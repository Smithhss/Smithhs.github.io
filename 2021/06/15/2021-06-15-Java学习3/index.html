<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java学习3 | Smith</title><meta name="keywords" content="Java"><meta name="author" content="Smith"><meta name="copyright" content="Smith"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java学习3"><meta name="application-name" content="Java学习3"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java学习3"><meta property="og:url" content="https://smithhs.cn/2021/06/15/2021-06-15-Java%E5%AD%A6%E4%B9%A03/index.html"><meta property="og:site_name" content="Smith"><meta property="og:description" content="常见算法简单认识算法 排序算法 冒泡排序接下来，我们学习一种算法叫排序算法，它可以价格无序的整数，排列成从小到大的形式（升序），或者从大到小的形式（降序） 排序算法有很多种，我们这里只学习比较简单的两种，一种是冒泡排序，一种是选择排序。学习算法我们先要搞清楚算法的流程，然后再去“推敲“如何写代码。（"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp"><meta property="article:author" content="Smith"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://smithhs.cn/2021/06/15/2021-06-15-Java%E5%AD%A6%E4%B9%A03/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.14/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":240},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-04 10:14:25',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>if (GLOBAL_CONFIG.preloader.source == "2" || GLOBAL_CONFIG.preloader.source == "3") {
  const loadingPercentage = document.getElementById("loading-percentage");
  let loadingPercentageTimer = setInterval(function() {
    var progressBar = document.querySelector(".pace-progress");
    if (!progressBar) return
    var currentValue = progressBar.getAttribute("data-progress-text");
    if (currentValue !== loadingPercentage.textContent) {
      loadingPercentage.textContent = currentValue;
      if (currentValue === "100%") {
        clearInterval(loadingPercentageTimer);
      }
    }
  }, 100);
}

const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://smithhs.cn/" title="博客" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="http://robot.onliu.cn/" title="Robot" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cupfox.png" alt="Robot"/><span class="back-menu-item-text">Robot</span></a><a class="back-menu-item" href="http://res.onliu.cn" title="Sale" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alandodo-1315761622.cos.ap-beijing.myqcloud.com/blog-tuce/tubiao.jpg" alt="Sale"/><span class="back-menu-item-text">Sale</span></a><a class="back-menu-item" href="http://se.onliu.cn/" title="资源共享" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alandodo-1315761622.cos.ap-beijing.myqcloud.com/blog/x126.png" alt="资源共享"/><span class="back-menu-item-text">资源共享</span></a><a class="back-menu-item" href="https://github.com/Smithhss" title="Github" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/GitHub.png" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Smith</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Android-Studio/" style="font-size: 1.05rem;">Android Studio<sup>1</sup></a><a href="/tags/App/" style="font-size: 1.05rem;">App<sup>2</sup></a><a href="/tags/Butterfly/" style="font-size: 1.05rem;">Butterfly<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/Cisco-Packet-Tracer/" style="font-size: 1.05rem;">Cisco Packet Tracer<sup>1</sup></a><a href="/tags/Easypan/" style="font-size: 1.05rem;">Easypan<sup>2</sup></a><a href="/tags/FurtherMathematics/" style="font-size: 1.05rem;">FurtherMathematics<sup>1</sup></a><a href="/tags/GPT/" style="font-size: 1.05rem;">GPT<sup>1</sup></a><a href="/tags/Git2/" style="font-size: 1.05rem;">Git2<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/JavaWeb/" style="font-size: 1.05rem;">JavaWeb<sup>2</sup></a><a href="/tags/Jrebel/" style="font-size: 1.05rem;">Jrebel<sup>1</sup></a><a href="/tags/LeetCode/" style="font-size: 1.05rem;">LeetCode<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>3</sup></a><a href="/tags/Markdown/" style="font-size: 1.05rem;">Markdown<sup>2</sup></a><a href="/tags/Maven/" style="font-size: 1.05rem;">Maven<sup>2</sup></a><a href="/tags/Mysql/" style="font-size: 1.05rem;">Mysql<sup>1</sup></a><a href="/tags/NoSql/" style="font-size: 1.05rem;">NoSql<sup>1</sup></a><a href="/tags/Nodejs/" style="font-size: 1.05rem;">Nodejs<sup>2</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>4</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>2</sup></a><a href="/tags/VMware/" style="font-size: 1.05rem;">VMware<sup>2</sup></a><a href="/tags/Vue/" style="font-size: 1.05rem;">Vue<sup>1</sup></a><a href="/tags/YouHou/" style="font-size: 1.05rem;">YouHou<sup>1</sup></a><a href="/tags/books/" style="font-size: 1.05rem;">books<sup>1</sup></a><a href="/tags/butterfly/" style="font-size: 1.05rem;">butterfly<sup>1</sup></a><a href="/tags/clash/" style="font-size: 1.05rem;">clash<sup>1</sup></a><a href="/tags/project/" style="font-size: 1.05rem;">project<sup>4</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/" style="font-size: 1.05rem;">开发框架<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" style="font-size: 1.05rem;">开发环境<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">数据结构与算法<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 1.05rem;">软件工程<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">17</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming/">Programming</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a></span></div></div><h1 class="post-title">Java学习3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time datetime="2021-06-15T07:24:00.000Z" title="发表于 2021-06-15 15:24:00">2021-06-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">65.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>244分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Java学习3"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为石家庄"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>石家庄</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><h2 id="简单认识算法"><a href="#简单认识算法" class="headerlink" title="简单认识算法"></a>简单认识算法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh72.png"></p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh73.png"></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>接下来，我们学习一种算法叫排序算法，它可以价格无序的整数，排列成从小到大的形式（升序），或者从大到小的形式（降序）</p>
<p>排序算法有很多种，我们这里只学习比较简单的两种，一种是冒泡排序，一种是选择排序。学习算法我们先要搞清楚算法的流程，然后再去“推敲“如何写代码。（<strong>注意，我这里用的次是推敲，也就是说算法这样的代码并不是一次成型的，是需要反复修改才能写好的</strong>）。</p>
<p>先来学习冒泡排序，先来介绍一下，冒泡排序的流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序核心思路：每次将相邻的两个元素继续比较</span><br><span class="line">如下图所示：</span><br><span class="line">   第一轮比较 <span class="number">3</span>次</span><br><span class="line">   第二轮比较 <span class="number">2</span>次</span><br><span class="line">   第三轮比较 <span class="number">1</span>次</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、准备一个数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个循环控制排几轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// i = 0  1  2           【5， 2， 3， 1】    次数</span></span><br><span class="line">            <span class="comment">// i = 0 第一轮            0   1   2         3</span></span><br><span class="line">            <span class="comment">// i = 1 第二轮            0   1             2</span></span><br><span class="line">            <span class="comment">// i = 2 第三轮            0                 1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个循环控制每轮比较几次。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断当前位置的元素值，是否大于后一个位置处的元素值，如果大则交换。</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><p>接下来，按照选择排序的流程编写代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、准备好一个数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//           0  1  2  3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、控制选择几轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// i = 0 第一轮    j = 1 2 3</span></span><br><span class="line">            <span class="comment">// i = 1 第二轮    j = 2 3</span></span><br><span class="line">            <span class="comment">// i = 2 第三轮    j = 3</span></span><br><span class="line">            <span class="comment">// 3、控制每轮选择几次。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断当前位置是否大于后面位置处的元素值，若大于则交换。</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh74.png"></p>
<p><strong>先聊一聊基本查找：</strong>假设我们要查找的元素是81，如果是基本查找的话，只能从0索引开始一个一个往后找，但是如果元素比较多，你要查找的元素比较靠后的话，这样查找的此处就比较多。性能比较差。</p>
<p><strong>再讲二分查找</strong>：二分查找的主要特点是，每次查找能排除一般元素，这样效率明显提高。<strong>但是二分查找要求比较苛刻，它要求元素必须是有序的，否则不能进行二分查找。</strong></p>
<ul>
<li>二分查找的核心思路</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>步：先定义两个变量，分别记录开始索引(left)和结束索引(right)</span><br><span class="line">第<span class="number">2</span>步：计算中间位置的索引，mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">第<span class="number">3</span>步：每次查找中间mid位置的元素，和目标元素key进行比较</span><br><span class="line">        如果中间位置元素比目标元素小，那就说明mid前面的元素都比目标元素小</span><br><span class="line">            此时：left = mid+<span class="number">1</span></span><br><span class="line">        如果中间位置元素比目标元素大，那说明mid后面的元素都比目标元素大</span><br><span class="line">            此时：right = mid-<span class="number">1</span></span><br><span class="line">        如果中间位置元素和目标元素相等，那说明mid就是我们要找的位置</span><br><span class="line">            此时：把mid返回		</span><br><span class="line">注意：一搬查找一次肯定是不够的，所以需要把第<span class="number">1</span>步和第<span class="number">2</span>步循环来做，只到left&gt;end就结束，如果最后还没有找到目标元素，就返回-<span class="number">1.</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握二分查找算法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、准备好一个数组。</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">23</span>, <span class="number">79</span>, <span class="number">81</span>, <span class="number">103</span>, <span class="number">127</span>, <span class="number">131</span>, <span class="number">147</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(binarySearch(arr, <span class="number">150</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.binarySearch(arr, <span class="number">81</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、定义两个变量，一个站在左边位置，一个站在右边位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个循环控制折半。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 3、每次折半，都算出中间位置处的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 4、判断当前要找的元素值，与中间位置处的元素值的大小情况。</span></span><br><span class="line">            <span class="keyword">if</span>(data &lt; arr[middle])&#123;</span><br><span class="line">                <span class="comment">// 往左边找，截止位置（右边位置） = 中间位置 - 1</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &gt; arr[middle])&#123;</span><br><span class="line">                <span class="comment">// 往右边找，起始位置（左边位置） = 中间位置 + 1</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 中间位置处的元素值，正好等于我们要找的元素值</span></span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// -1特殊结果，就代表没有找到数据！数组中不存在该数据！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>接下来，我们学习一个全新的知识，叫做正则表达式。<strong>正则表达式其实是由一些特殊的符号组成的，它代表的是某种规则。</strong></p>
<blockquote>
<p>正则表达式的作用1：用来校验字符串数据是否合法</p>
<p>正则表达式的作用2：可以从一段文本中查找满足要求的内容</p>
</blockquote>
<ul>
<li>不使用正则表达式，校验QQ号码代码是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、判断qq号码是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(qq == <span class="literal">null</span> || qq.startsWith(<span class="string">&quot;0&quot;</span>) || qq.length() &lt; <span class="number">6</span> || qq.length() &gt; <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、qq至少是不是null,不是以0开头的，满足6-20之间的长度。</span></span><br><span class="line">        <span class="comment">// 判断qq号码中是否都是数字。</span></span><br><span class="line">        <span class="comment">// qq = 2514ghd234</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; qq.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 根据索引提取当前位置处的字符。</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> qq.charAt(i);</span><br><span class="line">            <span class="comment">// 判断ch记住的字符，如果不是数字，qq号码不合法。</span></span><br><span class="line">            <span class="keyword">if</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3、说明qq号码肯定是合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用正则表达式代码是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ1</span><span class="params">(String qq)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qq != <span class="literal">null</span> &amp;&amp; qq.matches(<span class="string">&quot;[1-9]\\d&#123;5,19&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh75.png"></p>
<p>我们将这些规则，在代码中演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握正则表达式的书写规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、字符类(只能匹配单个字符)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));    <span class="comment">// [abc]只能匹配a、b、c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;e&quot;</span>.matches(<span class="string">&quot;[abcd]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;d&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));   <span class="comment">// [^abc] 不能是abc</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">// [a-zA-Z] 只能是a-z A-Z的字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>.matches(<span class="string">&quot;[a-zA-Z]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;k&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">// ： a到z，除了b和c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&quot;</span>)); <span class="comment">// false 注意：以上带 [内容] 的规则都只能用于匹配单个字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、预定义字符(只能匹配单个字符)  .  \d  \D   \s  \S  \w  \W</span></span><br><span class="line">        System.out.println(<span class="string">&quot;徐&quot;</span>.matches(<span class="string">&quot;.&quot;</span>)); <span class="comment">// .可以匹配任意字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;徐徐&quot;</span>.matches(<span class="string">&quot;.&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// \转义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// \n \t</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>));  <span class="comment">// \d: 0-9</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>.matches(<span class="string">&quot;\\s&quot;</span>));   <span class="comment">// \s: 代表一个空白字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\s&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\S&quot;</span>));  <span class="comment">// \S: 代表一个非空白字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>.matches(<span class="string">&quot;\\S&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>));  <span class="comment">// \w: [a-zA-Z_0-9]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;_&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;徐&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;徐&quot;</span>.matches(<span class="string">&quot;\\W&quot;</span>));  <span class="comment">// [^\w]不能是a-zA-Z_0-9</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\W&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;23232&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// false 注意：以上预定义字符都只能匹配单个字符。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、数量词： ?   *   +   &#123;n&#125;   &#123;n, &#125;  &#123;n, m&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\w?&quot;</span>));   <span class="comment">// ? 代表0次或1次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;\\w?&quot;</span>));    <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;\\w?&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12&quot;</span>.matches(<span class="string">&quot;\\w*&quot;</span>));   <span class="comment">// * 代表0次或多次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;\\w*&quot;</span>));        <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12张&quot;</span>.matches(<span class="string">&quot;\\w*&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12&quot;</span>.matches(<span class="string">&quot;\\w+&quot;</span>));   <span class="comment">// + 代表1次或多次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;\\w+&quot;</span>));       <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc12张&quot;</span>.matches(<span class="string">&quot;\\w+&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a3c&quot;</span>.matches(<span class="string">&quot;\\w&#123;3&#125;&quot;</span>));   <span class="comment">// &#123;3&#125; 代表要正好是n次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>.matches(<span class="string">&quot;\\w&#123;3&#125;&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="comment">// &#123;3,&#125; 代表是&gt;=3次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abcde徐&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,&#125;&quot;</span>));     <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc232d&quot;</span>.matches(<span class="string">&quot;\\w&#123;3,9&#125;&quot;</span>));     <span class="comment">// &#123;3, 9&#125; 代表是  大于等于3次，小于等于9次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、其他几个常用的符号：(?i)忽略大小写 、 或：| 、  分组：()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;(?i)abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.matches(<span class="string">&quot;(?i)abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aBc&quot;</span>.matches(<span class="string">&quot;a((?i)b)c&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABc&quot;</span>.matches(<span class="string">&quot;a((?i)b)c&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求1：要求要么是3个小写字母，要么是3个数字。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A12&quot;</span>.matches(<span class="string">&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：必须是”我爱“开头，中间可以是至少一个”编程“，最后至少是1个”666“</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我爱编程编程666666&quot;</span>.matches(<span class="string">&quot;我爱(编程)+(666)+&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;我爱编程编程66666&quot;</span>.matches(<span class="string">&quot;我爱(编程)+(666)+&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式应用案例"><a href="#正则表达式应用案例" class="headerlink" title="正则表达式应用案例"></a>正则表达式应用案例</h2><p>学习完正则表达式的规则之后，接下来我们再利用正则表达式，去校验几个实际案例。</p>
<ul>
<li>正则表达式校验手机号码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：校验用户输入的电话、邮箱、时间是否合法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        checkPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的电话号码(手机|座机): &quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">// 18676769999  010-3424242424 0104644535</span></span><br><span class="line">            <span class="keyword">if</span>(phone.matches(<span class="string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,7&#125;-?[1-9]\\d&#123;4,19&#125;)&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的号码格式正确~~~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的号码格式不正确~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用正则表达式校验邮箱是否正确</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        checkEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的邮箱： &quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * dlei0009@163.com</span></span><br><span class="line"><span class="comment">             * 25143242@qq.com</span></span><br><span class="line"><span class="comment">             * itheima@itcast.com.cn</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;2,&#125;@\\w&#123;2,20&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的邮箱格式正确~~~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的邮箱格式不正确~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用于查找信息"><a href="#用于查找信息" class="headerlink" title="用于查找信息"></a>用于查找信息</h2><p><strong>正则表达式的第二个作用：在一段文本中查找满足要求的内容</strong></p>
<h2 id="用于搜索替换、分割内容"><a href="#用于搜索替换、分割内容" class="headerlink" title="用于搜索替换、分割内容"></a>用于搜索替换、分割内容</h2><ul>
<li>正则表达式用于搜索替换、分割内容，需要结合String提供的如下方法完成:</li>
</ul>
<p>public string replaceAl1(String regex , string newStr)<br>按照正则表达式匹配的内容进行替换</p>
<p>public string[] split(String regex):<br>按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="认识异常"><a href="#认识异常" class="headerlink" title="认识异常"></a>认识异常</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh76.png"></p>
<blockquote>
<p><strong>先来演示一个运行时异常产生</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br><span class="line"><span class="comment">//5是一个不存在的索引，所以此时产生ArrayIndexOutOfBoundsExcpetion</span></span><br><span class="line">System.out.println(arr[<span class="number">5</span>]); </span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>再来演示一个编译时异常</strong></p>
</blockquote>
<p>我们在调用SimpleDateFormat对象的parse方法时，要求传递的参数必须和指定的日期格式一致，否则就会出现异常。 Java比较贴心，它为了更加强烈的提醒方法的调用者，设计了编译时异常，它把异常的提醒提前了，你调用方法是否真的有问题，只要可能有问题就给你报出异常提示（红色波浪线）。</p>
<p> <strong>编译时异常的目的：意思就是告诉你，这里小心点容易出错，仔细检查一下</strong></p>
<p>有人说，我检查过了，我确认我的代码没问题，为了让它不报错，继续将代码写下去。我们这里有两种解决方案。</p>
<ul>
<li>第一种：使用throws在方法上声明，意思就是告诉下一个调用者，这里面可能有异常啊，你调用时注意一下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：认识异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2028-11-11 10:24&quot;</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种：使用try…catch语句块异常进行处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2028-11-11 10:24&quot;</span>);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，关于什么是异常，我们就先认识到这里。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul>
<li>自定义异常<br>Java无法为这个世界上全部的问题都提供异常类来代表，如果企业自己的某种问题，想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。</li>
</ul>
<p>我们通过一个实际场景，来给大家演示自定义异常。</p>
<blockquote>
<p>需求：写一个saveAge(int age)方法，在方法中对参数age进行判断，如果age&lt;0或者&gt;&#x3D;150就认为年龄不合法，如果年龄不合法，就给调用者抛出一个年龄非法异常。</p>
<p>分析：Java的API中是没有年龄非常这个异常的，所以我们可以自定义一个异常类，用来表示年龄非法异常，然后再方法中抛出自定义异常即可。</p>
</blockquote>
<ul>
<li>先写一个异常类AgeIllegalException（这是自己取的名字，名字取得很奈斯），继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、必须让这个类继承自Exception，才能成为一个编译时异常类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再写一个测试类，在测试类中定义一个saveAge(int age)方法，对age判断如果年龄不在0~150之间，就抛出一个AgeIllegalException异常对象给调用者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：保存一个合法的年</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveAge2(<span class="number">225</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge2底层执行是成功的！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge2底层执行是出现bug的！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、在方法中对age进行判断，不合法则抛出AgeIllegalException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄被成功保存： &quot;</span> + age);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用一个异常对象封装这个问题</span></span><br><span class="line">            <span class="comment">// throw 抛出去这个异常对象</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;/age is illegal, your age is &quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意咯，自定义异常可能是编译时异常，也可以是运行时异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果自定义异常类继承Excpetion，则是编译时异常。</span><br><span class="line">	特点：方法中抛出的是编译时异常，必须在方法上使用<span class="keyword">throws</span>声明，强制调用者处理。</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>如果自定义异常类继承RuntimeException，则运行时异常。</span><br><span class="line">	特点：方法中抛出的是运行时异常，不需要在方法上用<span class="keyword">throws</span>声明。</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义异常的种类</li>
</ul>
<ol>
<li>自定义运行时异常</li>
</ol>
<ul>
<li>定义一个异常类继承RuntimeException.</li>
<li>重写构造器。</li>
<li>通过throw new异常类(xxx)来创建异常对象并抛出。<br>编译阶段不报错,提醒不强烈,运行时才可能出现!!</li>
</ul>
<ol start="2">
<li>自定义编译时异常</li>
</ol>
<ul>
<li>定义一个异常类继承Exception.</li>
<li>重写构造器。</li>
<li>通过throw new异常类(xoxx)来创建异常对象并抛出。<br>编译阶段就报错,提醒更加强烈!</li>
</ul>
<ul>
<li>异常有什么作用?</li>
</ul>
<ol>
<li><p>异常是用来查寻系统Bug的关键参考信息!</p>
</li>
<li><p>异常示以作为方法内部的一种特殊返回值，以便通知上层调用者底层的执行情况!</p>
</li>
</ol>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><ul>
<li>开发中对于异常的常见处理方式<br>方法A<br>方法B 异常，抛给调用者<br>方法C 异常，抛给调用者</li>
</ul>
<p>我们看一个代码，main方法调用test1方法，test1方法调用test2方法，test1和test2方法中多有扔异常。</p>
<ul>
<li>第一种处理方式是，在main方法中对异常进行try…catch捕获处理了，给出友好提示。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您要找的文件不存在！！&quot;</span>);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印出这个异常对象的信息。记录下来。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您要解析的时间有问题了！&quot;</span>);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印出这个异常对象的信息。记录下来。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, ParseException &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2028-11-11 10:24:11&quot;</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取文件的。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/meinv.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种处理方式是：在main方法中对异常进行捕获，并尝试修复</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握异常的处理方式：捕获异常，尝试修复。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求：调用一个方法，让用户输入一个合适的价格返回为止。</span></span><br><span class="line">        <span class="comment">// 尝试修复</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getMoney());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入合法的数字！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入合适的价格：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">            <span class="keyword">if</span>(money &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> money;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的价格是不合适的！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>捕获异常，记录异常并响应合适的信息给用户</li>
<li>捕获异常，尝试重新修复</li>
</ol>
<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>集合体系结构<br>Collection Map<br>单列集合    双列集合</li>
</ul>
<ul>
<li>collection代表单列集合，每个元素（数据）只包含一个值。</li>
<li>Map代表双列集合，每个元素包含两个值(键值对)。</li>
</ul>
<ul>
<li>Collection集合体系<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh77.png"></li>
</ul>
<p>各种集合的特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单确认一下Collection集合的特点</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//存取顺序一致，可以重复，有索引</span></span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">//[java1, java2, java1, java2] </span></span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">//存取顺序不一致，不重复，无索引</span></span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">//[java3, java2, java1] </span></span><br></pre></td></tr></table></figure>

<h2 id="Collection的常用方法"><a href="#Collection的常用方法" class="headerlink" title="Collection的常用方法"></a>Collection的常用方法</h2><ul>
<li>为啥要先学collection的常用方法?</li>
</ul>
<ul>
<li>Collection是单列集合的祖宗，它规定的方法（功能）是全部单列集合都会继承的。collection的常见方法如下:</li>
</ul>
<p>public boolean add(E e)     把给定的对象添加到当前集合中<br>public void clear()         清空集合中所有的元素<br>public boolean remove(E e)  把给定的对象在当前集合中删除<br>public boolean contains(object obj)   判断当前集合中是否包含给定的对象<br>public boolean isEmpty()    判断当前集合是否为空<br>public int size()           返回集合中元素的个数。<br>public object[ ] toArray()  把集合中的元素，存储到数组中</p>
<blockquote>
<p>Collection集合的一些常用方法，这些方法所有Collection实现类都可以使用。 这里我们以创建ArrayList为例，来演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//1.public boolean add(E e): 添加元素到集合</span></span><br><span class="line">c.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">System.out.println(c); <span class="comment">//打印: [java1, java1, java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.public int size(): 获取集合的大小</span></span><br><span class="line">System.out.println(c.size()); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.public boolean contains(Object obj): 判断集合中是否包含某个元素</span></span><br><span class="line">System.out.println(c.contains(<span class="string">&quot;java1&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(c.contains(<span class="string">&quot;Java1&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.pubilc boolean remove(E e): 删除某个元素，如果有多个重复元素只能删除第一个</span></span><br><span class="line">System.out.println(c.remove(<span class="string">&quot;java1&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(c); <span class="comment">//打印: [java1,java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.public void clear(): 清空集合的元素</span></span><br><span class="line">c.clear(); </span><br><span class="line">System.out.println(c); <span class="comment">//打印：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.public boolean isEmpty(): 判断集合是否为空 是空返回true 反之返回false</span></span><br><span class="line">System.out.println(c.isEmpty()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.public Object[] toArray(): 把集合转换为数组</span></span><br><span class="line">Object[] array = c.toArray();</span><br><span class="line">System.out.println(Arrays.toString(array)); <span class="comment">//[java1,java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.如果想把集合转换为指定类型的数组，可以使用下面的代码</span></span><br><span class="line">String[] array1 = c.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[c.size()]);</span><br><span class="line">System.out.println(Arrays.toString(array1)); <span class="comment">//[java1,java2, java2, java3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//9.还可以把一个集合中的元素，添加到另一个集合中</span></span><br><span class="line">Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c1.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">c1.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c2.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">c2.add(<span class="string">&quot;java4&quot;</span>);</span><br><span class="line">c1.addAll(c2); <span class="comment">//把c2集合中的全部元素，添加到c1集合中去</span></span><br><span class="line">System.out.println(c1); <span class="comment">//[java1, java2, java3, java4]</span></span><br></pre></td></tr></table></figure>

<p>最后，我们总结一下Collection集合的常用功能有哪些，ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet集合都可以调用下面的方法。</p>
<h2 id="Collection的遍历方式"><a href="#Collection的遍历方式" class="headerlink" title="Collection的遍历方式"></a>Collection的遍历方式</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li><p>迭代器概述<br>迭代器是用来遍历集合的专用方式(数组没有迭代器)，在Java中迭代器的代表是lterator。</p>
</li>
<li><p>Collection集合获取迭代器的方法<br>Iterator<E> iterator()    返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素</p>
</li>
<li><p>lterator迭代器中的常用方法<br>boolean hasNext()         询问当前位置是否有元紊存在，存在返回true ,不存在返回false<br>E next()                  获取当前位置的元素,并同时将迭代器对象指向下一个元素处。</p>
</li>
</ul>
<p>接下来学习的迭代器就是一种集合的通用遍历方式。</p>
<p>代码写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line">System.out.println(c); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：先获取迭代器对象</span></span><br><span class="line"><span class="comment">//解释：Iterator就是迭代器对象，用于遍历集合的工具)</span></span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：用于判断当前位置是否有元素可以获取</span></span><br><span class="line"><span class="comment">//解释：hasNext()方法返回true，说明有元素可以获取；反之没有</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//第三步：获取当前位置的元素，然后自动指向下一个元素.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器代码的原理如下：</p>
<ul>
<li>当调用iterator()方法获取迭代器时，当前指向第一个元素</li>
<li>hasNext()方法则判断这个位置是否有元素，如果有则返回true，进入循环</li>
<li>调用next()方法获取元素，并将当月元素指向下一个位置，</li>
<li>等下次循环时，则获取下一个元素，依此内推</li>
</ul>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><ul>
<li>增强for循环<br>格式:<br>for(元素的数据类型变量名:数组或者集合){<br>}<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(String s : c)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>增强for可以用来遍历集合或者数组。</li>
<li>增强for遍历集合，本质就是迭代器遍历集合的简化写法。</li>
</ul>
<h3 id="forEach遍历集合"><a href="#forEach遍历集合" class="headerlink" title="forEach遍历集合"></a>forEach遍历集合</h3><p>在JDK8版本以后还提供了一个forEach方法也可以遍历集合，如果下图所示：</p>
<p>我们发现forEach方法的参数是一个Consumer接口，而Consumer是一个函数式接口，所以可以传递Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">c.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;小昭&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;灭绝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用forEach方法</span></span><br><span class="line"><span class="comment">//由于参数是一个Consumer接口，所以可以传递匿名内部类</span></span><br><span class="line">c.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用lambda表达式对匿名内部类进行简化</span></span><br><span class="line">c.forEach(s-&gt;System.out.println(s)); <span class="comment">//[赵敏, 小昭, 素素, 灭绝]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历集合案例"><a href="#遍历集合案例" class="headerlink" title="遍历集合案例"></a>遍历集合案例</h3><p>接下来，我们看一个案例，在集合中存储自定义的对象，并遍历。具体要求如下</p>
<p>首先，我们得写一个电影类，用来描述每一步电影应该有哪些信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//电影名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score; <span class="comment">//评分</span></span><br><span class="line">    <span class="keyword">private</span> String actor; <span class="comment">//演员</span></span><br><span class="line">    <span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> score, String actor)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.score=score;</span><br><span class="line">        <span class="built_in">this</span>.actor=actor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，再创建一个测试类，完成上面的需求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Collection&lt;Movie&gt; movies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">MOvie</span>(<span class="string">&quot;《肖申克的救赎》&quot;</span>, <span class="number">9.7</span>, <span class="string">&quot;罗宾斯&quot;</span>));</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">MOvie</span>(<span class="string">&quot;《霸王别姬》&quot;</span>, <span class="number">9.6</span>, <span class="string">&quot;张国荣、张丰毅&quot;</span>));</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">MOvie</span>(<span class="string">&quot;《阿甘正传》&quot;</span>, <span class="number">9.5</span>, <span class="string">&quot;汤姆汉克斯&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Movie movie : movies)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电影名：&quot;</span> + movie.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;评分：&quot;</span> + movie.getScore());</span><br><span class="line">            System.out.println(<span class="string">&quot;主演：&quot;</span> + movie.getActor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的内存原理如下图所示：当往集合中存对象时，实际上存储的是对象的地址值</p>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h3 id="特点、特有方式"><a href="#特点、特有方式" class="headerlink" title="特点、特有方式"></a>特点、特有方式</h3><ul>
<li>List集合的特有方法</li>
</ul>
<ul>
<li>List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了。</li>
</ul>
<p>方法名称<br>说明<br>void add(int index,E element)         在此集合中的指定位置插入指定的元素<br>E remove(int index)                    删除指定索引处的元素，返回被删除的元素<br>E set(int index,E element)            修改指定索引处的元素，返回被修改的元素<br>E get(int index)                       返回指定索引处的元素</p>
<p>List集合是索引的，所以多了一些有索引操作的方法，如下图所示：</p>
<p>接下来，我们用代码演示一下这几个方法的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个ArrayList集合对象（有序、有索引、可以重复）</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;蜘蛛精&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;至尊宝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;至尊宝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;牛夫人&quot;</span>); </span><br><span class="line">System.out.println(list); <span class="comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.public void add(int index, E element): 在某个索引位置插入元素</span></span><br><span class="line">list.add(<span class="number">2</span>, <span class="string">&quot;紫霞仙子&quot;</span>);</span><br><span class="line">System.out.println(list); <span class="comment">//[蜘蛛精, 至尊宝, 紫霞仙子, 至尊宝, 牛夫人]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.public E remove(int index): 根据索引删除元素, 返回被删除的元素</span></span><br><span class="line">System.out.println(list.remove(<span class="number">2</span>)); <span class="comment">//紫霞仙子</span></span><br><span class="line">System.out.println(list);<span class="comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛夫人]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.public E get(int index): 返回集合中指定位置的元素</span></span><br><span class="line">System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.public E set(int index, E e): 修改索引位置处的元素，修改后，会返回原数据</span></span><br><span class="line">System.out.println(list.set(<span class="number">3</span>,<span class="string">&quot;牛魔王&quot;</span>)); <span class="comment">//牛夫人</span></span><br><span class="line">System.out.println(list); <span class="comment">//[蜘蛛精, 至尊宝, 至尊宝, 牛魔王]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><ul>
<li>List集合支持的遍历方式</li>
</ul>
<ol>
<li>for循环(因为List集合有索引)</li>
<li>迭代器</li>
<li>增强for循环</li>
<li>Lambda表达式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;蜘蛛精&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;至尊宝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;糖宝宝&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; list.size(); i++)&#123;</span><br><span class="line">    <span class="comment">//i = 0, 1, 2</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.增强for遍历</span></span><br><span class="line"><span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.lambda表达式遍历</span></span><br><span class="line">list.forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList集合的底层原理"><a href="#ArrayList集合的底层原理" class="headerlink" title="ArrayList集合的底层原理"></a>ArrayList集合的底层原理</h3><ol>
<li>ArrayList集合的底层原理<ol>
<li>利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组</li>
<li>添加第一个元素时，底层会创建一个新的长度为10的数组</li>
<li>存满时，会扩容1.5倍</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li>
</ol>
</li>
</ol>
<ul>
<li>数组的特点<br>查询快、增删慢</li>
</ul>
<ul>
<li>查询速度快(注意∶是根据索引查询数据快)︰查询数据通过地址值和索引定位，查询任意数据耗时相同。</li>
<li>删除效率低:可能需要把后面很多的数据进行前移。</li>
<li>添加效率极低:可能需要把后面很多的数据后移，再添加元素;或者也可能需要进行数组的扩容。</li>
</ul>
<ol start="2">
<li>ArrayList集合话合的应用场景</li>
</ol>
<p>1、ArrayList适合:根据索引查询数据, 比如根据随机索查询数据(高效)! 或考数据量不是很大时!<br>2、ArrayList不适合:数据量大的同时，又要频繁的进行增删操作!</p>
<h3 id="LinkList集合的底层原理"><a href="#LinkList集合的底层原理" class="headerlink" title="LinkList集合的底层原理"></a>LinkList集合的底层原理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh78.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh79.png"></p>
<ul>
<li>LinkedList集合的底层原理</li>
</ul>
<ul>
<li>基于双链表实现的。</li>
<li>特点:查询慢，增删相对较快，但对首尾元素进行增删改查的速度是极快的。</li>
</ul>
<ul>
<li>LinkedList新增了:很多首尾操作的特有方法。<br>方法名称<br>说明<br>public void addFirst(E e)            在该列表开头插入指定的元素<br>public void addLast(E e)             将指定的元素追加到此列表的末尾<br>public E getFirst()                  返回此列表中的第一个元素<br>public E getLast()                   返回此列表中的最后一个元素<br>public E removeFirst()               从此列表中删除并返回第一个元素<br>public E removeLast()                从此列表中删除并返回最后一个元素</li>
</ul>
<ol>
<li>LinkedList的应用场景之一:可以用来设计队列<br>只是在首尾增册删元素，用LinkedList来实现很合话!</li>
</ol>
<p>入队   出队<br><strong>先进先出，后进后出</strong></p>
<ol start="2">
<li>LinkedList的应用场景之一:可以用来设计栈<br>只是在首部增删元素，用LinkedList来实现很合话!</li>
</ol>
<p>栈顶元素<br>数据进入栈模型的过程称为:压&#x2F;进栈(push)<br>数据离开栈模型的过程称为:弹&#x2F;出栈(pop)<br>栈底元素</p>
<p><strong>后进先出，先进后出</strong></p>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Set系列集合特点:无序:添加数据的顺序和获取出的数据顺序不一致;不重复;无索引;<br>HashSet:无序、不重复、无索引。<br>LinkedHashSet:有序、不重复、无索引。<br>TreeSet排序、不重复、无索引。</li>
</ul>
<p>下面我们用代码简单演示一下，每一种Set集合的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set&lt;Integer&gt; set = new HashSet&lt;&gt;();	//无序、无索引、不重复</span></span><br><span class="line"><span class="comment">//Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); //有序、无索引、不重复</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(); <span class="comment">//可排序(升序)、无索引、不重复</span></span><br><span class="line">set.add(<span class="number">666</span>);</span><br><span class="line">set.add(<span class="number">555</span>);</span><br><span class="line">set.add(<span class="number">555</span>);</span><br><span class="line">set.add(<span class="number">888</span>);</span><br><span class="line">set.add(<span class="number">888</span>);</span><br><span class="line">set.add(<span class="number">777</span>);</span><br><span class="line">set.add(<span class="number">777</span>);</span><br><span class="line">System.out.println(set); <span class="comment">//[555, 666, 777, 888]</span></span><br></pre></td></tr></table></figure>

<h3 id="HashSet集合的底层原理"><a href="#HashSet集合的底层原理" class="headerlink" title="HashSet集合的底层原理"></a>HashSet集合的底层原理</h3><ul>
<li>哈希值</li>
</ul>
<ul>
<li>就是一个int类型的数值，Java中每个对象都有一个哈希值。</li>
<li>Java中的所有对象，都可以调用Obejct类提供的hashCode方法，返回该对象自己的哈希值。<br>public int hashCode():          返回对象的哈希码值。</li>
</ul>
<ul>
<li>对象哈希值的特点</li>
</ul>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的。</li>
<li>不同的对象，它们的哈希值一般不相同，但也有可能会相同(哈希碰撞)。<br>int (-21亿多~21亿多)             45亿个对象</li>
</ul>
<ul>
<li><p>HashSet集合的底层原理<br>基于哈希表实现。<br> *哈希表是一种增删改查数据，性能都较好的数据结构。</p>
</li>
<li><p>哈希表<br>JDK8之前，哈希表&#x3D;数组+链表<br>JDK8开始，哈希表&#x3D;数组+链表+红黑树<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh80.png"></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh81.png"></p>
<ul>
<li>深入理解HashSet集合去重复的机制。</li>
</ul>
<ul>
<li>HashSet集合默认不能对内容一样的两个不同对象去重复!<br>比如内容一样的两个学生对象存入到HashSet集合中去，HashSet集合是不能去重复的!</li>
</ul>
<p>HashSet存储元素的原理，依赖于两个方法：一个是hashCode方法用来确定在底层数组中存储的位置，另一个是用equals方法判断新添加的元素是否和集合中已有的元素相同。</p>
<p>要想保证在HashSet集合中没有重复元素，我们需要重写元素类的hashCode和equals方法。比如以下面的Student类为例，假设把Student类的对象作为HashSet集合的元素，想要让学生的姓名和年龄相同，就认为元素重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height; <span class="comment">//身高</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        <span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按快捷键生成hashCode和equals方法</span></span><br><span class="line">    <span class="comment">//alt+insert 选择 hashCode and equals</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != student.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Double.compare(student.height, height) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(student.name) : student.name == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="type">long</span> temp;</span><br><span class="line">        result = name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        temp = Double.doubleToLongBits(height);</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="type">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，写一个测试类，往HashSet集合中存储Student对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line">        </span><br><span class="line">        students.add(s1);</span><br><span class="line">        students.add(s2);</span><br><span class="line">        students.add(s3);</span><br><span class="line">        students.add(s4);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Student s : students)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下，我们发现存了两个蜘蛛精，当时实际打印出来只有一个，而且是无序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;牛魔王&#x27;</span>, age=<span class="number">48</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;至尊宝&#x27;</span>, age=<span class="number">20</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;蜘蛛精&#x27;</span>, age=<span class="number">23</span>, height=<span class="number">169.6</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSet集合的底层原理"><a href="#LinkedHashSet集合的底层原理" class="headerlink" title="LinkedHashSet集合的底层原理"></a>LinkedHashSet集合的底层原理</h3><ul>
<li>LinkedHashSet底层原理</li>
</ul>
<ul>
<li>依然是基于哈希表(数组、链表、红黑树)实现的。</li>
<li>但是，它的每个元素都额外的多了一个双链表的机制记录它前后元素的位置。</li>
</ul>
<h3 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h3><ul>
<li>TreeSet</li>
</ul>
<ul>
<li>特点:不重复、无索引、可排序(默认升序排序，按照元素的大小，由小到大排序)</li>
<li>底层是基于红黑树实现的排序。</li>
</ul>
<ul>
<li>注意:</li>
</ul>
<ul>
<li>对于数值类型:Integer , Double，默认按照数值本身的大小进行升序排序。</li>
<li>对于字符串类型:默认按照首字符的编号升序排序。</li>
<li>对于自定义类型如Student对象，TreeSet默认是无法直接排序的。</li>
</ul>
<p>TreeSet集合的特点是可以对元素进行排序，但是必须指定元素的排序规则。</p>
<p>如果往集合中存储String类型的元素，或者Integer类型的元素，它们本身就具备排序规则，所以直接就可以排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set1= <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">set1.add(<span class="number">8</span>);</span><br><span class="line">set1.add(<span class="number">6</span>);</span><br><span class="line">set1.add(<span class="number">4</span>);</span><br><span class="line">set1.add(<span class="number">3</span>);</span><br><span class="line">set1.add(<span class="number">7</span>);</span><br><span class="line">set1.add(<span class="number">1</span>);</span><br><span class="line">set1.add(<span class="number">5</span>);</span><br><span class="line">set1.add(<span class="number">2</span>);</span><br><span class="line">System.out.println(set1); <span class="comment">//[1,2,3,4,5,6,7,8]</span></span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; set2= <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">set2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">set2.add(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">System.out.println(set1); <span class="comment">//[a,b,c,d,e,f,g]</span></span><br></pre></td></tr></table></figure>


<p>如果往TreeSet集合中存储自定义类型的元素，比如说Student类型，则需要我们自己指定排序规则，否则会出现异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建TreeSet集合，元素为Student类型</span></span><br><span class="line">Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建4个Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">23</span>, <span class="number">169.8</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Studnet对象到集合</span></span><br><span class="line">students.add(s1);</span><br><span class="line">students.add(s2);</span><br><span class="line">students.add(s3);</span><br><span class="line">students.add(s4);</span><br><span class="line">System.out.println(students); </span><br></pre></td></tr></table></figure>

<p>此时运行代码，会直接报错。原因是TreeSet不知道按照什么条件对Student对象来排序。</p>
<ul>
<li>自定义排序规则<br>TreeSet集合存储自定义类型的对象时，必须指定排序规则，支持如下两种方式来指定比较规则。<blockquote>
<p>第一种：让元素的类实现Comparable接口，重写compareTo方法</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>第二种：在创建TreeSet集合时，通过构造方法传递Compartor比较器对象</p>
</blockquote>
<p>public TreeSet(Comparator&lt;? super E&gt; comparator)</p>
<ul>
<li><strong>排序方式1：</strong>我们先来演示第一种排序方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：先让Student类，实现Comparable接口</span></span><br><span class="line"><span class="comment">//注意：Student类的对象是作为TreeSet集合的元素的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">	<span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        <span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步：重写compareTo方法</span></span><br><span class="line">    <span class="comment">//按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原理：</span></span><br><span class="line"><span class="comment">    在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的</span></span><br><span class="line"><span class="comment">    结果是正数、负数、还是零，决定元素放在后面、前面还是不存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">//this：表示将要添加进去的Student对象</span></span><br><span class="line">        <span class="comment">//o: 表示集合中已有的Student对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，再运行测试类，结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;至尊宝&#x27;</span>, age=<span class="number">20</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;紫霞&#x27;</span>, age=<span class="number">20</span>, height=<span class="number">169.8</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;蜘蛛精&#x27;</span>, age=<span class="number">23</span>, height=<span class="number">169.6</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;牛魔王&#x27;</span>, age=<span class="number">48</span>, height=<span class="number">169.6</span>&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>排序方式2：</strong>接下来演示第二种排序方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建TreeSet集合时，传递比较器对象排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原理：当调用add方法时，底层会先用比较器，根据Comparator的compare方是正数、负数、还是零，决定谁在后，谁在前，谁不存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//下面代码中是按照学生的年龄升序排序</span></span><br><span class="line">Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="comment">//需求：按照学生的身高排序</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1,o2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建4个Student对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">20</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">23</span>, <span class="number">169.8</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>, <span class="number">169.6</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>,<span class="number">48</span>, <span class="number">169.6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Studnet对象到集合</span></span><br><span class="line">students.add(s1);</span><br><span class="line">students.add(s2);</span><br><span class="line">students.add(s3);</span><br><span class="line">students.add(s4);</span><br><span class="line">System.out.println(students); </span><br></pre></td></tr></table></figure>

<ul>
<li>两种方式中，关于返回值的规则;</li>
</ul>
<ul>
<li>如果认为第一个元素&gt;第二个元素返回正整数即可。</li>
<li>如果认为第一个元素&lt;第二个元素返回负整数即可。</li>
<li>如果认为第一个元素&#x3D;第二个元素返回0即可，此时TreeSet集合只会保留一个元素，认为两者重复。<br>注意:如果类本身有实现Comparable接口，TreeSet集合同时也自带比较器，默认使用集合自带的比较器排序。</li>
</ul>
<h2 id="注意事项：集合的并发修改异常问题"><a href="#注意事项：集合的并发修改异常问题" class="headerlink" title="注意事项：集合的并发修改异常问题"></a>注意事项：集合的并发修改异常问题</h2><ul>
<li>总结：</li>
</ul>
<ol>
<li>如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据?<br>用ArrayList集合(有序、可重复、有索引)，底层基于数组的。(常用)</li>
<li>如果希望记住元素的添加顺序，且增删首尾数据的情况较多?<br>用LinkedList集合(有序、可重复、有索引)，底层基于双链表实现的。</li>
<li>如果不在意元素顺序，也没有重复元素需要存储，只希望增删改查都快?<br>用HashSet集合(无序，不重复，无索引)，底层基于哈希表实现的。(常用)</li>
<li>如果希望记住元素的添加顺序，也没有重复元素需要存储，且希望增删改查都快?<br>用LinkedHashSet集合(有序，不重复，无索引)，底层基于哈希表和双链表。</li>
<li>如果要对元素进行排序，也没有重复元素需要存储?且希望增删改查都快?<br>用TreeSet集合，基于红黑树实现。</li>
</ol>
<ul>
<li>集合的并发修改异常</li>
</ul>
<ul>
<li>使用迭代器遍历集合时，又同时在删除集合中的数据，程序就会出现并发修改异常的错误。</li>
<li>由于增强for循环遍历集合就是迭代器遍历集合的简化写法，因此，使用增强for循环遍历集合，又在同时删除集合中的数据时，程序也会出现并发修改异常的错误</li>
</ul>
<ul>
<li>怎么保证遍历集合同时删除数据时不出bug?</li>
</ul>
<ul>
<li>使用迭代器遍历集合，但用迭代器自己的删除方法删除数据即可。</li>
<li>如果能用for循环遍历时:可以倒着遍历并删除;或者从前往后遍历，但删除元素后做i –操作。</li>
</ul>
<h1 id="Collection的其他相关知识"><a href="#Collection的其他相关知识" class="headerlink" title="Collection的其他相关知识"></a>Collection的其他相关知识</h1><h2 id="前置知识：可变参数"><a href="#前置知识：可变参数" class="headerlink" title="前置知识：可变参数"></a>前置知识：可变参数</h2><ul>
<li>可变参数</li>
</ul>
<ul>
<li>就是一种特殊形参，定义在方法、构造器的形参列表里，格式是:数据类型…参数名称;</li>
</ul>
<blockquote>
<ul>
<li><p><strong>可变参数是一种特殊的形式参数，定义在方法、构造器的形参列表处，它可以让方法接收多个同类型的实际参数。</strong></p>
</li>
<li><p><strong>可变参数在方法内部，本质上是一个数组</strong></p>
</li>
</ul>
</blockquote>
<p>接下来，我们编写代码来演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//不传递参数，下面的nums长度则为0, 打印元素是[]</span></span><br><span class="line">        test();	</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传递3个参数，下面的nums长度为3，打印元素是[10, 20, 30]</span></span><br><span class="line">        test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传递一个数组，下面数组长度为4，打印元素是[10,20,30,40] </span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;</span><br><span class="line">        test(arr); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>...nums)</span>&#123;</span><br><span class="line">        <span class="comment">//可变参数在方法内部，本质上是一个数组</span></span><br><span class="line">        System.out.println(nums.length);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还有一些错误写法，需要让大家写代码时注意一下</p>
<blockquote>
<ul>
<li><p><strong>一个形参列表中，只能有一个可变参数；否则会报错</strong></p>
</li>
<li><p><strong>一个形参列表中如果多个参数，可变参数需要写在最后；否则会报错</strong></p>
</li>
</ul>
</blockquote>
<ul>
<li>可变参数的特点和好处</li>
</ul>
<ul>
<li>特点:可以不传数据给它;可以传一个或者同时传多个数据给它;也可以传一个数组给它。</li>
<li>好处:常常用来灵活的接收数据。</li>
</ul>
<ul>
<li>可变参数的注意事项:</li>
</ul>
<ul>
<li>可变参数在方法内部就是一个数组。</li>
<li>一个形参列表中可变参数只能有一个</li>
<li>可变参数必须放在形参列表的最后面</li>
</ul>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><ul>
<li>collections</li>
</ul>
<ul>
<li>是一个用来操作集合的工具类</li>
</ul>
<ul>
<li>Collections提供的常用静态方法<br>方法名称        说明<br>public static <T> boolean addA11(Collection&lt;? super T&gt; c, T… elements)<br>给集合批呈添加元素</li>
</ul>
<p>public static void shuffle(List&lt;?&gt; list)<br>打乱List集合中的元素顺序</p>
<p>public static <T> void sort(List<T>list)<br>对List集合中的元紊进行升序排序</p>
<p>public static <T> void sort(List<T> list,Comparator&lt;? super T c)<br>对List集合中元素，按照比较器对象指定的规则进行排序</p>
<p>我们把这些方法用代码来演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T...e)</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.public static void shuffle(List&lt;?&gt; list)：对集合打乱顺序</span></span><br><span class="line">        Collections.shuffle(names);</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们往集合中存储的元素要么是Stirng类型，要么是Integer类型，他们本来就有一种自然顺序所以可以直接排序。但是如果我们往List集合中存储Student对象，这个时候想要对List集合进行排序自定义比较规则的。指定排序规则有两种方式，如下：</p>
<blockquote>
<p><strong>排序方式1：让元素实现Comparable接口，重写compareTo方法</strong></p>
</blockquote>
<p>比如现在想要往集合中存储Studdent对象，首先需要准备一个Student类，实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//排序时：底层会自动调用此方法，this和o表示需要比较的两个对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span>&#123;</span><br><span class="line">        <span class="comment">//需求：按照年龄升序排序</span></span><br><span class="line">        <span class="comment">//如果返回正数：说明左边对象的年龄&gt;右边对象的年龄</span></span><br><span class="line">        <span class="comment">//如果返回负数：说明左边对象的年龄&lt;右边对象的年龄，</span></span><br><span class="line">        <span class="comment">//如果返回0：说明左边对象的年龄和右边对象的年龄相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...getter、setter、constructor..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再使用<code>Collections.sort(list集合)</code>对List集合排序，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.public static &lt;T&gt; void short(List&lt;T list): 对List集合排序</span></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>,<span class="number">23</span>,<span class="number">169.7</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">22</span>,<span class="number">169.8</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>,<span class="number">22</span>,<span class="number">169.8</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>,<span class="number">26</span>,<span class="number">169.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较；</span></span><br><span class="line"><span class="comment">	每次比较时，会用一个Student对象调用compareTo方法和另一个Student对象进行比较；</span></span><br><span class="line"><span class="comment">	根据compareTo方法返回的结果是正数、负数，零来决定谁大，谁小，谁相等，重新排序元素的位置</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：这些都是sort方法底层自动完成的，想要完全理解，必须要懂排序算法才行；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Collections.sort(students);	</span><br><span class="line">System.out.println(students);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>排序方式2：使用调用sort方法是，传递比较器</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原理：sort方法底层会遍历students集合中的每一个元素，采用排序算法，将任意两个元素两两比较；</span></span><br><span class="line"><span class="comment">	每次比较，会将比较的两个元素传递给Comparator比较器对象的compare方法的两个参数o1和o2,</span></span><br><span class="line"><span class="comment">	根据compare方法的返回结果是正数，负数，或者0来决定谁大，谁小，谁相等，重新排序元素的位置</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：这些都是sort方法底层自动完成的，不需要我们完全理解，想要理解它必须要懂排序算法才行.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Collections.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);	</span><br><span class="line">System.out.println(students);</span><br></pre></td></tr></table></figure>
<h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="斗地主案例"><a href="#斗地主案例" class="headerlink" title="斗地主案例"></a>斗地主案例</h3><p>我们先分析一下业务需求：</p>
<ul>
<li>总共有54张牌，每一张牌有花色和点数两个属性、为了排序还可以再加一个序号</li>
<li>点数可以是：<code>“3”,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;</code></li>
<li>花色可以是：<code>“♣”,&quot;♠&quot;,&quot;♥&quot;,&quot;♦&quot;</code></li>
<li>斗地主时：三个玩家没人手里17张牌，剩余3张牌作为底牌</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：为了表示每一张牌有哪些属性，首先应该新建一个扑克牌的类</span><br><span class="line">第二步：启动游戏时，就应该提前准备好<span class="number">54</span>张牌</span><br><span class="line">第三步：接着再完全洗牌、发牌、捋牌、看牌的业务逻辑</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>先来完成第一步，定义一个扑克类Card</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">// 每张牌是存在大小的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 0 1 2 ....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">(String number, String color, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color + number ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>再完成第二步，定义一个房间类，初始化房间时准备好54张牌</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// 必须有一副牌。</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Card&gt; allCards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1、做出54张牌，存入到集合allCards</span></span><br><span class="line">        <span class="comment">// a、点数：个数确定了，类型确定。</span></span><br><span class="line">        String[] numbers = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// b、花色：个数确定了，类型确定。</span></span><br><span class="line">        String[] colors = &#123;<span class="string">&quot;♠&quot;</span>, <span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♣&quot;</span>, <span class="string">&quot;♦&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示每张牌的大小</span></span><br><span class="line">        <span class="comment">// c、遍历点数，再遍历花色，组织牌</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="comment">// number = &quot;3&quot;</span></span><br><span class="line">            size++; <span class="comment">// 1 2 ....</span></span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                <span class="comment">// 得到一张牌</span></span><br><span class="line">                <span class="type">Card</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(number, color, size);</span><br><span class="line">                allCards.add(c); <span class="comment">// 存入了牌</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单独存入小大王的。</span></span><br><span class="line">        <span class="type">Card</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">&quot;&quot;</span>,  <span class="string">&quot;🃏&quot;</span> , ++size);</span><br><span class="line">        <span class="type">Card</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;👲&quot;</span> , ++size);</span><br><span class="line">        Collections.addAll(allCards, c1, c2);</span><br><span class="line">        System.out.println(<span class="string">&quot;新牌：&quot;</span> + allCards);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最后完成第三步，定义一个启动游戏的方法，完成洗牌、发牌、捋牌、看牌的业务逻辑</strong></p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 游戏启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、洗牌： allCards</span></span><br><span class="line">    Collections.shuffle(allCards);</span><br><span class="line">    System.out.println(<span class="string">&quot;洗牌后：&quot;</span> + allCards);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、发牌，首先肯定要定义 三个玩家。 List(ArrayList)  Set(TreeSet)</span></span><br><span class="line">    List&lt;Card&gt; linHuChong = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Card&gt; jiuMoZhi = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Card&gt; renYingYing = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 正式发牌给这三个玩家，依次发出51张牌，剩余3张做为底牌。</span></span><br><span class="line">    <span class="comment">// allCards = [♥3, ♣10, ♣4, ♥K, ♦Q, ♣2, 🃏, ♣8, ....</span></span><br><span class="line">    <span class="comment">//             0     1   2   3   4   5   6 ...   % 3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allCards.size() - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">Card</span> <span class="variable">c</span> <span class="operator">=</span> allCards.get(i);</span><br><span class="line">        <span class="comment">// 判断牌发给谁</span></span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 请啊冲接牌</span></span><br><span class="line">            linHuChong.add(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 请啊鸠来接牌</span></span><br><span class="line">            jiuMoZhi.add(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// 请盈盈接牌</span></span><br><span class="line">            renYingYing.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、对3个玩家的牌进行排序</span></span><br><span class="line">    sortCards(linHuChong);</span><br><span class="line">    sortCards(jiuMoZhi);</span><br><span class="line">    sortCards(renYingYing);</span><br><span class="line">    <span class="comment">// 4、看牌</span></span><br><span class="line">    System.out.println(<span class="string">&quot;啊冲：&quot;</span> + linHuChong);</span><br><span class="line">    System.out.println(<span class="string">&quot;啊鸠：&quot;</span> + jiuMoZhi);</span><br><span class="line">    System.out.println(<span class="string">&quot;盈盈：&quot;</span> + renYingYing);</span><br><span class="line">    List&lt;Card&gt; lastThreeCards = allCards.subList(allCards.size() - <span class="number">3</span>, allCards.size()); <span class="comment">// 51 52 53</span></span><br><span class="line">    System.out.println(<span class="string">&quot;底牌：&quot;</span> + lastThreeCards);</span><br><span class="line">    jiuMoZhi.addAll(lastThreeCards);</span><br><span class="line">    sortCards(jiuMoZhi);</span><br><span class="line">    System.out.println(<span class="string">&quot;啊鸠抢到地主后：&quot;</span> + jiuMoZhi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集中进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cards</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortCards</span><span class="params">(List&lt;Card&gt; cards)</span> &#123;</span><br><span class="line">    Collections.sort(cards, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Card&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Card o1, Card o2)</span> &#123;</span><br><span class="line">            <span class="comment">// return o1.getSize() - o2.getSize(); // 升序排序</span></span><br><span class="line">            <span class="keyword">return</span> o2.getSize() - o1.getSize(); <span class="comment">// 降序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘记了写测试类了，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  1、牌类。</span></span><br><span class="line">        <span class="comment">//  2、房间</span></span><br><span class="line">        <span class="type">Room</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">        <span class="comment">//  3、启动游戏</span></span><br><span class="line">        m.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>先认识一下什么是双列集合。</li>
</ul>
<p>所谓双列集合，就是说集合中的元素是一对一对的。Map集合中的每一个元素是以<code>key=value</code>的形式存在的，一个<code>key=value</code>就称之为一个键值对，而且在Java中有一个类叫Entry类，Entry的对象用来表示键值对对象。</p>
<p>所有的Map集合有如下的特点：<strong>键不能重复，值可以重复，每一个键只能找到自己对应的值。</strong></p>
<ul>
<li>认识Map集合</li>
</ul>
<ul>
<li>Map集合称为双列集合，格式:{key7&#x3D;value1 , key2&#x3D;value2 , key3&#x3D;value3, ..}，一次需要存一对数据做为一个元素.</li>
<li>Map集合的每个元素“key&#x3D;value”称为一个键值对&#x2F;键值对对象&#x2F;一个Entry对象，Map集合也被叫做“键值对集合”</li>
<li>Map集合的所有键是不允许重复的，但值可以重复，键和值是一一对应的，每一个键只能找到自己对应的值</li>
</ul>
<p>下面我们先写一个Map集合，保存几个键值对，体验一下Map集合的特点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 一行经典代码。 按照键 无序，不重复，无索引。</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">// 有序，不重复，无索引。</span></span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">220</span>); <span class="comment">// 后面重复的数据会覆盖前面的数据（键）</span></span><br><span class="line">        map.put(<span class="string">&quot;手机&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 可排序，不重复，无索引</span></span><br><span class="line">        map1.put(<span class="number">23</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map1.put(<span class="number">23</span>, <span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        map1.put(<span class="number">19</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map1.put(<span class="number">20</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh82.png"></p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li>为什么要先学习Map的常用方法?<br>Map是双列集合的祖宗，它的功能是全部双列集合都可以继承过来使用的。</li>
</ul>
<p>Map的常用方法如下:<br>方法名称                                     说明<br>public v put(K key ,v value)                添加元素<br>public int size()                           获取集合的大小<br>public void clear()                         清空集合<br>public boolean isEmpty()                    判断集合是否为空，为空返回true ，反之<br>public v get(Object key)                    根据键获取对应值<br>public v remove(Object key)                 根据键删除整个元素<br>public boolean containsKey(Object key)       判断是否包含某个键<br>public boolean containsValue(Object value)  判断是否包含某个值<br>public Set<K> keySet()                      获取全部键的集合<br>public collection<V> values()               获取Map集合的全部值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">220</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手机&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;null=null, 手表=220, Java=2, 手机=2&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.public int size():获取集合的大小</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public void clear():清空集合</span></span><br><span class="line">        <span class="comment">//map.clear();</span></span><br><span class="line">        <span class="comment">//System.out.println(map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.public boolean isEmpty(): 判断集合是否为空，为空返回true ,反之！</span></span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.public V get(Object key)：根据键获取对应值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> map.get(<span class="string">&quot;手表&quot;</span>);</span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;手机&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;张三&quot;</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. public V remove(Object key)：根据键删除整个元素(删除键会返回键的值)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;手表&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.public  boolean containsKey(Object key): 判断是否包含某个键 ，包含返回true ,反之</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;手表&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;手机&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;java&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;Java&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.public boolean containsValue(Object value): 判断是否包含某个值。</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;2&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9.public Set&lt;K&gt; keySet(): 获取Map集合的全部键。</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        System.out.println(keys);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.public Collection&lt;V&gt; values(); 获取Map集合的全部值。</span></span><br><span class="line">        Collection&lt;Integer&gt; values = map.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.把其他Map集合的数据倒入到自己集合中来。(拓展)</span></span><br><span class="line">        Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">&quot;java1&quot;</span>,  <span class="number">10</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;java2&quot;</span>,  <span class="number">20</span>);</span><br><span class="line">        Map&lt;String, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;java3&quot;</span>,  <span class="number">10</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;java2&quot;</span>,  <span class="number">222</span>);</span><br><span class="line">        map1.putAll(map2); <span class="comment">// putAll：把map2集合中的元素全部倒入一份到map1集合中去。</span></span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>Map集合的遍历方式</p>
<ol>
<li>键找值     先获取Map集合全部的键，再通过遍历键来找值</li>
</ol>
<ul>
<li>需要用到Map的如下方法:<br>方法名称                   说明<br>public Set<K> keySet()    获取所有键的集合<br>public V get(Object key)  根据键获取其对应的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：掌握Map集合的遍历方式1：键找值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备一个Map集合。</span></span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">162.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取Map集合的全部键</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// System.out.println(keys);</span></span><br><span class="line">        <span class="comment">// [蜘蛛精, 牛魔王, 至尊宝, 紫霞]</span></span><br><span class="line">        <span class="comment">//         key</span></span><br><span class="line">        <span class="comment">// 2、遍历全部的键，根据键获取其对应的值</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="comment">// 根据键获取对应的值</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=====&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>键值对     把“键值对“看成一个整体进行遍历(难度较大)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh83.png"></p>
<p>Map集合是用来存储键值对的，而每一个键值对实际上是一个Entry对象。</p>
<p><strong>这里Map集合的第二种方式，是直接获取每一个Entry对象，把Entry存储扫Set集合中去，再通过Entry对象获取键和值。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Map集合的第二种遍历方式：键值对。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span></span><br><span class="line">        <span class="comment">// entries = [(蜘蛛精=169.8), (牛魔王=183.6), (至尊宝=169.5), (紫霞=165.8)]</span></span><br><span class="line">        <span class="comment">// entry = (蜘蛛精=169.8)</span></span><br><span class="line">        <span class="comment">// entry = (牛魔王=183.6)</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; entry : entries) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Lambda    JDK1.8开始之后的新技术(非常的简单)</li>
</ol>
<ul>
<li>Map集合的遍历方式三:Lambda</li>
</ul>
<ul>
<li>需要用到Map的如下方法<br>方法名称                     说明<br>default void forEach(Biconsumer&lt;? super K, ? super V&gt; action)    结合lambda遍历Map集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Map集合的第二种遍历方式：键值对。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">169.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;紫霞&quot;</span>, <span class="number">165.8</span>);</span><br><span class="line">        map.put(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">169.5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">183.6</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// map = &#123;蜘蛛精=169.8, 牛魔王=183.6, 至尊宝=169.5, 紫霞=165.8&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历map集合，传递匿名内部类</span></span><br><span class="line">        map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k, Double v)</span> &#123;</span><br><span class="line">                System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//遍历map集合，传递Lambda表达式</span></span><br><span class="line">        map.forEach(( k,  v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Map集合案例"><a href="#Map集合案例" class="headerlink" title="Map集合案例"></a>Map集合案例</h2><p>学习完Map集合的基本用法之后，接下来我们做一个综合案例，将Map集合运用一下。</p>
<p>先分析需求，再考虑怎么用代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>首先可以将<span class="number">80</span>个学生选择的景点放到一个集合中去（也就是说，集合中的元素是<span class="number">80</span>个任意的ABCD元素）</span><br><span class="line"><span class="number">2.</span>准备一个Map集合用来存储景点，以及景点被选择的次数</span><br><span class="line"><span class="number">3.</span>遍历<span class="number">80</span>个学生选择景点的集合，得到每一个景点，判断Map集合中是否包含该景点</span><br><span class="line">    如果不包含，则存储<span class="string">&quot;景点=1&quot;</span></span><br><span class="line">    如果包含，则存获取该景点原先的值，再存储<span class="string">&quot;景点=原来的值+1&quot;</span>; 此时新值会覆盖旧值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成Map集合的案例：统计投票人数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、把80个学生选择的景点数据拿到程序中来。</span></span><br><span class="line">        List&lt;String&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] selects = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次模拟一个学生选择一个景点，存入到集合中去。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(<span class="number">4</span>); <span class="comment">// 0 1 2 3</span></span><br><span class="line">            data.add(selects[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始统计每个景点的投票人数</span></span><br><span class="line">        <span class="comment">// 准备一个Map集合用于统计最终的结果</span></span><br><span class="line">        Map&lt;String, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始遍历80个景点数据</span></span><br><span class="line">        <span class="keyword">for</span> (String s : data) &#123;</span><br><span class="line">            <span class="comment">// 问问Map集合中是否存在该景点</span></span><br><span class="line">            <span class="keyword">if</span>(result.containsKey(s))&#123;</span><br><span class="line">                <span class="comment">// 说明这个景点之前统计过。其值+1. 存入到Map集合中去</span></span><br><span class="line">                result.put(s, result.get(s) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明这个景点是第一次统计，存入&quot;景点=1&quot;</span></span><br><span class="line">                result.put(s, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>HashMap集合的底层原理</li>
</ul>
<ul>
<li>HashMap跟HashSet的底层原理是一模一样的，都是基于哈希表实现的。<br>实际上:原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>HashMap忘层是基于哈希表实现的</li>
</ul>
<ul>
<li>HashMap集合是一种增删改查数据，性能都较好的集合</li>
<li>但是它是无序，不能重复，没有索引支持的(由键决定特点)</li>
<li>HashMap的键依赖hashCode方法和equals方法保证键的唯一</li>
<li>如果键存储的是自定义类型的对象，可以通过重写hashCode和equals方法，这样可以保证多个对象内容一样时，HashMap集合就能认为是重复的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HashMap底层数据结构: 哈希表结构</span><br><span class="line">	JDK8之前的哈希表 = 数组+链表</span><br><span class="line">	JDK8之后的哈希表 = 数组+链表+红黑树</span><br><span class="line">	哈希表是一种增删改查数据，性能相对都较好的数据结构</span><br><span class="line">	</span><br><span class="line">往HashMap集合中键值对数据时，底层步骤如下</span><br><span class="line">	第<span class="number">1</span>步：当你第一次往HashMap集合中存储键值对时，底层会创建一个长度为<span class="number">16</span>的数组</span><br><span class="line">	第<span class="number">2</span>步：把键然后将键和值封装成一个对象，叫做Entry对象</span><br><span class="line">	第<span class="number">3</span>步：再根据Entry对象的键计算hashCode值（和值无关）</span><br><span class="line">	第<span class="number">4</span>步：利用hashCode值和数组的长度做一个类似求余数的算法，会得到一个索引位置</span><br><span class="line">	第<span class="number">5</span>步：判断这个索引的位置是否为<span class="literal">null</span>，如果为<span class="literal">null</span>,就直接将这个Entry对象存储到这个索引位置</span><br><span class="line">		   如果不为<span class="literal">null</span>，则还需要进行第<span class="number">6</span>步的判断</span><br><span class="line">	第<span class="number">6</span>步：继续调用equals方法判断两个对象键是否相同</span><br><span class="line">		  如果equals返回<span class="literal">false</span>，则以链表的形式往下挂</span><br><span class="line">		  如果equals方法<span class="literal">true</span>,则认为键重复，此时新的键值对会替换就的键值对。</span><br><span class="line">	</span><br><span class="line">HashMap底层需要注意这几点：</span><br><span class="line">	<span class="number">1.</span>底层数组默认长度为<span class="number">16</span>，如果数组中有超过<span class="number">12</span>个位置已经存储了元素，则会对数组进行扩容<span class="number">2</span>倍</span><br><span class="line">	  数组扩容的加载因子是<span class="number">0.75</span>，意思是：<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span> 	</span><br><span class="line">   	</span><br><span class="line">    <span class="number">2.</span>数组的同一个索引位置有多个元素、并且在<span class="number">8</span>个元素以内(包括<span class="number">8</span>)，则以链表的形式存储</span><br><span class="line">    	JDK7版本：链表采用头插法（新元素往链表的头部添加）</span><br><span class="line">    	JDK8版本：链表采用尾插法（新元素我那个链表的尾部添加）</span><br><span class="line">    	</span><br><span class="line">    <span class="number">3.</span>数组的同一个索引位置有多个元素、并且超过了<span class="number">8</span>个，则以红黑树形式存储</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从HashMap底层存储键值对的过程中我们发现：决定键是否重复依赖与两个方法，一个是hashCode方法、一个是equals方法。有两个键计算得到的hashCode值相同，并且两个键使用equals比较为true，就认为键重复。</p>
<p><strong>所以，往Map集合中存储自定义对象作为键，为了保证键的唯一性，我们应该重写hashCode方法和equals方法。</strong></p>
<p>比如有如下案例：往HashMap集合中存储Student对象作为键，学生的家庭住址当做值。要求，当学生对象的姓名和年龄相同时就认为键重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this  o</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age; <span class="comment">// 年龄升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Double.compare(student.height, height) == <span class="number">0</span> &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...get,set方法自己补全....</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个测试类，在测试类中，创建HashMap集合，键是Student类型，值是Stirng类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Map集合下的实现类：HashMap集合的底层原理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1HashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;盘丝洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">23</span>, <span class="number">163.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">28</span>, <span class="number">183.5</span>), <span class="string">&quot;牛头山&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面存储的键，有两个蜘蛛精，但是打印出只会有最后一个。</p>
<h2 id="LinkHashMap"><a href="#LinkHashMap" class="headerlink" title="LinkHashMap"></a>LinkHashMap</h2><p>学习完HashMap集合的特点，以及底层原理。接下来我们学习一下LinkedHashMap集合。</p>
<ul>
<li>LinkedHashMap集合的特点也是由键决定的：<strong>有序的、不重复、无索引</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握LinkedHashMap的底层原理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2LinkedHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    //  按照键 无序，不重复，无索引。</span></span><br><span class="line">        LinkedHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">//  按照键 有序，不重复，无索引。</span></span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手表&quot;</span>, <span class="number">220</span>);</span><br><span class="line">        map.put(<span class="string">&quot;手机&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面代码发现，如果是LinedHashMap集合键存储和取出的顺序是一样的</p>
<p>如果是HashMap，键存储和取出的顺序是不一致的</p>
<ul>
<li>LinkedHashMap的底层原理，和LinkedHashSet底层原理是一样的。底层多个一个双向链表来维护键的存储顺序。</li>
</ul>
<p>​取元素时，先取头节点元素，然后再依次取下一个几点，一直到尾结点。所以是有序的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh84.png"></p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>TreeMap</li>
</ul>
<ul>
<li>特点:不重复、无索引、可排序(按照键的大小默认升序排序，只能对键排序)</li>
<li>原理:TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。</li>
</ul>
<ul>
<li>TreeMap集合同样也支持两种方式来指定排序规则</li>
</ul>
<ul>
<li>让类实现Comparable接口，重写比较规则。<br>TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。</li>
</ul>
<p>Map集合下面的另一个子类叫TreeMap。根据我们前面学习其他Map集合的经验，我们应该可以猜出TreeMap有什么特点。</p>
<ul>
<li><p>TreeMap集合的特点也是由键决定的，默认按照键的升序排列，键不重复，也是无索引的。</p>
</li>
<li><p>TreeMap集合的底层原理和TreeSet也是一样的，底层都是红黑树实现的。所以可以对键进行排序。</p>
<p>比如往TreeMap集合中存储Student对象作为键，排序方法有两种。直接看代码吧</p>
</li>
</ul>
<p><strong>排序方式1：</strong>写一个Student类，让Student类实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：先让Student类，实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    <span class="comment">//无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//全参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> height)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">        <span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...get、set、toString()方法自己补上..</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原理：</span></span><br><span class="line"><span class="comment">    在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的</span></span><br><span class="line"><span class="comment">    结果是正数、负数、还是零，决定元素放在后面、前面还是不存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">//this：表示将要添加进去的Student对象</span></span><br><span class="line">        <span class="comment">//o: 表示集合中已有的Student对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>排序方式2：</strong>在创建TreeMap集合时，直接传递Comparator比较器对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握TreeMap集合的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3TreeMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        Map&lt;Student, String&gt; map = new TreeMap&lt;&gt;(( o1,  o2) -&gt;   Double.compare(o2.getHeight(), o1.getHeight()));</span></span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;盘丝洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">25</span>, <span class="number">168.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;至尊宝&quot;</span>, <span class="number">23</span>, <span class="number">163.5</span>), <span class="string">&quot;水帘洞&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">28</span>, <span class="number">183.5</span>), <span class="string">&quot;牛头山&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式都可以对TreeMap集合中的键排序。<strong>注意：只有TreeMap的键才能排序，HashMap键不能排序。</strong></p>
<h2 id="补充知识：集合的嵌套"><a href="#补充知识：集合的嵌套" class="headerlink" title="补充知识：集合的嵌套"></a>补充知识：集合的嵌套</h2><ul>
<li>案例分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>从需求中我们可以看到，有三个省份，每一个省份有多个城市</span><br><span class="line">	我们可以用一个Map集合的键表示省份名称，而值表示省份有哪些城市</span><br><span class="line"><span class="number">2.</span>而又因为一个身份有多个城市，同一个省份的多个城市可以再用一个List集合来存储。</span><br><span class="line">	所以Map集合的键是String类型，而指是List集合类型</span><br><span class="line">	HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：理解集合的嵌套。</span></span><br><span class="line"><span class="comment"> * 江苏省 = &quot;南京市&quot;,&quot;扬州市&quot;,&quot;苏州市“,&quot;无锡市&quot;,&quot;常州市&quot;</span></span><br><span class="line"><span class="comment"> * 湖北省 = &quot;武汉市&quot;,&quot;孝感市&quot;,&quot;十堰市&quot;,&quot;宜昌市&quot;,&quot;鄂州市&quot;</span></span><br><span class="line"><span class="comment"> * 河北省 = &quot;石家庄市&quot;,&quot;唐山市&quot;, &quot;邢台市&quot;, &quot;保定市&quot;, &quot;张家口市&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、定义一个Map集合存储全部的省份信息，和其对应的城市信息。</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; cities1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(cities1, <span class="string">&quot;南京市&quot;</span>,<span class="string">&quot;扬州市&quot;</span>,<span class="string">&quot;苏州市&quot;</span> ,<span class="string">&quot;无锡市&quot;</span>,<span class="string">&quot;常州市&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;江苏省&quot;</span>, cities1);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; cities2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(cities2, <span class="string">&quot;武汉市&quot;</span>,<span class="string">&quot;孝感市&quot;</span>,<span class="string">&quot;十堰市&quot;</span>,<span class="string">&quot;宜昌市&quot;</span>,<span class="string">&quot;鄂州市&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;湖北省&quot;</span>, cities2);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; cities3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(cities3, <span class="string">&quot;石家庄市&quot;</span>,<span class="string">&quot;唐山市&quot;</span>, <span class="string">&quot;邢台市&quot;</span>, <span class="string">&quot;保定市&quot;</span>, <span class="string">&quot;张家口市&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;河北省&quot;</span>, cities3);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; cities = map.get(<span class="string">&quot;湖北省&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String city : cities) &#123;</span><br><span class="line">            System.out.println(city);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.forEach((p, c) -&gt; &#123;</span><br><span class="line">            System.out.println(p + <span class="string">&quot;-----&gt;&quot;</span> + c);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h2 id="认识Stream"><a href="#认识Stream" class="headerlink" title="认识Stream"></a>认识Stream</h2><ul>
<li>什么是Stream?</li>
</ul>
<ul>
<li>也叫Stream流，是Jdk8开始新增的一套APl(java.util.stream.*)，可以用于操作集合或者数组的数据。<br>用Stream流来做，代码是这样的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list2 = names.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(a -&gt; a.length()==<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure></li>
<li>优势: Stream流大量的结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh85.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要掌握下面四点：</span><br><span class="line">	<span class="number">1</span>、如何获取List集合的Stream流？</span><br><span class="line">	<span class="number">2</span>、如何获取Set集合的Stream流？</span><br><span class="line">	<span class="number">3</span>、如何获取Map集合的Stream流？</span><br><span class="line">	<span class="number">4</span>、如何获取数组的Stream流？</span><br></pre></td></tr></table></figure>

<p>直接上代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、如何获取List集合的Stream流？</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = names.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、如何获取Set集合的Stream流？</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(set, <span class="string">&quot;刘德华&quot;</span>,<span class="string">&quot;张曼玉&quot;</span>,<span class="string">&quot;蜘蛛精&quot;</span>,<span class="string">&quot;马德&quot;</span>,<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line">        stream1.filter(s -&gt; s.contains(<span class="string">&quot;德&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、如何获取Map集合的Stream流？</span></span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">172.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">166.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;卡尔扎巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; ks = keys.stream();</span><br><span class="line"></span><br><span class="line">        Collection&lt;Double&gt; values = map.values();</span><br><span class="line">        Stream&lt;Double&gt; vs = values.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream();</span><br><span class="line">        kvs.filter(e -&gt; e.getKey().contains(<span class="string">&quot;巴&quot;</span>))</span><br><span class="line">                .forEach(e -&gt; System.out.println(e.getKey()+ <span class="string">&quot;--&gt;&quot;</span> + e.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、如何获取数组的Stream流？</span></span><br><span class="line">        String[] names2 = &#123;<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;东方不败&quot;</span>, <span class="string">&quot;唐大山&quot;</span>, <span class="string">&quot;独孤求败&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; s1 = Arrays.stream(names2);</span><br><span class="line">        Stream&lt;String&gt; s2 = Stream.of(names2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Stream的常用方法"><a href="#Stream的常用方法" class="headerlink" title="Stream的常用方法"></a>Stream的常用方法</h2><ol>
<li>获取Stream流?</li>
</ol>
<ul>
<li><p>获取集合的Stream流，<br>Collection提供的如下方法              说明<br>default stream<E> stream()           获取当前集合对象的Stream流</p>
</li>
<li><p>获取数组的Stream流<br>Arrays类提供的如下方法                                说明<br>public static <T> stream<T> stream(T[]array)         获取当前数组的stream流</p>
</li>
</ul>
<p>Stream类提供的如下方法                                说明<br>public static<T> Stream<T> of(T… values)           获取当前接收数据的Stream流</p>
<p><strong>中间方法指的是：调用完方法之后其结果是一个新的Stream流，于是可以继续调用方法，这样一来就可以支持链式编程</strong>（或者叫流式编程）。</p>
<ol start="2">
<li>Stream流常见的中间方法<br>中间方法指的是调用完成后会返回新的Stream流，可以继续使用(支持链式编程)。<br>Stream提供的常用中间方法                              说明<br>Stream<T> filter(Predicate&lt;? super T&gt; predicate)    用于对流中的数据进行过滤。<br>Stream<I> sorted()                                  对元素进行升序排序<br>Stream<I> sorted(Comparator&lt; ? super I&gt;comparator)  按照指定规则排序<br>Stream<T> limit( long maxSize)                      获取前几个元素<br>Stream<T> skip( long n)                             跳过前几个元素<br>stream<T> distinct()                                去除流中重复的元素。<br><R>Stream<R> map(Function&lt;? super L,? extends R&gt; mapper)对元素进行加工，并返回对应的新流<br>static <T> Stream<T> concat(Stream a，stream b)     合并a和b两个流为一个流</li>
</ol>
<p>代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流提供的常见中间方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">88.5</span>, <span class="number">100.0</span>, <span class="number">60.0</span>, <span class="number">99.0</span>, <span class="number">9.5</span>, <span class="number">99.6</span>, <span class="number">25.0</span>);</span><br><span class="line">        <span class="comment">// 需求1：找出成绩大于等于60分的数据，并升序后，再输出。</span></span><br><span class="line">        scores.stream().filter(s -&gt; s &gt;= <span class="number">60</span>).sorted().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出.</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getAge() &gt;= <span class="number">23</span> &amp;&amp; s.getAge() &lt;= <span class="number">30</span>)</span><br><span class="line">                .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br><span class="line">                .forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：取出身高最高的前3名学生，并输出。</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：取出身高倒数的2名学生，并输出。   s1 s2 s3 s4 s5 s6</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .skip(students.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).map(Student::getName)</span><br><span class="line">               .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals）</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>)</span><br><span class="line">                .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; st1 = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; st2 = Stream.of(<span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;李四2&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; allSt = Stream.concat(st1, st2);</span><br><span class="line">        allSt.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Stream流常见的终结方法</li>
</ol>
<ul>
<li>收集Stream流:就是把Stream流操作后的结果转回到集合或者数组中去返回。</li>
<li>Stream流:方便操作集合&#x2F;数组的手段;集合&#x2F;数组:才是开发中的目的。</li>
</ul>
<p>Stream提供的常用终结方法                说明<br>R collect(Collector collector)        把流处理后的结果收集到一个指定的集合中去<br>object[ ] toArray()                   把流处理后的结果收集到一个数组中去</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：Stream流的终结方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求1：请计算出身高超过168的学生有几人。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).count();</span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：请找出身高最高的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：请找出身高最矮的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">ss</span> <span class="operator">=</span> students.stream().min((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(ss);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。</span></span><br><span class="line">        <span class="comment">// 流只能收集一次。</span></span><br><span class="line">        List&lt;Student&gt; students1 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(students1);</span><br><span class="line"></span><br><span class="line">        Set&lt;Student&gt; students2 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(students2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。</span></span><br><span class="line">        Map&lt;String, Double&gt; map =</span><br><span class="line">                students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>)</span><br><span class="line">                        .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray();</span></span><br><span class="line">        Student[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).toArray(len -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>[len]);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="File、IO流"><a href="#File、IO流" class="headerlink" title="File、IO流"></a>File、IO流</h1><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><ul>
<li>File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件(可以是文件、或文件夹)。</li>
</ul>
<p>获取文件信息(大小，文件名，修改时间)<br>判断文件的类型<br>创建文件&#x2F;文件夹<br>删除文件&#x2F;文件夹</p>
<p><strong>但是需要我们注意：</strong>File对象只能对文件进行操作，不能操作文件中的内容。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>学习File类和其他类一样，第一步是创建File类的对象。 想要创建对象，我们得看File类有哪些构造方法。</p>
<ul>
<li>创建File类的对象<br>构造器                                      说明<br>public File(String pathname)                根据文件路径创建文件对象<br>public File(string parent，String child)    根据父路径和子路径名字创建文件对象<br>public File(File parent，String child)       根据父路径对应文件对象和子路径名字创建文件对象</li>
</ul>
<p>下面我们演示一下，File类创建对象的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求我们注意的是：路径中<span class="string">&quot;\&quot;要写成&quot;</span>\\<span class="string">&quot;， 路径中&quot;</span>/<span class="string">&quot;可以直接用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File创建对象，代表具体文件的方案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个File对象，指代某个具体的文件。</span></span><br><span class="line">        <span class="comment">// 路径分隔符</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:/resource/ab.txt&quot;);</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:\\resource\\ab.txt&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator +<span class="string">&quot;resource&quot;</span> + File.separator + <span class="string">&quot;ab.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 文件大小</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：File对象可以指代一个不存在的文件路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(f3.length());</span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我现在要定位的文件是在模块中，应该怎么定位呢？</span></span><br><span class="line">        <span class="comment">// 绝对路径：带盘符的</span></span><br><span class="line">        <span class="comment">// File f4 = new File(&quot;D:\\code\\javasepromax\\file-io-app\\src\\itheima.txt&quot;);</span></span><br><span class="line">        <span class="comment">// 相对路径（重点）：不带盘符，默认是直接去工程下寻找文件的。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意</li>
</ul>
<ul>
<li>File对象既可以代表文件、 也可以代表文件夹。</li>
<li>File封装的对象仅仅是一 个路径名, 这个路径可以是存在的,也允许是不存在的。</li>
</ul>
<ul>
<li><p>绝对路径、相对路径绝对路径:从盘符开始<br>File file1 &#x3D; new File(“D: \litheimalla.txt”);</p>
</li>
<li><p>相对路径:不带盘符，默认直接到当前工程下的目录寻找文件。<br>File file3 &#x3D; new File(“模块名\la.txt”);</p>
</li>
</ul>
<h3 id="常见方法1：判断文件类型、获取文件信息"><a href="#常见方法1：判断文件类型、获取文件信息" class="headerlink" title="常见方法1：判断文件类型、获取文件信息"></a>常见方法1：判断文件类型、获取文件信息</h3><ul>
<li>File提供的判断文件类型、获取文件信息功能<br>方法名称                                   说明<br>public boolean exists()                    判断当前文件对象，对应的文件路径是否存在，存在返回true<br>public boolean isFile()                    判断当前文件对象指代的是否是文件，是文件返回true，反之。<br>public boolean isDirectory()               判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。<br>public string getName()                    获取文件的名称(包含后缀)<br>public long length()                       获取文件的大小，返回字节个数<br>public long lastModified()                 获取文件的最后修改时间。<br>public String getPath()                    获取创建文件对象时，使用的路径<br>public String getAbsolutePath()            获取绝对路径</li>
</ul>
<p>话不多少，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：掌握File提供的判断文件类型、获取文件信息功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象，指代某个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/ab.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//File f1 = new File(&quot;D:/resource/&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public boolean exists()：判断当前文件对象，对应的文件路径是否存在，存在返回true.</span></span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean isFile() : 判断当前文件对象指代的是否是文件，是文件返回true，反之。</span></span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、public boolean isDirectory()  : 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。</span></span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了判断功能还有一些获取功能，看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/ab.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.public String getName()：获取文件的名称（包含后缀）</span></span><br><span class="line">System.out.println(f1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.public long length()：获取文件的大小，返回字节个数</span></span><br><span class="line">System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.public long lastModified()：获取文件的最后修改时间。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(sdf.format(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.public String getPath()：获取创建文件对象时，使用的路径</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\ab.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima.txt&quot;</span>);</span><br><span class="line">System.out.println(f2.getPath());</span><br><span class="line">System.out.println(f3.getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.public String getAbsolutePath()：获取绝对路径</span></span><br><span class="line">System.out.println(f2.getAbsolutePath());</span><br><span class="line">System.out.println(f3.getAbsolutePath());</span><br></pre></td></tr></table></figure>
<h3 id="常用方法2：创建文件、删除文件"><a href="#常用方法2：创建文件、删除文件" class="headerlink" title="常用方法2：创建文件、删除文件"></a>常用方法2：创建文件、删除文件</h3><ul>
<li><p>File类创建文件的功能<br>方法名称                                  说明<br>public boolean createNewFile()           创建一个新的空的文件<br>public boolean mkdir()                   只能创建一级文件夹<br>public boolean mkdirs()                  可以创建多级文件夹</p>
</li>
<li><p>File类删除文件的功能<br>方法名称                                  说明<br>public boolean delete()                   删除文件、空文件夹<br>注意:delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File创建和删除文件相关的方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、public boolean createNewFile()：创建一个新文件（文件内容为空），创建成功返回true,反之。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/itheima2.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public boolean mkdir()：用于创建文件夹，注意：只能创建一级文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean mkdirs()：用于创建文件夹，注意：可以创建多级文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/bbb/ccc/ddd/eee/fff/ggg&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean delete()：删除文件，或者空文件，注意：不能删除非空文件夹。</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        System.out.println(f2.delete());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource&quot;</span>);</span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>mkdir(): 只能创建单级文件夹、</span><br><span class="line"><span class="number">2.</span>mkdirs(): 才能创建多级文件夹</span><br><span class="line"><span class="number">3.</span>delete(): 文件可以直接删除，但是文件夹只能删除空的文件夹，文件夹有内容删除不了。</span><br></pre></td></tr></table></figure>
<h3 id="常用方法3：遍历文件夹"><a href="#常用方法3：遍历文件夹" class="headerlink" title="常用方法3：遍历文件夹"></a>常用方法3：遍历文件夹</h3><ul>
<li>File类提供的遍历文件夹的功能<br>方法名称                            说明<br>public string[] list()              获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。<br>public File[] listFiles()           获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回(重点)</li>
</ul>
<p>演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File提供的遍历文件夹的方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、public String[] list()：获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\待研发内容&quot;</span>);</span><br><span class="line">        String[] names = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public File[] listFiles():（重点）获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）</span></span><br><span class="line">        File[] files = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaa&quot;</span>);</span><br><span class="line">        File[] files1 = f.listFiles();</span><br><span class="line">        System.out.println(Arrays.toString(files1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意几个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>当主调是文件时，或者路径不存在时，返回<span class="literal">null</span></span><br><span class="line"><span class="number">2.</span>当主调是空文件夹时，返回一个长度为<span class="number">0</span>的数组</span><br><span class="line"><span class="number">3.</span>当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹路径放在File数组中，并把数组返回</span><br><span class="line"><span class="number">4.</span>当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在FIle数组中，包含隐藏文件</span><br><span class="line"><span class="number">5.</span>当主调是一个文件夹，但是没有权限访问时，返回<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h2 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h2><h3 id="递归算法引入"><a href="#递归算法引入" class="headerlink" title="递归算法引入"></a>递归算法引入</h3><ul>
<li><p>什么是递归？</p>
<p>递归是一种算法，从形式上来说，方法调用自己的形式称之为递归。</p>
</li>
<li><p>递归的形式：有直接递归、间接递归，如下面的代码。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：认识一下递归的形式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接方法递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----test1---&quot;</span>);</span><br><span class="line">        test1(); <span class="comment">// 直接方法递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 间接方法递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---test2---&quot;</span>);</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        test2(); <span class="comment">// 间接递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果直接执行上面的代码，会进入死循环，最终导致栈内存溢出</p>
<p>以上只是用代码演示了一下，递归的形式。在下一节，在通过一个案例来给同学们讲一讲递归的执行流程。</p>
<h3 id="递归算法的执行流程"><a href="#递归算法的执行流程" class="headerlink" title="递归算法的执行流程"></a>递归算法的执行流程</h3><p>为了弄清楚递归的执行流程，接下来我们通过一个案例来学习一下。</p>
<p>案例需求：计算n的阶乘，比如5的阶乘 &#x3D; 1 * 2 * 3 * 4 * 5 ； 6 的阶乘 &#x3D;  1 * 2 * 3 * 4 * 5 * 6</p>
<p>分析需求用递归该怎么做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设f(n)表示n的阶乘，那么我们可以推导出下面的式子</span><br><span class="line">	 f(<span class="number">5</span>) = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span></span><br><span class="line">    f(<span class="number">5</span>) = f(<span class="number">4</span>)+<span class="number">5</span></span><br><span class="line">    f(<span class="number">4</span>) = f(<span class="number">3</span>)+<span class="number">4</span></span><br><span class="line">    f(<span class="number">3</span>) = f(<span class="number">2</span>)+<span class="number">3</span></span><br><span class="line">    f(<span class="number">2</span>) = f(<span class="number">1</span>)+<span class="number">2</span></span><br><span class="line">    f(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">总结规律：</span><br><span class="line">	除了f(<span class="number">1</span>) = <span class="number">1</span>; 出口</span><br><span class="line">	其他的f(n) = f(n-<span class="number">1</span>)+n</span><br></pre></td></tr></table></figure>

<p>我们可以把f(n)当做一个方法，那么方法的写法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握递归的应用，执行流程和算法思想。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5的阶乘是：&quot;</span> + f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求n个数的阶乘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">// 终结点</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码的执行流程，我们用内存图的形式来分析一下，该案例中递归调用的特点是：<strong>一层一层调用，再一层一层往回返。</strong></p>
<h3 id="递归文件搜索"><a href="#递归文件搜索" class="headerlink" title="递归文件搜索"></a>递归文件搜索</h3><p>学习完递归算法执行流程后，最后我们回过头来。再来看一下，如果使用递归来遍历文件夹。</p>
<p>案例需求：在<code>D:\\</code>判断下搜索QQ.exe这个文件，然后直接输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先调用文件夹的listFiles方法，获取文件夹的一级内容，得到一个数组</span><br><span class="line"><span class="number">2.</span>然后再遍历数组，获取数组中的File对象</span><br><span class="line"><span class="number">3.</span>因为File对象可能是文件也可能是文件夹，所以接下来就需要判断</span><br><span class="line">	判断File对象如果是文件，就获取文件名，如果文件名是`QQ.exe`则打印，否则不打印</span><br><span class="line">	判断File对象如果是文件夹，就递归执行<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>步骤</span><br><span class="line">所以：把<span class="number">1</span>，<span class="number">2</span>,<span class="number">3</span>步骤写成方法，递归调用即可。</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件搜索的实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;QQ.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去目录下搜索某个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 要搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、把非法的情况都拦截住</span></span><br><span class="line">        <span class="keyword">if</span>(dir == <span class="literal">null</span> || !dir.exists() || dir.isFile())&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 代表无法搜索</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、dir不是null,存在，一定是目录对象。</span></span><br><span class="line">        <span class="comment">// 获取当前目录下的全部一级文件对象。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4、遍历全部一级文件对象。</span></span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">// 5、判断文件是否是文件,还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 是文件，判断这个文件名是否是我们要找的</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;找到了：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">                        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                        runtime.exec(f.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是文件夹，继续重复这个过程（递归）</span></span><br><span class="line">                    searchFile(f, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="字符集的来历"><a href="#字符集的来历" class="headerlink" title="字符集的来历"></a>字符集的来历</h3><p>所以，接下来我们正式学习一下字符集。先来带着同学们，了解一下字符集的来历。</p>
<p>我们知道计算机是美国人发明的，由于计算机能够处理的数据只能是0和1组成的二进制数据，为了让计算机能够处理字符，于是美国人就把他们会用到的每一个字符进行了编码（<strong>所谓编码，就是为一个字符编一个二进制数据</strong>），如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh87.png"></p>
<p>美国人常用的字符有英文字母、标点符号、数字以及一些特殊字符，这些字符一共也不到128个，所以他们用1个字节来存储1字符就够了。 美国人把他们用到的字符和字符对应的编码总结成了一张码表，这张码表叫做ASCII码表（也叫ASCII字符集）。</p>
<p>其实计算机只在美国用是没有问题的，但是计算机慢慢的普及到全世界，当普及到中国的时候，在计算机中想要存储中文，那ASCII字符集就不够用了，因为中文太多了，随便数一数也有几万个字符。</p>
<p>于是中国人为了在计算机中存储中文，也编了一个中国人用的字符集叫做GBK字符集，这里面包含2万多个汉字字符，<strong>GBK中一个汉字采用两个字节来存储</strong>，为了能够显示英文字母，GBK字符集也兼容了ASCII字符集，<strong>在GBK字符集中一个字母还是采用一个字节来存储</strong>。</p>
<h3 id="汉字和字母的编码特点"><a href="#汉字和字母的编码特点" class="headerlink" title="汉字和字母的编码特点"></a>汉字和字母的编码特点</h3><p>接下来，就带着同学们了解一下，计算机是怎么识别中文和英文的。</p>
<p>比如：在文件中存储一个<code>我a你</code>，底层其实存储的是这样的二进制数据。</p>
<p><strong>需要我们注意汉字和字母的编码特点：</strong></p>
<ul>
<li><ol>
<li>如果是存储字母，采用1个字节来存储，一共8位，其中第1位是0</li>
<li>如果是存储汉字，采用2个字节来存储，一共16位，其中第1位是1</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh88.png"></p>
<p><strong>当读取文件中的字符时，通过识别读取到的第1位是0还是1来判断是字母还是汉字</strong></p>
<ul>
<li>如果读取到第1位是0，就认为是一个字母，此时往后读1个字节。</li>
<li>如果读取到第1位是1，就认为是一个汉字，此时往后读2个字节。</li>
</ul>
<h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>同学们注意了，咱们国家可以用GBK字符集来表示中国人使用的文字，那世界上还有很多其他的国家，他们也有自己的文字，他们也想要自己国家的文字在计算机中处理，于是其他国家也在搞自己的字符集，就这样全世界搞了上百个字符集，而且各个国家的字符集互不兼容。 这样其实很不利于国际化的交流，可能一个文件在我们国家的电脑上打开好好的，但是在其他国家打开就是乱码了。</p>
<p>为了解决各个国家字符集互不兼容的问题，由国际化标准组织牵头，设计了一套全世界通用的字符集，叫做Unicode字符集。在Unicode字符集中包含了世界上所有国家的文字，一个字符采用4个自己才存储。</p>
<p>在Unicode字符集中，采用一个字符4个字节的编码方案，又造成另一个问题：如果是说英语的国家，他们只需要用到26大小写字母，加上一些标点符号就够了，本身一个字节就可以表示完，用4个字节就有点浪费。</p>
<p>于是又对Unicode字符集中的字符进行了重新编码，一共设计了三种编码方案。分别是UTF-32、UTF-16、UTF-8;  <strong>其中比较常用的编码方案是UTF-8</strong></p>
<p>下面我们详细介绍一下UTF-8这种编码方案的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>UTF-<span class="number">8</span>是一种可变长的编码方案，工分为<span class="number">4</span>个长度区</span><br><span class="line"><span class="number">2.</span>英文字母、数字占<span class="number">1</span>个字节兼容(ASCII编码)</span><br><span class="line"><span class="number">3.</span>汉字字符占<span class="number">3</span>个字节</span><br><span class="line"><span class="number">4.</span>极少数字符占<span class="number">4</span>个字节</span><br></pre></td></tr></table></figure>



<h3 id="字符集小结"><a href="#字符集小结" class="headerlink" title="字符集小结"></a>字符集小结</h3><p>最后，我们将前面介绍过的字符集小结一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ASCII字符集：《美国信息交换标准代码》，包含英文字母、数字、标点符号、控制字符</span><br><span class="line">	特点：<span class="number">1</span>个字符占<span class="number">1</span>个字节</span><br><span class="line"></span><br><span class="line">GBK字符集：中国人自己的字符集，兼容ASCII字符集，还包含<span class="number">2</span>万多个汉字</span><br><span class="line">	特点：<span class="number">1</span>个字母占用<span class="number">1</span>个字节；<span class="number">1</span>个汉字占用<span class="number">2</span>个字节</span><br><span class="line"></span><br><span class="line">Unicode字符集：包含世界上所有国家的文字，有三种编码方案，最常用的是UTF-<span class="number">8</span></span><br><span class="line">    UTF-<span class="number">8</span>编码方案：英文字母、数字占<span class="number">1</span>个字节兼容(ASCII编码)、汉字字符占<span class="number">3</span>个字节</span><br></pre></td></tr></table></figure>


<h3 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h3><p>搞清楚字符集的知识之后，我们接下来再带着同学们使用Java代码完成编码和解码的操作。</p>
<p>其实String类类中就提供了相应的方法，可以完成编码和解码的操作。</p>
<ul>
<li>编码：把字符串按照指定的字符集转换为字节数组</li>
<li>解码：把字节数组按照指定的字符集转换为字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握如何使用Java代码完成对字符的编码和解码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;a我b&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = data.getBytes(); <span class="comment">// 默认是按照平台字符集（UTF-8）进行编码的。</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照指定字符集进行编码。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = data.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bytes1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); <span class="comment">// 按照平台默认编码（UTF-8）解码</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO流（字节流）"><a href="#IO流（字节流）" class="headerlink" title="IO流（字节流）"></a>IO流（字节流）</h2><h3 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h3><p>各位小伙伴，在前面我们已经学习过File类。但是我们知道File只能操作文件，但是不能操作文件中的内容。我们也学习了字符集，不同的字符集存字符数据的原理是不一样的。有了前面两个知识的基础，接下来我们再学习IO流，就可以对文件中的数据进行操作了。</p>
<p>IO流的作用：就是可以对文件或者网络中的数据进行读、写的操作。如下图所示</p>
<ul>
<li>把数据从磁盘、网络中读取到程序中来，用到的是输入流。</li>
<li>把程序中的数据写入磁盘、网络中，用到的是输出流。</li>
<li><strong>简单记：输入流（读数据）、输出流（写数据）</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh89.png"></p>
<p>IO流在Java中有很多种，不同的流来干不同的事情。Java把各种流用不同的类来表示，这些流的继承体系如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IO流分为两大派系：</span><br><span class="line">	<span class="number">1.</span>字节流：字节流又分为字节输入流、字节输出流</span><br><span class="line">	<span class="number">2.</span>字符流：字符流由分为字符输入流、字符输出流</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh90.png"></p>
<h3 id="FileInputStream读取一个字节"><a href="#FileInputStream读取一个字节" class="headerlink" title="FileInputStream读取一个字节"></a>FileInputStream读取一个字节</h3><p>同学们，在上节课认识了什么是IO流，接下来我们学习字节流中的字节输入流，用InputStream来表示。但是InputStream是抽象类，我们用的是它的子类，叫FileInputStream。</p>
<p>需要用到的方法如下图所示：有构造方法、成员方法</p>
<p>构造器                                         说明<br>public FileInputStream(File file)             创建字节输入流管道与源文件接通<br>public FileInputStream(String pathname)       创建字节输入流管道与源文件接通</p>
<p>方法名称                           说明<br>public int read()                 每次读取一个字节返回，如果发现没有数据可读会返回-1.<br>public int read(byte[] buffer)    每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1.</p>
<p>使用FileInputStream读取文件中的字节数据，步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileInputStream文件字节输入流管道，与源文件接通。</span><br><span class="line">第二步：调用read()方法开始读取文件的字节数据。</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输入流，每次读取一个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建文件字节输入流管道，与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((<span class="string">&quot;file-io-app\\src\\itheima01.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件的字节数据。</span></span><br><span class="line">        <span class="comment">// public int read():每次读取一个字节返回，如果没有数据了，返回-1.</span></span><br><span class="line">        <span class="type">int</span> b; <span class="comment">// 用于记住读取的字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、流使用完毕之后，必须关闭！释放系统资源！</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一个问题：由于一个中文在UTF-8编码方案中是占3个字节，采用一次读取一个字节的方式，读一个字节就相当于读了1&#x2F;3个汉字，此时将这个字节转换为字符，是会有乱码的。</p>
<h3 id="FileInputStream读取多个字节"><a href="#FileInputStream读取多个字节" class="headerlink" title="FileInputStream读取多个字节"></a>FileInputStream读取多个字节</h3><p>我们学习了FileInputStream调用read()方法，可以一次读取一个字节。但是这种读取方式效率太太太太慢了。 为了提高效率，我们可以使用另一个read(byte[] bytes)的重载方法，可以一次读取多个字节，至于一次读多少个字节，就在于你传递的数组有多大。</p>
<p>使用FileInputStream一次读取多个字节的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileInputStream文件字节输入流管道，与源文件接通。</span><br><span class="line">第二步：调用read(<span class="type">byte</span>[] bytes)方法开始读取文件的字节数据。</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用FileInputStream每次读取多个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流对象代表字节输入流管道与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima02.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件中的字节数据：每次读取多个字节。</span></span><br><span class="line">        <span class="comment">//  public int read(byte b[]) throws IOException</span></span><br><span class="line">        <span class="comment">//  每次读取多个字节到字节数组中去，返回读取的字节数量，读取完毕会返回-1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环改造。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。  abc 66</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意：读取多少，倒出多少。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 性能得到了明显的提升！！</span></span><br><span class="line">        <span class="comment">// 这种方案也不能避免读取汉字输出乱码的问题！！</span></span><br><span class="line"></span><br><span class="line">        is.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要我们注意的是：<strong>read(byte[] bytes)它的返回值，表示当前这一次读取的字节个数。</strong></li>
</ul>
<p>假设有一个a.txt文件如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br></pre></td></tr></table></figure>

<p>每次读取过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">也就是说，并不是每次读取的时候都把数组装满，比如数组是 <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">第一次调用read(bytes)读取了<span class="number">3</span>个字节(分别是<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>)，并且往数组中存，此时返回值就是<span class="number">3</span></span><br><span class="line">第二次调用read(bytes)读取了<span class="number">2</span>个字节(分别是<span class="number">99</span>,<span class="number">100</span>),并且往数组中存，此时返回值是<span class="number">2</span></span><br><span class="line">第三次调用read(bytes)文件中后面已经没有数据了，此时返回值为-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还需要注意一个问题：采用一次读取多个字节的方式，也是可能有乱码的。因为也有可能读取到半个汉字的情况。</li>
</ul>
<h3 id="FileInputStream读取全部字节"><a href="#FileInputStream读取全部字节" class="headerlink" title="FileInputStream读取全部字节"></a>FileInputStream读取全部字节</h3><p>同学们，前面我们到的读取方式，不管是一次读取一个字节，还是一次读取多个字节，都有可能有乱码。那么接下来我们介绍一种，不出现乱码的读取方式。</p>
<p>我们可以一次性读取文件中的全部字节，然后把全部字节转换为一个字符串，就不会有乱码了。</p>
<p>方式一:自己定义一个字节数组与被读取的文件大小一样大，然后使用该字节数组，一次读完文件的全部字节。<br>方法名称                         说明<br>public int read(byte[] buffer)  每次用一个字节数组去读取，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、准备一个字节数组，大小与文件的大小正好一样大。</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> f.length();</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) size];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buffer);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>
<p>方式二:Java官方为InputStream提供了如下方法，可以直接把文件的全部字节读取到一个字节数组中返回。<br>方法名称                        说明<br>public byte[] readAllBytes() throws IOException<br>直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、调用方法读取所有字节，返回一个存储所有字节的字节数组。</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>

<p>最后，还是要注意一个问题：<strong>一次读取所有字节虽然可以解决乱码问题，但是文件不能过大，如果文件过大，可能导致内存溢出。</strong></p>
<h3 id="FileOutputStream写字节"><a href="#FileOutputStream写字节" class="headerlink" title="FileOutputStream写字节"></a>FileOutputStream写字节</h3><p>使用FIleInputStream读取文件中的字节数据。然后有同学就迫不及待的想学习往文件中写入数据了。</p>
<p>往文件中写数据需要用到OutputStream下面的一个子类FileOutputStream。写输入的流程如下图所示</p>
<p>使用FileOutputStream往文件中写数据的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileOutputStream文件字节输出流管道，与目标文件接通。</span><br><span class="line">第二步：调用wirte()方法往文件中写数据</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输出流FileOutputStream的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="comment">// 覆盖管道：覆盖之前的数据</span></span><br><span class="line"><span class="comment">//        OutputStream os =</span></span><br><span class="line"><span class="comment">//                new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加数据的管道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/itheima04out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始写字节数据出去了</span></span><br><span class="line">        os.write(<span class="number">97</span>); <span class="comment">// 97就是一个字节，代表a</span></span><br><span class="line">        os.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// &#x27;b&#x27;也是一个字节</span></span><br><span class="line">        <span class="comment">// os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我爱你中国abc&quot;</span>.getBytes();</span><br><span class="line">        os.write(bytes);</span><br><span class="line"></span><br><span class="line">        os.write(bytes, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换行符</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        os.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字节流复制文件"><a href="#字节流复制文件" class="headerlink" title="字节流复制文件"></a>字节流复制文件</h3><p>在前面已经把字节输入流和字节输出流都学习完了。现在我们就可以用这两种流配合起来使用，做一个文件复制的综合案例。</p>
<p>比如：我们要复制一张图片，从磁盘<code>D:/resource/meinv.png</code>的一个位置，复制到<code>C:/data/meinv.png</code>位置。</p>
<p>复制文件的思路如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>需要创建一个FileInputStream流与源文件接通，创建FileOutputStream与目标文件接通</span><br><span class="line"><span class="number">2.</span>然后创建一个数组，使用FileInputStream每次读取一个字节数组的数据，存如数组中</span><br><span class="line"><span class="number">3.</span>然后再使用FileOutputStream把字节数组中的有效元素，写入到目标文件中</span><br></pre></td></tr></table></figure>


<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：使用字节流完成对文件的复制操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：复制照片。</span></span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.png&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">        <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO流资源释放"><a href="#IO流资源释放" class="headerlink" title="IO流资源释放"></a>IO流资源释放</h2><h3 id="JDK7以前的资源释放"><a href="#JDK7以前的资源释放" class="headerlink" title="JDK7以前的资源释放"></a>JDK7以前的资源释放</h3><p>在JDK7版本以前，我们可以使用try…catch…finally语句来处理。格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//有可能产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放资源的代码</span></span><br><span class="line">    <span class="comment">//finally里面的代码有一个特点，不管异常是否发生，finally里面的代码都会执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造上面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源的操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(os != <span class="literal">null</span>) os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码写到这里，有很多同学就已经看不下去了。是的，我也看不下去，本来几行代码就写完了的，加上try…catch…finally之后代码多了十几行，而且阅读性并不高。难受….</p>
<h3 id="JDK7以后的资源释放"><a href="#JDK7以后的资源释放" class="headerlink" title="JDK7以后的资源释放"></a>JDK7以后的资源释放</h3><p>刚才已经发现了try…catch…finally处理异常，并释放资源代码比较繁琐。Java在JDK7版本为我们提供了一种简化的是否资源的操作，它会自动是否资源。代码写起来也想当简单。</p>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象<span class="number">1</span>; 资源对象<span class="number">2</span>;)&#123;</span><br><span class="line">    使用资源的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    处理异常的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：注意到没有，这里没有释放资源的代码。它会自动是否资源</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握释放资源的方式：try-with-resource</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    	<span class="keyword">try</span> (</span><br><span class="line">          <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.png&quot;</span>);</span><br><span class="line">          <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">          <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.png&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>同学们，前面我们学习了字节流，使用字节流可以读取文件中的字节数据。但是如果文件中有中文，使用字节流来读取，就有可能读到半个汉字的情况，这样会导致乱码。虽然使用读取全部字节的方法不会出现乱码，但是如果文件过大又不太合适。</p>
<p>所以Java专门为我们提供了另外一种流，叫字符流，可以字符流是专门为读取文本数据而生的。</p>
<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p>先类学习字符流中的FileReader类，这是字符输入流，用来将文件中的字符数据读取到程序中来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh90.png"></p>
<p>FileReader读取文件的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileReader对象与要读取的源文件接通</span><br><span class="line">第二步：调用read()方法读取文件中的字符</span><br><span class="line">第三步：调用close()方法关闭流</span><br></pre></td></tr></table></figure>


<p>需要用到的方法：先通过构造器创建对象，再通过read方法读取数据（<strong>注意：两个read方法的返回值，含义不一样</strong>）</p>
<p>构造器                             说明<br>public FileReader(File file)       创建字符输入流管道与源文件接通<br>public FileReader(String pathname) 创建字符输入流管道与源文件接通</p>
<p>方法名称                     说明<br>public int read()<br>每次读取一个字符返回，如果发现没有数据可读会返回-1<br>public int read(char[ ] buffer)<br>如果发现没有数据可读会返回-1.每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输入流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字符输入流管道与源文件接通</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 2、一个字符一个字符的读（性能较差）</span></span><br><span class="line"><span class="comment">//            int c; // 记住每次读取的字符编号。</span></span><br><span class="line"><span class="comment">//            while ((c = fr.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print((char) c);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 每次读取一个字符的形式，性能肯定是比较差的。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、每次读取多个字符。（性能是比较不错的！）</span></span><br><span class="line">            <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字符。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><p>我们学习了FileReader，它可以将文件中的字符数据读取到程序中来。接下来，我们就要学习FileWriter了，它可以将程序中的字符数据写入文件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh90.png"></p>
<p>FileWriter往文件中写字符数据的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileWirter对象与要读取的目标文件接通</span><br><span class="line">第二步：调用write(字符数据/字符数组/字符串)方法读取文件中的字符</span><br><span class="line">第三步：调用close()方法关闭流</span><br></pre></td></tr></table></figure>

<p>需要用到的方法如下：构造器是用来创建FileWriter对象的，有了对象才能调用write方法写数据到文件。</p>
<p>构造器                            说明<br>public Filewriter(File file)<br>创建字节输出流管道与源文件对象接通</p>
<p>public Filewriter(string filepath)<br>创建字节输出流管道与源文件路径接通</p>
<p>public Filewriter(File file，boolean append)<br>创建字节输出流管道与源文件对象接通，可追加数据</p>
<p>public Filewriter(string filepath, boolean append)<br>创建字节输出流管道与源文件路径接通，可追加数据</p>
<p>方法名称                     说明<br>void write(int c)           写一个字符<br>void write(String str)      写一个字符串<br>void write(String str, int off, int len)    写一个字符串的一部分<br>void write(char[]cbuf)                      写入一个字符数组<br>void write(char[] cbuf, int off, jint len)  写入字符数组的一部分</p>
<p>接下来，用代码演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输出流：写字符数据出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 0、创建一个文件字符输出流管道与目标文件接通。</span></span><br><span class="line">                <span class="comment">// 覆盖管道</span></span><br><span class="line">                <span class="comment">// Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;);</span></span><br><span class="line">                <span class="comment">// 追加数据的管道</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima02out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 1、public void write(int c):写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            fw.write(<span class="number">97</span>);</span><br><span class="line">            <span class="comment">//fw.write(&#x27;磊&#x27;); // 写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、public void write(String c)写一个字符串出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">            <span class="type">char</span>[] buffer = &#123;<span class="string">&#x27;黑&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">            fw.write(buffer);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">            fw.write(buffer, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileWriter写的注意事项"><a href="#FileWriter写的注意事项" class="headerlink" title="FileWriter写的注意事项"></a>FileWriter写的注意事项</h3><p>各位同学，刚才我们已经学习了FileWriter字符输出流的基本使用。但是，这里有一个小问题需要和同学们说下一：<strong>FileWriter写完数据之后，必须刷新或者关闭，写出去的数据才能生效。</strong></p>
<p>比如：下面的代码只调用了写数据的方法，没有关流的方法。当你打开目标文件时，是看不到任何数据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>而下面的代码，加上了flush()方法之后，数据就会立即到目标文件中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.刷新</span></span><br><span class="line">fw.flush(); </span><br></pre></td></tr></table></figure>

<p>下面的代码，调用了close()方法，数据也会立即到文件中去。因为close()方法在关闭流之前，会将内存中缓存的数据先刷新到文件，再关流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭流</span></span><br><span class="line">fw.close(); <span class="comment">//会先刷新，再关流</span></span><br></pre></td></tr></table></figure>

<p>但是需要注意的是，关闭流之后，就不能在对流进行操作了。否则会出异常</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>学习完字符流之后，接下来我们学习一下缓冲流。我们还是先来认识一下缓存流，再来说一下它的作用。缓冲流有四种，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh91.png"></p>
<p><strong>缓冲流的作用</strong>：可以对原始流进行包装，提高原始流读写数据的性能。</p>
<h3 id="缓冲字节流"><a href="#缓冲字节流" class="headerlink" title="缓冲字节流"></a>缓冲字节流</h3><p>我们先来学习字节缓冲流是如何提高读写数据的性能的，原理如下图所示。是因为在缓冲流的底层自己封装了一个长度为8KB（8129byte）的字节数组，但是缓冲流不能单独使用，它需要依赖于原始流。</p>
<ul>
<li><strong>读数据时：</strong>它先用原始字节输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps: 先一次多囤点货），再从8KB的字节数组中读取一个字节或者多个字节（把消耗屯的货）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh92.png"></p>
<ul>
<li><strong>写数据时：</strong> 它是先把数据写到缓冲流内部的8BK的数组中（ps: 先攒一车货），等数组存满了，再通过原始的字节输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh93.png"></p>
<p>在创建缓冲字节流对象时，需要封装一个原始流对象进来。构造方法如下</p>
<p>构造器                 说明<br>public BufferedInputStream(InputStream is)<br>把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能</p>
<p>public BufferedOutputStream(OutputStream os)<br>把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p>
<p>如果我们用缓冲流复制文件，代码写法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima01.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 1、定义一个字节缓冲输入流包装原始的字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima01_bak.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、定义一个字节缓冲输出流包装原始的字节输出流</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-2-字符缓冲流"><a href="#2-2-字符缓冲流" class="headerlink" title="2.2 字符缓冲流"></a>2.2 字符缓冲流</h3><p>接下来，我们学习另外两个缓冲流——字符缓冲流。它的原理和字节缓冲流是类似的，它底层也会有一个8KB的数组，但是这里是字符数组。字符缓冲流也不能单独使用，它需要依赖于原始字符流一起使用。</p>
<ul>
<li><strong>BufferedReader读数据时：</strong>它先原始字符输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps: 先一次多囤点货），再从8KB的字符数组中读取一个字符或者多个字符（把消耗屯的货）。</li>
</ul>
<p>创建BufferedReader对象需要用到BufferedReader的构造方法，内部需要封装一个原始的字符输入流，我们可以传入FileReader.</p>
<p>构造器               说明<br>public BufferedReader(Reader n)<br>把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能</p>
<p>而且BufferedReader还要特有的方法，一次可以读取文本文件中的一行</p>
<p>方法            说明<br>public string readLine()<br>读取一行数据返回，如果没有数据可读了，会返回null</p>
<p>使用BufferedReader读取数据的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2\\src\\itheima04.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建一个字符缓冲输入流包装原始的字符输入流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">        )&#123;</span><br><span class="line"><span class="comment">//            char[] buffer = new char[3];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while ((len = br.read(buffer)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(new String(buffer, 0, len));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"></span><br><span class="line">            String line; <span class="comment">// 记住每次读取的一行数据</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>BufferedWriter写数据时：</strong> 它是先把数据写到字符缓冲流内部的8BK的数组中（ps: 先攒一车货），等数组存满了，再通过原始的字符输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。如下图所示</li>
</ul>
<p>创建BufferedWriter对象时需要用到BufferedWriter的构造方法，而且内部需要封装一个原始的字符输出流，我们这里可以传递FileWriter。</p>
<p>构造器                    说明<br>public BufferedWriter(Writer r)<br>把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能</p>
<p>而且BufferedWriter新增了一个功能，可以用来写一个换行符</p>
<p>方法                    说明<br>public void newLine()   换行</p>
<p>接下来，用代码演示一下，使用BufferedWriter往文件中写入字符数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima05out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 创建一个字符缓冲输出流管道包装原始的字符输出流</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            bw.write(<span class="number">97</span>);</span><br><span class="line">            bw.write(<span class="string">&#x27;磊&#x27;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="缓冲流性能分析"><a href="#缓冲流性能分析" class="headerlink" title="缓冲流性能分析"></a>缓冲流性能分析</h3><p>我们说缓冲流内部多了一个数组，可以提高原始流的读写性能。讲到这一定有同学有这么一个疑问，它和我们使用原始流，自己加一个8BK数组不是一样的吗？ 缓冲流就一定能提高性能吗？先告诉同学们答案，<strong>缓冲流不一定能提高性能</strong>。</p>
<blockquote>
<p>下面我们用一个比较大文件（889MB）复制，做性能测试，分别使用下面四种方式来完成文件复制，并记录文件复制的时间。</p>
</blockquote>
<p>① 使用低级流一个字节一个字节的复制</p>
<p>② 使用低级流按照字节数组的形式复制</p>
<p>③ 使用缓冲流一个字节一个字节的复制</p>
<p>④ 使用缓冲流按照字节数组的形式复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">低级流一个字节复制: 慢得简直让人无法忍受</span><br><span class="line">低级流按照字节数组复制(数组长度<span class="number">1024</span>): <span class="number">12.</span>117s</span><br><span class="line">缓冲流一个字节复制: <span class="number">11.</span>058s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">1024</span>): <span class="number">2.</span>163s</span><br><span class="line">【注意：这里的测试只能做一个参考，和电脑性能也有直接关系】</span><br></pre></td></tr></table></figure>

<p>经过上面的测试，我们可以得出一个结论：<strong>默认情况下，采用一次复制1024个字节，缓冲流完胜。</strong></p>
<blockquote>
<p>但是，缓冲流就一定性能高吗？我们采用一次复制8192个字节试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">2.</span>535s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">2.</span>088s</span><br></pre></td></tr></table></figure>

<p>经过上面的测试，我们可以得出一个结论：<strong>一次读取8192个字节时，低级流和缓冲流性能相当。</strong>相差的那几毫秒可以忽略不计。</p>
<blockquote>
<p>继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*32个字节数据试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>128s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>133s</span><br></pre></td></tr></table></figure>

<p>经过上面的测试，我们可以得出一个结论：<strong>数组越大性能越高，低级流和缓冲流性能相当。</strong>相差的那几秒可以忽略不计。</p>
<blockquote>
<p>继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*6个字节数据试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>039s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>151s</span><br></pre></td></tr></table></figure>

<p>此时你会发现，当数组大到一定程度，性能已经提高了多少了，甚至缓冲流的性能还没有低级流高。</p>
<p>最终总结一下：<strong>缓冲流的性能不一定比低级流高，其实低级流自己加一个数组，性能其实是不差。</strong>只不过缓冲流帮你加了一个相对而言大小比较合理的数组 。</p>
<h2 id="三、转换流"><a href="#三、转换流" class="headerlink" title="三、转换流"></a>三、转换流</h2><p>前面我们学习过FileReader读取文件中的字符，但是同学们注意了，FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码，因为FileReader它遇到汉字默认是按照3个字节来读取的，而GBK格式的文件一个汉字是占2个字节，这样就会导致乱码。</p>
<p>Java给我们提供了另外两种流InputStreamReader，OutputStreamWriter，这两个流我们把它叫做转换流。它们可以将字节流转换为字符流，并且可以指定编码方案。</p>
<h3 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h3><p>接下来，我们先学习InputStreamReader类，你看这个类名就比较有意思，前面是InputStream表示字节输入流，后面是Reader表示字符输入流，合在一起意思就是表示可以把InputStream转换为Reader，最终InputStreamReader其实也是Reader的子类，所以也算是字符输入流。</p>
<p>InputStreamReader也是不能单独使用的，它内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。</p>
<blockquote>
<p>需求：我们可以先准备一个GBK格式的文件，然后使用下面的代码进行读取，看是是否有乱码。</p>
</blockquote>
<p>1床前明月光c<br>2疑是地上霜b<br>3低头思姑娘a<br>abcde<br>GBK格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、得到文件的原始字节流（GBK的字节流形式）</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima06.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输入流包装成缓冲字符输入流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">                )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完之后，你会发现没有乱码。</p>
<h3 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h3><p>接下来，我们先学习OutputStreamWriter类，你看这个类名也比较有意思，前面是OutputStream表示字节输出流，后面是Writer表示字符输出流，合在一起意思就是表示可以把OutputStream转换为Writer，最终OutputStreamWriter其实也是Writer的子类，所以也算是字符输出流。</p>
<p>OutputStreamReader也是不能单独使用的，它内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。</p>
<blockquote>
<p>需求：我们可以先准备一个GBK格式的文件，使用下面代码往文件中写字符数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定写出去的字符编码。</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字节输出流</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima07out.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输出流包装成缓冲字符输出流</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(<span class="string">&quot;我是中国人abc&quot;</span>);</span><br><span class="line">            bw.write(<span class="string">&quot;我爱你中国123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>接下来，我们学习打印流，其实打印流我们从开学第一天就一直再使用，只是没有学到你感受不到而已。打印流可以实现更加方便，更加高效的写数据的方式。</p>
<h3 id="打印流基本使用"><a href="#打印流基本使用" class="headerlink" title="打印流基本使用"></a>打印流基本使用</h3><p>打印流，这里所说的打印其实就是写数据的意思，它和普通的write方法写数据还不太一样，一般会使用打印流特有的方法叫<code>print(数据)</code>或者<code>println(数据)</code>，它打印啥就输出啥。</p>
<p>打印流有两个，一个是字节打印流PrintStream，一个是字符打印流PrintWriter，如下图所示</p>
<p><strong>PrintStream和PrintWriter的用法是一样的，所以这里就一块演示了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个打印流管道</span></span><br><span class="line"><span class="comment">//                PrintStream ps =</span></span><br><span class="line"><span class="comment">//                        new PrintStream(&quot;io-app2/src/itheima08.txt&quot;, Charset.forName(&quot;GBK&quot;));</span></span><br><span class="line"><span class="comment">//                PrintStream ps =</span></span><br><span class="line"><span class="comment">//                        new PrintStream(&quot;io-app2/src/itheima08.txt&quot;);</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">ps</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima08.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">                ps.print(<span class="number">97</span>);	<span class="comment">//文件中显示的就是:97</span></span><br><span class="line">                ps.print(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//文件中显示的就是:a</span></span><br><span class="line">                ps.println(<span class="string">&quot;我爱你中国abc&quot;</span>);	<span class="comment">//文件中显示的就是:我爱你中国abc</span></span><br><span class="line">                ps.println(<span class="literal">true</span>);<span class="comment">//文件中显示的就是:true</span></span><br><span class="line">                ps.println(<span class="number">99.5</span>);<span class="comment">//文件中显示的就是99.5</span></span><br><span class="line"></span><br><span class="line">                ps.write(<span class="number">97</span>); <span class="comment">//文件中显示a，发现和前面println方法的区别了吗？</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="重定向输出语句"><a href="#重定向输出语句" class="headerlink" title="重定向输出语句"></a>重定向输出语句</h3><p>其实我们开学第一课，就给同学们讲过<code>System.out.println()</code>这句话表示打印输出，但是至于为什么能够输出，其实我们一直不清楚。</p>
<p>以前是因为知识储备还不够，无法解释，到现在就可以给同学们揭晓谜底了，因为System里面有一个静态变量叫out，out的数据类型就是PrintStream，它就是一个打印流，而且这个打印流的默认输出目的地是控制台，所以我们调用<code>System.out.pirnln()</code>就可以往控制台打印输出任意类型的数据，而且打印啥就输出啥。</p>
<p>而且System还提供了一个方法，可以修改底层的打印流，这样我们就可以重定向打印语句的输出目的地了。我们玩一下, 直接上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老骥伏枥&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;志在千里&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io-app2/src/itheima09.txt&quot;</span>); )&#123;</span><br><span class="line">            <span class="comment">// 把系统默认的打印流对象改成自己设置的打印流</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;烈士暮年&quot;</span>);	</span><br><span class="line">            System.out.println(<span class="string">&quot;壮心不已&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时打印语句，将往文件中打印数据，而不在控制台。</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>同学们，接下我们再学习一种流，这种流在开发中偶尔也会用到。比如，我们想把数据和数据的类型一并写到文件中去，读取的时候也将数据和数据类型一并读出来。这就可以用到数据流，有两个DataInputStream和DataOutputStream.</p>
<h3 id="DataOutputStream类"><a href="#DataOutputStream类" class="headerlink" title="DataOutputStream类"></a>DataOutputStream类</h3><p>我们先学习DataOutputStream类，它也是一种包装流，创建DataOutputStream对象时，底层需要依赖于一个原始的OutputStream流对象。然后调用它的wirteXxx方法，写的是特定类型的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/1667924147403.png" alt="1667924147403"></p>
<p>构造器            说明<br>public DataOutputstream(outputstream out)<br>创建新数据输出流包装基础的字节输出流</p>
<p>方法              说明<br>public final void writeByte(int v) throws IOException<br>将byte类型的数据写入基础的字节输出流<br>public final void writeInt(int v) throws IOException<br>将int类型的数据写入基础的字节输出流<br>public final void writeDouble(Double v) throws IOException<br>将double类型的数据写入基础的字节输出流<br>public final void writeUTF(String str) throws IOException<br>将字符串数据以UTF-8编码成字节写入基础的字节输出流<br>public void write(int&#x2F;byte[ ]&#x2F;byte[]一部分)<br>支持写字节数据出去</p>
<p>代码如下：往文件中写整数、小数、布尔类型数据、字符串数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataOutputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个数据输出流包装低级的字节输出流</span></span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima10out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            dos.writeInt(<span class="number">97</span>);</span><br><span class="line">            dos.writeDouble(<span class="number">99.5</span>);</span><br><span class="line">            dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;黑马程序员666！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3><p>学习完DataOutputStream后，再学习DataIntputStream类，它也是一种包装流，创建DataInputStream对象时，底层需要依赖于一个原始的InputStream流对象。然后调用它的readXxx()方法就可以读取特定类型的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/1667924375953.png" alt="1667924375953"></p>
<p>构造器                   说明<br>public DataInputstream(InputStream is)<br>创建新数据输入流包装基础的字节输入流</p>
<p>方法                     说明<br>Public final byte readByte() throws IOException<br>读取字节数据返回<br>public final int readInt() throwsIOException<br>读取int类型的数据返回<br>public final double readDouble() throws IOException<br>读取double类型的数据返回<br>public final string readUTF() throws IOException<br>读取字符串数（UTF-8）据返回<br>public int readInt( )&#x2F;read(byte[])<br>支持读字节数据进来</p>
<p>代码如下：读取文件中特定类型的数据（整数、小数、字符串等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima10out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">            System.out.println(d);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">            System.out.println(b);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            System.out.println(rs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><p>各位同学同学，还有最后一个流要学习，叫做序列化流。序列化流是干什么用的呢？ 我们知道字节流是以字节为单位来读写数据、字符流是按照字符为单位来读写数据、而对象流是以对象为单位来读写数据。也就是把对象当做一个整体，可以写一个对象到文件，也可以从文件中把对象读取出来。</p>
<p>这里有一个新词 序列化，第一次听同学们可能还比较陌生，我来给同学们解释一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化：意思就是把对象写到文件或者网络中去。（简单记：写对象）</span><br><span class="line">反序列化：意思就是把对象从文件或者网络中读取出来。（简单记：读对象）</span><br></pre></td></tr></table></figure>

<h3 id="ObjectOutputStraem类"><a href="#ObjectOutputStraem类" class="headerlink" title="ObjectOutputStraem类"></a>ObjectOutputStraem类</h3><p>接下来，先学习ObjectOutputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输出流使用。</p>
<p>代码如下：将一个User对象写到文件中去</p>
<ul>
<li>第一步：先准备一个User类，必须让其实现Serializable接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：对象如果需要序列化，必须实现序列化接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// transient 这个成员变量将不参与序列化。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String loginName, String userName, <span class="type">int</span> age, String passWord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginName = loginName;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;loginName=&#x27;&quot;</span> + loginName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + passWord + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：再创建ObjectOutputStream流对象，调用writeObject方法对象到文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1ObjectOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 2、创建一个对象字节输出流包装原始的字节 输出流。</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima11out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 1、创建一个Java对象。</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">32</span>, <span class="string">&quot;666888xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、序列化对象到文件中去</span></span><br><span class="line">            oos.writeObject(u);</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化对象成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：写到文件中的对象，是不能用记事本打开看的。因为对象本身就不是文本数据，打开是乱码</strong></p>
<p>怎样才能读懂文件中的对象是什么呢？这里必须用反序列化，自己写代码读。</p>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p>接下来，学习ObjectInputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输入流使用。</p>
<p>接着前面的案例，文件中已经有一个Student对象，现在要使用ObjectInputStream读取出来。称之为反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2ObjectInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 1、创建一个对象字节输入流管道，包装 低级的字节输入流与源文件接通</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima11out.txt&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="补充知识：IO框架"><a href="#补充知识：IO框架" class="headerlink" title="补充知识：IO框架"></a>补充知识：IO框架</h2><p>最后，再给同学们补充讲解一个知识，叫做IO框架。它有什么用呢？有同学经常问老师，我们只学习了IO流对文件复制，能不能复制文件夹呀？ </p>
<p>当然是可以咯，但是如果让我们自己写复制文件夹的代码需要用到递归，还是比较麻烦的。为了简化对IO操作，<strong>由apache开源基金组织提供了一组有关IO流小框架，可以提高IO流的开发效率。</strong></p>
<p>这个框架的名字叫commons-io：其本质是别人写好的一些字节码文件（class文件），打包成了一个jar包。我们只需要把jar包引入到我们的项目中，就可以直接用了。 </p>
<p>这里给同学们介绍一个jar包中提供的工具类叫FileUtils，它的部分功能如下，很方便，你一看名字就知道怎么用了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/1667925627850.png" alt="1667925627850"></p>
<p>FileUtils类提供的部分方法展示                  说明<br>public static void copyFile(File srcFile，File destFile)<br>复制文件。<br>public static void copyDirectory(File srcDir，File destDir)<br>复制文件夹<br>public static void deleteDirectory(File directory)<br>删除文件夹<br>public static string readFileToString(File file，string encoding)<br>读数据<br>public static void writeStringToFile(File file,string data, String charname， boolean append)<br>写数据</p>
<p>IOUtils类提供的部分方法展示                  说明<br>public static int copy(InputStream inputstream，outputstream outputstream)<br>复制文件。<br>public static int copy(Reader reader，writer writer)<br>复制文件。<br>public static void write(String data,outputStream output，string charsetName)<br>写数据</p>
<p>在写代码之前，先需要引入jar包，具体步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在模块的目录下，新建一个lib文件夹</span><br><span class="line"><span class="number">2.</span>把jar包复制粘贴到lib文件夹下</span><br><span class="line"><span class="number">3.</span>选择lib下的jar包，右键点击Add As Library，然后就可以用了。</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIOTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.复制文件</span></span><br><span class="line">        FileUtils.copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io-app2/src/a.txt&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.复制文件夹</span></span><br><span class="line">        FileUtils.copyDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏3&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.删除文件夹</span></span><br><span class="line">        FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java提供的原生的一行代码搞定很多事情</span></span><br><span class="line">         Files.copy(Path.of(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>), Path.of(<span class="string">&quot;io-app2\\src\\b.txt&quot;</span>));</span><br><span class="line">        System.out.println(Files.readString(Path.of(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="特殊文件、日志技术、多线程"><a href="#特殊文件、日志技术、多线程" class="headerlink" title="特殊文件、日志技术、多线程"></a>特殊文件、日志技术、多线程</h1><h2 id="属性文件"><a href="#属性文件" class="headerlink" title="属性文件"></a>属性文件</h2><h3 id="特殊文件概述"><a href="#特殊文件概述" class="headerlink" title="特殊文件概述"></a>特殊文件概述</h3><p>同学们，前面我们学习了IO流，我们知道IO流是用来读、写文件中的数据。但是我们接触到的文件都是普通的文本文件，普通的文本文件里面的数据是没有任何格式规范的，用户可以随意编写，如下图所示。</p>
<p>像这种普通的文本文件，没有任何规律可言，不方便程序对文件中的数据信息处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh94.png"></p>
<p>在以后的Java开发过程中还会遇到一些特殊的文本文件，这些文件是有一些格式要求的，方便程序对文件中的数据进行处理。</p>
<p>比如，后面我们会用到两种特殊的文本文件，一种是properties文件，还有一种是xml文件。如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh95.png"></p>
<ul>
<li>后缀为.properties的文件，称之为属性文件，它可以很方便的存储一些类似于键值对的数据。经常当做软件的配置文件使用。</li>
<li>而xml文件能够表示更加复杂的数据关系，比如要表示多个用户的用户名、密码、家乡、性别等。在后面，也经常当做软件的配置文件使用。</li>
</ul>
<p>现在，学习特殊的文件主要学习什么呢？ 主要学习以下的三点</p>
<ol>
<li>了解它们的特点、作用</li>
<li>学习使用程序读取它们里面的数据</li>
<li>学习使用程序把数据存储到这些文件里</li>
</ol>
<h3 id="Properties属性文件"><a href="#Properties属性文件" class="headerlink" title="Properties属性文件"></a>Properties属性文件</h3><p>接下来，我们先学习Properties这种属性文件。首先我们要掌握属性文件的格式：</p>
<ol>
<li>属性文件后缀以<code>.properties</code>结尾</li>
<li>属性文件里面的每一行都是一个键值对，键和值中间用&#x3D;隔开。比如: <code>admin=123456</code> </li>
<li><code>#</code>表示这样是注释信息，是用来解释这一行配置是什么意思。</li>
<li>每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。</li>
<li>键不能重复，值可以重复</li>
</ol>
<p>如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh96.png"></p>
<p>接下来，我们学习如何读取属性文件中的数据。这里需要给同学们，介绍一个来叫Properties.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Properties是什么？</span><br><span class="line">    Properties是Map接口下面的一个实现类，所以Properties也是一种双列集合，用来存储键值对。	  但是一般不会把它当做集合来使用。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>Properties核心作用？</span><br><span class="line">    Properties类的对象，用来表示属性文件，可以用来读取属性文件中的键值对。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用Properties读取属性文件中的键值对</strong>，需要用到的方法如下。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/1667992486134.png" alt="1667992486134"></p>
<p>构造器                       说明<br>public Properties()<br>用于构建Properties集合对象(空容器)</p>
<p>常用方法                     说明<br>public void load(InputStream is)<br>通过字节输入流，读取属性文件里的键值对数据<br>public void load(Reader reader)<br>通过字符输入流，读取属性文件里的键值对数据<br>public string getProperty(String key)<br>根据键获取值(其实就是get方法的效果)<br>public Set<String> stringPropertyNames()<br>获取全部键的集合(其实就是ketSet方法的效果)</p>
<p>实用Properties读取属性文件的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、创建一个Properties的对象出来（键值对集合，空容器）</span><br><span class="line"><span class="number">2</span>、调用load(字符输入流/字节输入流)方法，开始加载属性文件中的键值对数据到properties对象中去</span><br><span class="line"><span class="number">3</span>、调用getProperty(键)方法，根据键取值</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用Properties类读取属性文件中的键值对信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Properties的对象出来（键值对集合，空容器）</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始加载属性文件中的键值对数据到properties对象中去</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;properties-xml-log-app\\src\\users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、根据键取值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;赵敏&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;张无忌&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、遍历全部的键和值。</span></span><br><span class="line">        <span class="comment">//获取键的集合</span></span><br><span class="line">        Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="comment">//再根据键获取值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        properties.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用Properties往属性文件中写键值对</strong>，需要用到的方法如下</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/1667993320872.png" alt="1667993320872"></p>
<p>常用方法                    说明<br>public Object setProperty(String key,String value)<br>保存键值对数据到Properties对象中去。<br>public void store(OutputStream os，String comments)<br>把键值对数据，通过字节输出流写出到属性文件里去<br>public void store(writer w,String comments)<br>把键值对数据，通过字符输出流写出到属性文件里去</p>
<p>往Properties属性文件中写键值对的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、先准备一个.properties属性文件，按照格式写几个键值对</span><br><span class="line"><span class="number">1</span>、创建Properties对象出来，</span><br><span class="line"><span class="number">2</span>、调用setProperty存储一些键值对数据</span><br><span class="line"><span class="number">3</span>、调用store(字符输出流/字节输出流, 注释)，将Properties集合中的键和值写到文件中</span><br><span class="line">    注意：第二个参数是注释，必须得加；</span><br></pre></td></tr></table></figure>

<p>先准备一个<code>users.properties</code>属性文件，如下图所示</p>
<p>#以下内容都是用户名和密码。<br>admin&#x3D;123456<br>张无忌&#x3D;minmin<br>周芷若&#x3D;wuji<br>赵敏&#x3D;wuji</p>
<p>接下来，编写代码读取上面的属性文件。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Properties对象出来，先用它存储一些键值对数据</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;minmin&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;殷素素&quot;</span>, <span class="string">&quot;cuishan&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;susu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把properties对象中的键值对数据存入到属性文件中去</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/users2.properties&quot;</span>)</span><br><span class="line">                         , <span class="string">&quot;i saved many users!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h2><p>同学们，在上一节我们学习了properties属性文件。接下来我们再学习一种在开发中经常使用的文件，叫做xml文件。我们先来给同学们介绍一下，什么是xml文件，然后再来学习如何读取xml文件中的数据。</p>
<h3 id="XML文件概述"><a href="#XML文件概述" class="headerlink" title="XML文件概述"></a>XML文件概述</h3><p><strong>首先，我们来认识一下，什么是XML？</strong></p>
<p>XML是可扩展的标记语言，意思是它是由一些标签组成	的，而这些标签是自己定义的。本质上一种数据格式，可以用来表示复杂的数据关系。</p>
<p>XML文件有如下的特点：</p>
<ul>
<li>XML中的<code>&lt;标签名&gt;</code> 称为一个标签或者一个元素，一般是成对出现的。</li>
<li>XML中的标签名可以自己定义（可扩展），但是必须要正确的嵌套</li>
<li>XML中只能有一个根标签。</li>
<li>XML标准中可以有属性</li>
<li>XML必须第一行有一个文档声明，格式是固定的<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></li>
<li>XML文件必须是以.xml为后缀结尾</li>
</ul>
<p>如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh97.png"><br><strong>接下，同学们可以跟着步骤新建一个XML文件，试试！</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh98.png"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  根标签只能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一个用户&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张无忌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>minmin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span>&gt;</span>很多人<span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>敏敏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>wuji<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面XML文件中的数据格式是最为常见的，标签有属性、文本、还有合理的嵌套。XML文件中除了写以上的数据格式之外，还有一些特殊的字符不能直接写。</p>
<ul>
<li><p>像 <code>&lt;,&gt;,&amp; </code>等这些符号不能出现在标签的文本中，因为标签格式本身就有&lt;&gt;，会和标签格式冲突。</p>
<p>如果标签文本中有这些特殊字符，需要用一些占位符代替。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;  表示 &lt;</span><br><span class="line">&amp;gt;  表示 &gt;</span><br><span class="line">&amp;amp; 表示 &amp;</span><br><span class="line">&amp;apos; 表示 &#x27;</span><br><span class="line">&amp;quot; 表示 &quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span> 3 <span class="symbol">&amp;lt;</span> 2 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> 5 <span class="symbol">&amp;gt;</span> 4 <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在标签文本中，出现大量的特殊字符，不想使用特殊字符，此时可以用CDATA区，格式如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data1</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">          3 &lt; 2 &amp;&amp; 5 &gt; 4</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">data1</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>最后，给同学们聊聊，XML在实际开发中有什么作用？</strong></p>
<p>关于XML是什么，以及XML的格式，还有XML有什么作用，就先认识到这里。</p>
<h3 id="XML解析1"><a href="#XML解析1" class="headerlink" title="XML解析1"></a>XML解析1</h3><p>使用程序读取XML文件中的数据，称之为XML解析。这里并不需要我们自己写IO流代码去读取xml文件中的数据。其实有很多开源的，好用的XML解析框架，最知名的是DOM4J（第三方开发的）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh99.png"></p>
<p>由于DOM4J是第三方提供的，所以需要把第三方提供的Jar包导入到自己的项目中来，才可以使用。具体步骤如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh100.png"></p>
<p>DOM4J解析XML文件的思想是：文档对象模型（意思是把整个XML文档、每一个标签、每一个属性都等都当做对象来看待）。Dowument对象表示真个XML文档、Element对象表示标签（元素）、Attribute对象表示属性、标签中的内容就是文本</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh101.png"></p>
<p>DOM4J解析XML需要用到的方法如下图所示</p>
<ul>
<li><p>SAXReader: Dom4j提供的解析器，可以认为是代表整个Dom4j框架<br>构造器&#x2F;方法                        说明<br>public SAXReader()                构建Dom4J的解析器对象<br>public Document read(String url)  把XML文件读成Document对象<br>public Document read(InputStream is) 通过字节输入流读取XML文件</p>
</li>
<li><p>Document<br>方法名                     说明<br>Element getRootElement()  获得根元素对象</p>
</li>
</ul>
<p>XML解析的过程，是从根元素开始，从外层往里层解析。 我们先把Document对象，和根元素获取出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh102.png"></p>
<h3 id="XML解析2"><a href="#XML解析2" class="headerlink" title="XML解析2"></a>XML解析2</h3><p>获取到XML文件的根元素之后，接下来，就可以用根元素在获取到它里面的子元素（包括子标签、表属性等）。需要用到的方法如下图所示</p>
<p>方法名                                  说明<br>public string getName()<br>得到元素名字<br>public List<Element> elements()<br>得到当前元素下所有子元素<br>public list<Element> elements(String name)<br>得到当前元素下指定名字的子元素返回集合<br>public Element element(String name)<br>得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个<br>public stringattributeValue(String name)<br>通过属性名直接得到属性值<br>public String elementText(子元素名)<br>得到指定名称的子元素的文本<br>public string getText()<br>得到文本</p>
<p>接下来，把上面的方法先一个一个的演示一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、获取根元素下的全部一级子元素。</span></span><br><span class="line">        <span class="comment">// List&lt;Element&gt; elements = root.elements();</span></span><br><span class="line">        List&lt;Element&gt; elements = root.elements(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            System.out.println(element.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取当前元素下的某个子元素。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">people</span> <span class="operator">=</span> root.element(<span class="string">&quot;people&quot;</span>);</span><br><span class="line">        System.out.println(people.getText());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下面有很多子元素user，默认获取第一个。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">user</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取元素的属性信息呢？</span></span><br><span class="line">        System.out.println(user.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">id</span> <span class="operator">=</span> user.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        System.out.println(id.getName());</span><br><span class="line">        System.out.println(id.getValue());</span><br><span class="line"></span><br><span class="line">        List&lt;Attribute&gt; attributes = user.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName() + <span class="string">&quot;=&quot;</span> + attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、如何获取全部的文本内容:获取当前元素下的子元素文本值</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        System.out.println(user.elementTextTrim(<span class="string">&quot;地址&quot;</span>)); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Element</span> <span class="variable">data</span> <span class="operator">=</span> user.element(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        System.out.println(data.getText());</span><br><span class="line">        System.out.println(data.getTextTrim()); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="XML文件写入"><a href="#XML文件写入" class="headerlink" title="XML文件写入"></a>XML文件写入</h3><p>在前面我们已经学习了XML解析，意思就是使用程序把XML文件中的数据读取出来。反过来能不能往XML文件中写入数据呢？ 答案是可以的。</p>
<p>DOM4J也提供了往XML文件中写标签的方法，但是用起来比较麻烦。这里不建议使用</p>
<p>我们自己使用StringBuilder按照标签的格式拼接，然后再使用BufferedWriter写到XML文件中去就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、使用一个StringBuilder对象来拼接XML格式的数据。</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;book&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;name&gt;&quot;</span>).append(<span class="string">&quot;从入门到跑路&quot;</span>).append(<span class="string">&quot;&lt;/name&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;author&gt;&quot;</span>).append(<span class="string">&quot;dlei&quot;</span>).append(<span class="string">&quot;&lt;/author&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;price&gt;&quot;</span>).append(<span class="number">999.99</span>).append(<span class="string">&quot;&lt;/price&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;/book&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/book.xml&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XML约束（了解）"><a href="#XML约束（了解）" class="headerlink" title="XML约束（了解）"></a>XML约束（了解）</h3><p>各位小伙伴，关于XML还有最后一个知识需要大家了解一下。这个知识叫做约束XML文件的编写，我讲这个知识的目的是因为同学们以后在开发过程中会遇到这个知识，但是这个代码不需要大家写，了解一下就可以了。</p>
<p><strong>首先，说一些什么是XML约束？</strong></p>
<p>XML约束指的是限制XML文件中的标签或者属性，只能按照规定的格式写。</p>
<p>比如我在项目中，想约束一个XML文件中的标签只能写&lt;书&gt;、&lt;书名&gt;、&lt;作者&gt;、&lt;售价&gt;这几个标签，如果写其他标签就报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh103.png"></p>
<p>怎么才能达到上面的效果呢？有两种约束技术，一种是DTD约束、一种是Schame约束。</p>
<ul>
<li><p>DTD约束案例</p>
<p>如下图所示book.xml中引入了DTD约束文件，book.xml文件中的标签就受到DTD文件的约束</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh104.png"></p>
<p>DTD文件解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 书架(书+)&gt;   表示根标签是&lt;书架&gt;，并且书架中有子标签&lt;书&gt;</span><br><span class="line">&lt;!ELEMENT 书(书名、作者、售价)&gt; 表示书是一个标签，且书中有子标签&lt;书名&gt;、&lt;作者&gt;、&lt;售价&gt;</span><br><span class="line">&lt;!ELEMENT 书名(#PCDATA)&gt;	表示&lt;书名&gt;是一个标签，且&lt;书名&gt;里面是普通文本</span><br><span class="line">&lt;!ELEMENT 作者(#PCDATA)&gt;	表示&lt;作者&gt;是一个标签，且&lt;作者&gt;里面是普通文本</span><br><span class="line">&lt;!ELEMENT 售价(#PCDATA)&gt;	表示&lt;售价&gt;是一个标签，且&lt;售价&gt;里面是普通文本</span><br></pre></td></tr></table></figure>


</li>
<li><p>Schame约束案例</p>
<p>如下图所示，左边的book2.xml文件就受到右边schame文件（.xsd结尾的文件）的约束。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh105.png"></p>
</li>
</ul>
<h2 id="日志技术"><a href="#日志技术" class="headerlink" title="日志技术"></a>日志技术</h2><h3 id="日志概述"><a href="#日志概述" class="headerlink" title="日志概述"></a>日志概述</h3><p>好的同学们，接下来我们学习一个将来我们会用到的一个技术，叫做日志技术。首先同学们肯定想知道什么是日志？</p>
<p>想搞清楚什么是日志，其实可以通过下面几个问题来了解的。</p>
<ul>
<li>系统系统能记住某些数据被谁操作，比如被谁删除了？</li>
<li>想分析用户浏览系统的具体情况，比如挖掘用户的具体喜好？</li>
<li>当系统在开发中或者上线后出现了Bug，崩溃了，该通过什么去分析，定位Bug?</li>
</ul>
<p>而日志就可以帮我们解决以上的问题。所以日志就好比生活中的日记，日记可以记录生活中的点点滴滴；而程序中的日志，通常就是一个文件，里面记录了程序运行过程中产生的各种数据。</p>
<p>日志技术有如下好处</p>
<ol>
<li>日志可以将系统执行的信息，方便的记录到指定位置，可以是控制台、可以是文件、可以是数据库中。</li>
<li>日志可以随时以开关的形式控制启停，无需侵入到源代码中去修改。</li>
</ol>
<h3 id="日志的体系"><a href="#日志的体系" class="headerlink" title="日志的体系"></a>日志的体系</h3><p>在上一节给同学们介绍了，什么是日志，日志能干什么。接下来需要给同学们介绍一下有哪些日志技术，以及日志的体系。</p>
<p>大家注意了在行内，其实有很多日志框架给开发者使用。所谓日志框架就是由一些牛人或者第三方公司已经做好的实现代码，后来者就可以直接拿过去使用。</p>
<p>日志框架有很多种，比如有JUL（java.util.logging）、Log4j、logback等。但是这些日志框架如果使用的API方法都不一样的话，使用者的学习成本就很高。为了降低程序员的学习压力，行内提供了一套日志接口，然后所有的日志框架都按照日志接口的API来实现就可以了。</p>
<p>这样程序员只要会一套日志框架，那么其他的也就可以通过用，甚至可以在多套日志框架之间来回切换。比较常用的日志框架，和日志接口的关系如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh106.png"></p>
<p><strong>这里推荐同学们使用Logback日志框架，也在行业中最为广泛使用的。</strong></p>
<p><strong>Logback日志分为哪几个模块</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh107.png"></p>
<h3 id="Logback快速入门"><a href="#Logback快速入门" class="headerlink" title="Logback快速入门"></a>Logback快速入门</h3><p>接下来，就带领同学们快速使用一下Logback日志框架，使用Logback记录几条日志信息到文件中去和将日志信息打印在控制台上。</p>
<p>由于Logback是第三方提供的技术，所以首先需要啊将Jar包引入到项目中，具体步骤如下</p>
<ol>
<li><p>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code> 这三个jar包，复制一下</p>
</li>
<li><p>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</p>
</li>
<li><p>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</p>
</li>
<li><p>然后就可以开始写代码了，在代码中创建一个日志记录日对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;当前类名&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始记录日志，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBackTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Logger日志对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;LogBackTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//while (true) &#123;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法开始执行~~~&quot;</span>);</span><br><span class="line">                chu(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法执行成功~~~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;chu法方法执行失败了，出现了bug~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数a:&quot;</span> + a);</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数b:&quot;</span> + b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;结果是：&quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当我们运行程序时，就可以看到控制台记录的日志</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh108.png"></p>
<p>同时在文件中，也有一份这样的日志信息。文件在哪里内，从配置文件中去找</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh109.png"></p>
<p>打开<code>D:/log/itheima-data.log</code>看一下文件中是否有记录日志吧！！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh110.png"></p>
<p>关于Logback的快速入门我们就做完了。至于日志的配置文件中，其他的配置是什么含义我们下一节再继续学习。</p>
<h3 id="日志配置文件"><a href="#日志配置文件" class="headerlink" title="日志配置文件"></a>日志配置文件</h3><p>Logback提供了一个核心配置文件logback.xml，日志框架在记录日志时会读取配置文件中的配置信息，从而记录日志的形式。具体可以做哪些配置呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 可以配置日志输出的位置是文件、还是控制台</span><br><span class="line"><span class="number">2.</span> 可以配置日志输出的格式</span><br><span class="line"><span class="number">3.</span> 还可以配置日志关闭和开启、以及哪些日志输出哪些日志不输出。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如下图所示，控制日志往文件中输出，还是往控制台输出</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh111.png"></p>
<ul>
<li><strong>如下图所示，控制打开和关闭日志</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh112.png"></p>
<ul>
<li><p><strong>如下图所示，控制日志的输出的格式</strong></p>
<p>日志格式是由一些特殊的符号组成，可以根据需要删减不想看到的部分。比如不想看到线程名那就不要[%thread]。但是不建议同学们更改这些格式，因为这些都是日志很基本的信息。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh113.png"></p>
<h3 id="3-5-配置日志级别"><a href="#3-5-配置日志级别" class="headerlink" title="3.5 配置日志级别"></a>3.5 配置日志级别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh114.png"></p>
<ul>
<li>在哪里配置日志级别呢？如下图所示</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh115.png"></p>
<ul>
<li><p>Logback只输出大于或者等于核心配置文件配置的日志级别信息。小于配置级别的日志信息，不被记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置的是trace，则trace、debug、info、warn、error级别的日志都被输出</span><br><span class="line">配置的是debug, 则debug、info、warn、error级别的日志被输出</span><br><span class="line">配置的是info,则info、warn、error级别的日志被输出</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>同学们，接下来我们来学习一个全新而且非常重要的知识，叫做多线程。首先和同学们聊聊什么是线程？<strong>线程其实是程序中的一条执行路径。</strong></p>
<p> 我们之前写过的程序，其实都是单线程程序，如下图代码，如果前面的for循环没有执行完，for循环下面的代码是不会执行的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh116.png"></p>
<p><strong>怎样的程序才是多线程程序呢？</strong> 如下图所示，12306网站就是支持多线程的，因为同时可以有很多人一起进入网站购票，而且每一个人互不影响。再比如百度网盘，可以同时下载或者上传多个文件。这些程序中其实就有多条执行路径，每一条执行执行路径就是一条线程，所以这样的程序就是多线程程序。</p>
<p>认识了什么是多线程程序，那如何使用Java创建线程呢？ Java提供了几种创建线程的方式，下一节再一种一种的学习。</p>
<h3 id="线程创建方式1"><a href="#线程创建方式1" class="headerlink" title="线程创建方式1"></a>线程创建方式1</h3><p>Java为开发者提供了一个类叫做Thread，此类的对象用来表示线程。创建线程并执行线程的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义一个子类继承Thread类，并重写run方法</span><br><span class="line"><span class="number">2.</span>创建Thread的子类对象</span><br><span class="line"><span class="number">3.</span>调用start方法启动线程（启动线程后，会自动执行run方法中的代码）</span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写Thread类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个测试类，在测试类中创建MyThread线程对象，并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="comment">// main方法是由一条默认的主线程负责执行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建MyThread线程类的对象代表一个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 4、启动线程（自动执行run方法的）</span></span><br><span class="line">        t.start(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下图所示，我们会发现MyThread和main线程在相互抢夺CPU的执行权（<strong>注意：哪一个线程先执行，哪一个线程后执行，目前我们是无法控制的，每次输出结果都会不一样</strong>）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh117.png"></p>
<p><strong>最后我们还需要注意一点</strong>：不能直接去调用run方法，如果直接调用run方法就不认为是一条线程启动了，而是把Thread当做一个普通对象，此时run方法中的执行的代码会成为主线程的一部分。此时执行结果是这样的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh118.png"></p>
<h3 id="线程创建方式2"><a href="#线程创建方式2" class="headerlink" title="线程创建方式2"></a>线程创建方式2</h3><p>接下来我们学习线程的第二种创建方式。Java为开发者提供了一个Runnable接口，该接口中只有一个run方法，意思就是通过Runnable接口的实现类对象专门来表示线程要执行的任务。具体步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先写一个Runnable接口的实现类，重写run方法(这里面就是线程要执行的代码)</span><br><span class="line"><span class="number">2.</span>再创建一个Runnable实现类的对象</span><br><span class="line"><span class="number">3.</span>创建一个Thread对象，把Runnable实现类的对象传递给Thread</span><br><span class="line"><span class="number">4.</span>调用Thread对象的start()方法启动线程（启动后会自动执行Runnable里面的run方法）</span><br></pre></td></tr></table></figure>

<p>代码如下：先准备一个Runnable接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、定义一个任务类，实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 2、重写runnable的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程要执行的任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个测试类，在测试类中创建线程对象，并执行线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建任务对象。</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4、把任务对象交给一个线程对象处理。</span></span><br><span class="line">        <span class="comment">//  public Thread(Runnable target)</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面代码，结果如下图所示<strong>（注意：没有出现下面交替执行的效果，也是正常的）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主线程main输出 ===》<span class="number">1</span></span><br><span class="line">主线程main输出 ===》<span class="number">2</span></span><br><span class="line">主线程main输出 ===》<span class="number">3</span></span><br><span class="line">子线程输出 ===》<span class="number">1</span></span><br><span class="line">子线程输出 ===》<span class="number">2</span></span><br><span class="line">子线程输出 ===》<span class="number">3</span></span><br><span class="line">子线程输出 ===》<span class="number">4</span></span><br><span class="line">子线程输出 ===》<span class="number">5</span></span><br><span class="line">主线程main输出 ===》<span class="number">4</span></span><br><span class="line">主线程main输出 ===》<span class="number">5</span></span><br></pre></td></tr></table></figure>



<h3 id="线程创建方式2—匿名内部类"><a href="#线程创建方式2—匿名内部类" class="headerlink" title="线程创建方式2—匿名内部类"></a>线程创建方式2—匿名内部类</h3><p>同学们注意了，现在这种写法不是新知识。只是将前面第二种方式用匿名内部类改写一下。因为同学们在看别人写的代码时，有可能会看到这种写法。你知道是怎么回事就可以了。</p>
<p>刚刚我们学习的第二种线程的创建方式，需要写一个Runnable接口的实现类，然后再把Runnable实现类的对象传递给Thread对象。</p>
<p><strong>现在我不想写Runnable实现类，于是可以直接创建Runnable接口的匿名内部类对象，传递给Thread对象。</strong></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、直接创建Runnable接口的匿名内部类形式（任务对象）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程1输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式1：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程2输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式2：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程3输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程的创建方式3"><a href="#线程的创建方式3" class="headerlink" title="线程的创建方式3"></a>线程的创建方式3</h3><p>接下来，我们学习线程的第三种创建方式。已经有两种了为什么还有要第三种呢？ 这样，我们先分析一下前面两种都存在的一个问题。然后再引出第三种可以解决这个问题。</p>
<ul>
<li><p>假设线程执行完毕之后有一些数据需要返回，前面两种方式重写的run方法均没有返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    ...线程执行的代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK5提供了Callable接口和FutureTask类来创建线程，它最大的优点就是有返回值。</p>
<p>在Callable接口中有一个call方法，重写call方法就是线程要执行的代码，它是有返回值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">    ...线程执行的代码...</span><br><span class="line">    <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>第三种创建线程的方式，步骤如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先定义一个Callable接口的实现类，重写call方法</span><br><span class="line"><span class="number">2.</span>创建Callable实现类的对象</span><br><span class="line"><span class="number">3.</span>创建FutureTask类的对象，将Callable对象传递给FutureTask</span><br><span class="line"><span class="number">4.</span>创建Thread对象，将Future对象传递给Thread</span><br><span class="line"><span class="number">5.</span>调用Thread的start()方法启动线程(启动后会自动执行call方法)</span><br><span class="line">   等call()方法执行完之后，会自动将返回值结果封装到FutrueTask对象中</span><br><span class="line">   </span><br><span class="line"><span class="number">6.</span>调用FutrueTask对的get()方法获取返回结果</span><br></pre></td></tr></table></figure>

<p>代码如下：先准备一个Callable接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、让子类继承Thread线程类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写Thread类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个测试类，在测试类中创建线程并启动线程，还要获取返回结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3、创建一个Callable的对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 4、把Callable的对象封装成一个FutureTask对象（任务对象）</span></span><br><span class="line">        <span class="comment">// 未来任务对象的作用？</span></span><br><span class="line">        <span class="comment">// 1、是一个任务对象，实现了Runnable对象.</span></span><br><span class="line">        <span class="comment">// 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。</span></span><br><span class="line">        FutureTask&lt;String&gt; f1  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="comment">// 5、把任务对象交给一个Thread对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f1).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取线程执行完毕后返回的结果。</span></span><br><span class="line">        <span class="comment">// 注意：如果执行到这儿，假如上面的线程还没有执行完毕</span></span><br><span class="line">        <span class="comment">// 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> f1.get();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程常用方法"><a href="#多线程常用方法" class="headerlink" title="多线程常用方法"></a>多线程常用方法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh119.png"></p>
<p>下面我们演示一下<code>getName()</code>、<code>setName(String name)</code>、<code>currentThread()</code>、<code>sleep(long time)</code>这些方法的使用效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">//1.执行父类Thread(String name)构造器，为当前线程设置名字了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//2.currentThread() 哪个线程执行它，它就会得到哪个线程对象。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//3.getName() 获取线程名称</span></span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot;输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再测试类中，创建线程对象，并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(String name) <span class="comment">//设置线程名称;</span></span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(t1.getName());  <span class="comment">//Thread-0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号线程&quot;</span>);</span><br><span class="line">        <span class="comment">// t2.setName(&quot;2号线程&quot;);</span></span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(t2.getName()); <span class="comment">// Thread-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程对象的名字</span></span><br><span class="line">        <span class="comment">// 哪个线程执行它，它就会得到哪个线程对象。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        m.setName(<span class="string">&quot;最牛的线程&quot;</span>);</span><br><span class="line">        System.out.println(m.getName()); <span class="comment">// main</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(m.getName() + <span class="string">&quot;线程输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面代码，效果如下图所示，我们发现每一条线程都有自己了名字了。</p>
<p>1号线程<br>2号线程<br>最牛的线程<br>最牛的线程线程输出:1<br>最牛的线程线程输出:2<br>最牛的线程线程输出:3<br>最牛的线程线程输出:4<br>最牛的线程线程输出:5<br>2号线程输出:1<br>2号线程输出:2<br>2号线程输出:3<br>1号线程输出:1<br>1号线程输出:2<br>1号线程输出:3</p>
<p><strong>最后再演示一下join这个方法是什么效果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// join方法作用：让当前调用这个方法的线程先执行完。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;3号线程&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t3.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果是1号线程先执行完，再执行2号线程；2号线程执行完，再执行3号线程；3号线程执行完就结束了。</p>
<p>1号线程输出:1<br>1号线程输出:2<br>1号线程输出:3<br>2号线程输出:1<br>2号线程输出:2<br>2号线程输出:3<br>3号线程输出:1<br>3号线程输出:2<br>3号线程输出:3</p>
<p>我们再尝试，把join()方法去掉，再看执行效果。此时你会发现2号线程没有执行完1号线程就执行了<strong>（效果是多次运行才出现的，根据个人电脑而异，可能有同学半天也出现不了也是正常的）</strong></p>
<p>3号线程输出:1<br>3号线程输出:2<br>3号线程输出:3<br>2号线程输出:1        看，2号执行没有执行完，1号线程就开始执行了<br>1号线程输出:1<br>2号线程输出:2<br>1号线程输出:2<br>2号线程输出:3<br>1号线程输出:3</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>各位小伙伴，前面我们已经学习了如何创建线程，以及线程的常用方法。接下来，我们要学习一个在实际开发过程中，使用线程时最重要的一个问题，叫线程安全问题。</p>
<h3 id="线程安全问题概述"><a href="#线程安全问题概述" class="headerlink" title="线程安全问题概述"></a>线程安全问题概述</h3><ul>
<li><strong>首先，什么是线程安全问题呢？</strong></li>
</ul>
<p><strong>线程安全问题指的是，多个线程同时操作同一个共享资源的时候，可能会出现业务安全问题。</strong></p>
<p>下面通过一个取钱的案例给同学们演示一下。案例需求如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">场景：小明和小红是一对夫妻，他们有一个共享账户，余额是<span class="number">10</span>万元，小红和小明同时来取钱，并且<span class="number">2</span>人各自都在取钱<span class="number">10</span>万元，可能出现什么问题呢？</span><br></pre></td></tr></table></figure>

<p>如下图所示，小明和小红假设都是一个线程，本类每个线程都应该执行完三步操作，才算是完成的取钱的操作。但是真实执行过程可能是下面这样子的</p>
<p>​	① 小红线程只执行了判断余额是否足够（条件为true），然后CPU的执行权就被小红线程抢走了。</p>
<p>​	② 小红线程也执行了判断了余额是否足够（条件也是true）, 然后CPU执行权又被小明线程抢走了。</p>
<p>​	③ 小明线程由于刚才已经判断余额是否足够了，直接执行第2步，吐出了10万元钱，此时共享账户月为0。然后CPU执行权又被小红线程抢走。 </p>
<p>​	④ 小红线程由于刚刚也已经判断余额是否足够了，直接执行第2步，吐出了10万元钱，此时共享账户月为-10万。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh120.png"></p>
<p><strong>你会发现，在这个取钱案例中，两个人把共享账户的钱都取了10万，但问题是只有10万块钱啊！！！</strong></p>
<p>以上取钱案例中的问题，就是线程安全问题的一种体现。</p>
<h3 id="线程安全问题的代码演示"><a href="#线程安全问题的代码演示" class="headerlink" title="线程安全问题的代码演示"></a>线程安全问题的代码演示</h3><p>先定义一个共享的账户类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId; <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明 小红同时过来的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义一个是取钱的线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 取钱(小明，小红)</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，再写一个测试类，在测试类中创建两个线程对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// 1、创建一个账户对象，代表两个人的共享账户。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-110&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 2、创建两个线程，分别代表小明 小红，再去同一个账户对象中取钱10万。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start(); <span class="comment">// 小明</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start(); <span class="comment">// 小红</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，执行效果如下。你会发现两个人都取了10万块钱，余额为-10完了。</p>
<p>小红来取钱100000.0成功!<br>小明来取钱100000.0成功!<br>小红来取钱后，余额剩余:0.0<br>小明来取钱后，余额剩余:-100000.0</p>
<h3 id="线程同步方案"><a href="#线程同步方案" class="headerlink" title="线程同步方案"></a>线程同步方案</h3><p>为了解决前面的线程安全问题，我们可以使用线程同步思想。同步最常见的方案就是加锁，<strong>意思是每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动释放锁，然后其他线程才能再加锁进来。</strong></p>
<p>等小红线程执行完了，把余额改为0，出去了就会释放锁。这时小明线程就可以加锁进来执行，如下图所示。</p>
<p>采用加锁的方案，就可以解决前面两个线程都取10万块钱的问题。怎么加锁呢？Java提供了三种方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>同步代码块</span><br><span class="line"><span class="number">2.</span>同步方法</span><br><span class="line"><span class="number">3.</span>Lock锁</span><br></pre></td></tr></table></figure>



<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>我们先来学习同步代码块。它的作用就是把访问共享数据的代码锁起来，以此保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁对象：必须是一个唯一的对象（同一个地址）</span></span><br><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//...访问共享数据的代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用同步代码块，来解决前面代码里面的线程安全问题。我们只需要修改DrawThread类中的代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明 小红线程同时过来的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="comment">// this正好代表共享资源！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再运行测试类，观察是否会出现不合理的情况。</p>
<p><strong>最后，再给同学们说一下锁对象如何选择的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象</span><br><span class="line"><span class="number">2.</span>对于实例方法，建议使用<span class="built_in">this</span>作为锁对象</span><br><span class="line"><span class="number">3.</span>对于静态方法，建议把类的字节码(类名.class)当做锁对象</span><br></pre></td></tr></table></figure>



<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>接下来，学习同步方法解决线程安全问题。<strong>其实同步方法，就是把整个方法给锁住，一个线程调用这个方法，另一个线程调用的时候就执行不了，只有等上一个线程调用结束，下一个线程调用才能继续执行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.money -= money;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完之后，再次运行测试类，观察是否会出现不合理的情况。</p>
<p><strong>接着，再问同学们一个问题，同步方法有没有锁对象？锁对象是谁？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步方法也是有锁对象，只不过这个锁对象没有显示的写出来而已。</span><br><span class="line">	<span class="number">1.</span>对于实例方法，锁对象其实是<span class="built_in">this</span>（也就是方法的调用者）</span><br><span class="line">	<span class="number">2.</span>对于静态方法，锁对象时类的字节码对象（类名.class）</span><br></pre></td></tr></table></figure>

<p><strong>最终，总结一下同步代码块和同步方法有什么区别？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不存在哪个好与不好，只是一个锁住的范围大，一个范围小</span><br><span class="line"><span class="number">2.</span>同步方法是将方法中所有的代码锁住</span><br><span class="line"><span class="number">3.</span>同步代码块是将方法中的部分代码锁住</span><br></pre></td></tr></table></figure>



<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>接下来，我们再来学习一种，线程安全问题的解决办法，叫做Lock锁。</p>
<p>Lock锁是JDK5版本专门提供的一种锁对象，通过这个锁对象的方法来达到加锁，和释放锁的目的，使用起来更加灵活。格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>首先在成员变量位子，需要创建一个Lock接口的实现类对象（这个对象就是锁对象）</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="number">2.</span>在需要上锁的地方加入下面的代码</span><br><span class="line">	 lk.lock(); <span class="comment">// 加锁</span></span><br><span class="line">	 <span class="comment">//...中间是被锁住的代码...</span></span><br><span class="line">	 lk.unlock(); <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p>使用Lock锁改写前面DrawThread中取钱的方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lk.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lk.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序结果，观察是否有线程安全问题。到此三种解决线程安全问题的办法我们就学习完了。</p>
<h2 id="线程通信（了解）"><a href="#线程通信（了解）" class="headerlink" title="线程通信（了解）"></a>线程通信（了解）</h2><p>接下来，我们学习一下线程通信。</p>
<p><strong>首先，什么是线程通信呢？</strong></p>
<ul>
<li>当多个线程共同操作共享资源时，线程间通过某种方式互相告知自己的状态，以相互协调，避免无效的资源挣抢。</li>
</ul>
<p><strong>线程通信的常见模式：是生产者与消费者模型</strong></p>
<ul>
<li>生产者线程负责生成数据</li>
<li>消费者线程负责消费生产者生成的数据</li>
<li>注意：生产者生产完数据后应该让自己等待，通知其他消费者消费；消费者消费完数据之后应该让自己等待，同时通知生产者生成。</li>
</ul>
<p>比如下面案例中，有3个厨师（生产者线程），两个顾客（消费者线程）。</p>
<p>接下来，我们先分析一下完成这个案例的思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先确定在这个案例中，什么是共享数据？</span><br><span class="line">	答：这里案例中桌子是共享数据，因为厨师和顾客都需要对桌子上的包子进行操作。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>再确定有那几条线程？哪个是生产者，哪个是消费者？</span><br><span class="line">	答：厨师是生产者线程，<span class="number">3</span>条生产者线程； </span><br><span class="line">	   顾客是消费者线程，<span class="number">2</span>条消费者线程</span><br><span class="line">	   </span><br><span class="line"><span class="number">3.</span>什么时候将哪一个线程设置为什么状态</span><br><span class="line">	生产者线程(厨师)放包子：</span><br><span class="line">		 <span class="number">1</span>)先判断是否有包子</span><br><span class="line">		 <span class="number">2</span>)没有包子时，厨师开始做包子, 做完之后把别人唤醒，然后让自己等待</span><br><span class="line">		 <span class="number">3</span>)有包子时，不做包子了，直接唤醒别人、然后让自己等待</span><br><span class="line">		 	</span><br><span class="line">	消费者线程(顾客)吃包子：</span><br><span class="line">		 <span class="number">1</span>)先判断是否有包子</span><br><span class="line">		 <span class="number">2</span>)有包子时，顾客开始吃包子, 吃完之后把别人唤醒，然后让自己等待</span><br><span class="line">		 <span class="number">3</span>)没有包子时，不吃包子了，直接唤醒别人、然后让自己等待</span><br></pre></td></tr></table></figure>

<p>按照上面分析的思路写代码。先写桌子类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放1个包子的方法</span></span><br><span class="line">    <span class="comment">// 厨师1 厨师2 厨师3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">// 判断是否有包子。</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(name + <span class="string">&quot;做的肉包子&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;做了一个肉包子~~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有包子了，不做了。</span></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 吃货1 吃货2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 有包子，吃了</span></span><br><span class="line">                System.out.println(name  + <span class="string">&quot;吃了：&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line">                list.clear();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有包子</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写测试类，在测试类中，创建3个厨师线程对象，再创建2个顾客对象，并启动所有线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//   需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上</span></span><br><span class="line">        <span class="comment">//      2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。</span></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建3个生产者线程（3个厨师）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建2个消费者线程（2个吃货）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面代码，运行结果如下：你会发现多个线程相互协调执行，避免无效的资源挣抢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">厨师1做了一个肉包子~~</span><br><span class="line">吃货2吃了：厨师1做的肉包子</span><br><span class="line">厨师3做了一个肉包子~~</span><br><span class="line">吃货2吃了：厨师3做的肉包子</span><br><span class="line">厨师1做了一个肉包子~~</span><br><span class="line">吃货1吃了：厨师1做的肉包子</span><br><span class="line">厨师2做了一个肉包子~~</span><br><span class="line">吃货2吃了：厨师2做的肉包子</span><br><span class="line">厨师3做了一个肉包子~~</span><br><span class="line">吃货1吃了：厨师3做的肉包子</span><br></pre></td></tr></table></figure>



<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池概述"><a href="#线程池概述" class="headerlink" title="线程池概述"></a>线程池概述</h3><p>各位小伙伴，接下来我们学习一下线程池技术。先认识一下什么是线程池技术？ 其实，<strong>线程池就是一个可以复用线程的技术</strong>。</p>
<p>要理解什么是线程复用技术，我们先得看一下不使用线程池会有什么问题，理解了这些问题之后，我们在解释线程复用同学们就好理解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设：用户每次发起一个请求给后台，后台就创建一个新的线程来处理，下次新的任务过来肯定也会创建新的线程，如果用户量非常大，创建的线程也讲越来越多。然而，创建线程是开销很大的，并且请求过多时，会严重影响系统性能。</span><br></pre></td></tr></table></figure>

<p>而使用线程池，就可以解决上面的问题。如下图所示，线程池内部会有一个容器，存储几个核心线程，假设有3个核心线程，这3个核心线程可以处理3个任务。</p>
<p>但是任务总有被执行完的时候，假设第1个线程的任务执行完了，那么第1个线程就空闲下来了，有新的任务时，空闲下来的第1个线程可以去执行其他任务。依此内推，这3个线程可以不断的复用，也可以执行很多个任务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh121.png"></p>
<p><strong>所以，线程池就是一个线程复用技术，它可以提高线程的利用率。</strong></p>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>在JDK5版本中提供了代表线程池的接口ExecutorService，而这个接口下有一个实现类叫ThreadPoolExecutor类，使用ThreadPoolExecutor类就可以用来创建线程池对象。</p>
<p>下面是它的构造器，参数比较多，不要怕，干就完了^_^。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh122.png"></p>
<p>接下来，用这7个参数的构造器来创建线程池的对象。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>关于线程池，我们需要注意下面的两个问题</p>
<ul>
<li><p>临时线程什么时候创建？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么时候开始拒绝新的任务？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程池执行Runnable任务"><a href="#线程池执行Runnable任务" class="headerlink" title="线程池执行Runnable任务"></a>线程池执行Runnable任务</h3><p>创建好线程池之后，接下来我们就可以使用线程池执行任务了。线程池执行的任务可以有两种，一种是Runnable任务；一种是callable任务。下面的execute方法可以用来执行Runnable任务。</p>
<p>方法名称              说明<br>void execute(Runnable command)<br>执行 Runnable任务<br>Future<T> submit(Callable<T> task)<br>执行callable任务，返回未来任务对象，用于获取线程返回的结果<br>void shutdown()<br>等全部任务执行完毕后，再关闭线程池!<br>List<Runnable> shutdownNow()<br>立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务</p>
<p>先准备一个线程任务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 任务是干啥的？</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ==&gt; 输出666~~&quot;</span>);</span><br><span class="line">        <span class="comment">//为了模拟线程一直在执行，这里睡久一点</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line"><span class="comment">//下面4个任务在任务队列里排队</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面2个任务，会被临时线程的创建时机了</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"><span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">pool.execute(target);</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，结果输出如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh123.png"></p>
<h3 id="线程池执行Callable任务"><a href="#线程池执行Callable任务" class="headerlink" title="线程池执行Callable任务"></a>线程池执行Callable任务</h3><p>接下来，我们学习使用线程池执行Callable任务。callable任务相对于Runnable任务来说，就是多了一个返回值。</p>
<p>执行Callable任务需要用到下面的submit方法</p>
<p>方法名称                  说明<br>void execute(Runnable command)<br>执行任务&#x2F;命令，没有返回值，一般用来执行Runnable任务<br>Future<T> submit(Callable<T> task)<br>执行任务，返回未来任务对象获取线程结果，一般拿来执行callable任务<br>void shutdown<br>等任务执行完毕后关闭线程池<br>List<Runnable> shutdownNow()<br>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</p>
<p>先准备一个Callable线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 描述线程的任务，返回线程执行返回后的结果。</span></span><br><span class="line">        <span class="comment">// 需求：求1-n的和返回。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;求出了1-&quot;</span> + n + <span class="string">&quot;的和是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再准备一个测试类，在测试类中创建线程池，并执行callable任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">8</span>,</span><br><span class="line">            TimeUnit.SECONDS, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、执行完Callable任务后，需要获取返回结果。</span></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后，结果如下图所示</p>
<p>pool-1-thread-1求出了1-100的和是:5050<br>pool-1-thread-2求出了1-200的和是:20100<br>pool-1-thread-3求出了1-300的和是:45150<br>pool-1-thread-2求出了1-400的和是:80200</p>
<h3 id="线程池工具类（Executors）"><a href="#线程池工具类（Executors）" class="headerlink" title="线程池工具类（Executors）"></a>线程池工具类（Executors）</h3><p>有同学可能会觉得前面创建线程池的代码参数太多、记不住，有没有快捷的创建线程池的方法呢？有的。Java为开发者提供了一个创建线程池的工具类，叫做Executors，它提供了方法可以创建各种不能特点的线程池。如下图所示</p>
<p>方法名称                         说明<br>public static ExecutorService newFixedThreadPool(int nThreads)<br>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</p>
<p>public static ExecutorService newsingleThreadExecutor()<br>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</p>
<p>public static Executorservice newCachedThreadPool()<br>线程数量随着任务增加而增加，如果线利任务执行完毕且空闲了60s则会被回收掉。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolsize)<br>创建—个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</p>
<p>接下来，我们演示一下创建固定线程数量的线程池。这几个方法用得不多，所以这里不做过多演示，同学们了解一下就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过Executors创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">17</span>);</span><br><span class="line">        <span class="comment">// 老师：核心线程数量到底配置多少呢？？？</span></span><br><span class="line">        <span class="comment">// 计算密集型的任务：核心线程数量 = CPU的核数 + 1</span></span><br><span class="line">        <span class="comment">// IO密集型的任务：核心线程数量 = CPU核数 * 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executors创建线程池这么好用，为什么不推荐同学们使用呢？原因在这里：看下图，这是《阿里巴巴Java开发手册》提供的强制规范要求。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh124.png"></p>
<h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>最后，我们再补充几个概念性的知识点，同学们知道这些概念什么意思就可以了。</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>先学习第一个补充知识点，并发和并行。在讲解并发和并行的含义之前，我们先来了解一下什么是进程、线程？</p>
<ul>
<li>正常运行的程序（软件）就是一个独立的进程</li>
<li>线程是属于进程，一个进程中包含多个线程</li>
<li>进程中的线程其实并发和并行同时存在（继续往下看）</li>
</ul>
<p>我们可以打开系统的任务管理器看看（快捷键：Ctrl+Shfit+Esc），自己的电脑上目前有哪些进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh125.png"></p>
<p>知道了什么是进程和线程之后，接着我们再来学习并发和并行的含义。</p>
<p><strong>首先，来学习一下什么是并发？</strong></p>
<p>进程中的线程由CPU负责调度执行，但是CPU同时处理线程的数量是优先的，为了保证全部线程都能执行到，CPU采用轮询机制为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。（简单记：并发就是多条线程交替执行）</p>
<p><strong>接下，再来学习一下什么是并行？</strong></p>
<p>并行指的是，多个线程同时被CPU调度执行。如下图所示，多个CPU核心在执行多条线程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh126.png"></p>
<p><strong>最后一个问题，多线程到底是并发还是并行呢？</strong></p>
<p>其实多个线程在我们的电脑上执行，并发和并行是同时存在的。</p>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>接下来，我们学习最后一个有关线程的知识点，叫做线程的生命周期。所谓生命周期就是线程从生到死的过程中间有哪些状态，以及这些状态之间是怎么切换的。</p>
<p>为了让大家同好的理解线程的生命周期，先用人的生命周期举个例子，人从生到死有下面的几个过程。在人的生命周期过程中，各种状态之间可能会有切换，线程也是一样的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh127.png"></p>
<p>接下来就来学习线程的生命周期。在Thread类中有一个嵌套的枚举类叫Thread.Status，这里面定义了线程的6中状态。如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh128.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW: 新建状态，线程还没有启动</span><br><span class="line">RUNNABLE: 可以运行状态，线程调用了start()方法后处于这个状态</span><br><span class="line">BLOCKED: 锁阻塞状态，没有获取到锁处于这个状态</span><br><span class="line">WAITING: 无限等待状态，线程执行时被调用了wait方法处于这个状态</span><br><span class="line">TIMED_WAITING: 计时等待状态，线程执行时被调用了sleep(毫秒)或者wait(毫秒)方法处于这个状态</span><br><span class="line">TERMINATED: 终止状态, 线程执行完毕或者遇到异常时，处于这个状态。</span><br></pre></td></tr></table></figure>

<p>这几种状态之间切换关系如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh129.png"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h2><p>同学们，今天我们学习的课程内容叫网络编程。意思就是编写的应用程序可以与网络上其他设备中的应用程序进行数据交互。</p>
<p>网络编程有什么用呢？这个就不言而喻了，比如我们经常用的微信收发消息就需要用到网络通信的技术、在比如我们打开浏览器可以浏览各种网络、视频等也需要用到网络编程的技术。</p>
<p>我们知道什么是网络编程、也知道网络编程能干什么后了，那Java给我们提供了哪些网络编程的解决方案呢？</p>
<p>Java提供的网络编程的解决方案都是在java.net包下。在正式学习Java网络编程技术之前，我们还需要学习一些网络通信的前置知识理论知识，只有这些前置知识做基础，我们学习网络编程代码编写才起来才能继续下去。</p>
<p>首先和同学们聊聊网络通信的基本架构。通信的基本架构主要有两种形式：一种是CS架构（Client 客户端&#x2F;Server服务端）、一种是BS架构（Brower 浏览器&#x2F;Server服务端）。</p>
<ul>
<li><strong>CS架构的特点：</strong>CS架构需要用户在自己的电脑或者手机上安装客户端软件，然后由客户端软件通过网络连接服务器程序，由服务器把数据发给客户端，客户端就可以在页面上看到各种数据了。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh130.png"></p>
<ul>
<li><p><strong>BS架构的特点：</strong>BS架构不需要开发客户端软件，用户只需要通过浏览器输入网址就可以直接从服务器获取数据，并由服务器将数据返回给浏览器，用户在页面上就可以看到各种数据了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh131.png"></p>
</li>
</ul>
<p>这两种结构不管是CS、还是BS都是需要用到网络编程的相关技术。我们学习Java的程序员，以后从事的工作方向主要还是BS架构的。</p>
<h2 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h2><p>各位小伙伴，我们前面已经知道什么是网络编程了。接下来我们还需要学习一些网络编程的基本概念，才能去编写网络编程的应用程序。</p>
<p>有哪三要素呢？分别是IP地址、端口号、通信协议</p>
<ol>
<li><p>IP地址：表示设备在网络中的地址，是网络中设备的唯一标识</p>
</li>
<li><p>端口号：应用程序在设备中唯一的标识</p>
</li>
<li><p>协议：连接和数据在网络中传输的规则。</p>
</li>
</ol>
<p>如下图所示：假设现在要从一台电脑中的微信上，发一句“你愁啥？”到其他电脑的微信上，流程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先通过ip地址找到对方的电脑</span><br><span class="line"><span class="number">2.</span>再通过端口号找到对方的电脑上的应用程序</span><br><span class="line"><span class="number">3.</span>按照双方约定好的规则发送、接收数据</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh132.png"></p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>接下来，我们详细介绍一下IP地址。<strong>IP（Ineternet Protocol）全称互联网协议地址，是分配给网络设备的唯一表示。</strong>IP地址分为：IPV4地址、IPV6地址</p>
<p>IPV4地址由32个比特位（4个字节）组成，如果下图所示，但是由于采用二进制太不容易阅读了，于是就将每8位看成一组，把每一组用十进制表示（叫做点分十进制表示法）。所以就有了我们经常看到的IP地址形式，如：192.168.1.66</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh133.png"></p>
<p>如果想查看本机的IP地址，可以在命令行窗口，输入<code>ipconfig</code>命令查看，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh134.png"></p>
<p>经过不断的发展，现在越来越多的设备需要联网，IPV4地址已经不够用了，所以扩展出来了IPV6地址。</p>
<p>IPV6采用128位二进制数据来表示（16个字节），号称可以为地球上的每一粒沙子编一个IP地址，</p>
<p>IPV6比较长，为了方便阅读，每16位编成一组，每组采用十六进制数据表示，然后用冒号隔开（称为冒分十六进制表示法），如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh135.png"></p>
<p>我们在命令行窗口输入<code>ipconfig</code>命令，同样可以看到ipv6地址，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh136.png"></p>
<p>现在的网络设备，一般IPV4和IPV6地址都是支持的。</p>
<hr>
<p>聊完什么是IP地址和IP地址分类之后，接下来再给大家介绍一下和IP地址相关的一个东西，叫做域名。</p>
<p>我们在浏览器上访问某一个网站是，就需要在浏览器的地址栏输入网址，这个网址的专业说法叫做域名。比如：传智播客的域名是<code>http://www.itcast.cn</code>。</p>
<p>域名和IP其实是一一对应的，由运营商来管理域名和IP的对应关系。我们在浏览器上敲一个域名时，首先由运营商的域名解析服务，把域名转换为ip地址，再通过IP地址去访问对应的服务器设备。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh137.png"></p>
<p>关于IP地址，还有一个特殊的地址需要我们记住一下。就是我们在学习阶段进行测试时，经常会自己给自己消息，需要用到一个本地回送地址：<code>127.0.0.1</code></p>
<p>最后给同学们介绍，两个和IP地址相关的命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig: 查看本机的ip地址</span><br><span class="line">pring 域名/ip  检测当前电脑与指定的ip是否连通</span><br></pre></td></tr></table></figure>

<p>ping命令出现以下的提示，说明网络是通过的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh138.png"></p>
<h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><p>各位小伙伴，在上一节课我们学习了网络编程的三要素之一，IP地址。按照面向对象的设计思想，Java中也有一个类用来表IP地址，这个类是InetAddress类。我们在开发网络通信程序的时候，可能有时候会获取本机的IP地址，以及测试与其他地址是否连通，这个时候就可以使用InetAddress类来完成。下面学习几个InetAddress的方法。</p>
<p>名称                      说明<br>public static InetAddress getLocalHost()<br>获取本机IP，会以一个inetAddress的对象返回<br>public static InetAddress getByName(String host)<br>根据ip地址或者域名，返回一个inetAdress对象<br>public string getHostName()<br>获取该ip地址对象对应的主机名。<br>public string getHostAddress()<br>获取该ip地址对象中的ip地址信息。<br>public boolean isReachable(int timeout)<br>在指定毫秒内，判断主机与该ip对应的主机是否能连通</p>
<p>演示上面几个方法的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取本机IP地址对象的</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip1</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip1.getHostName());</span><br><span class="line">        System.out.println(ip1.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取指定IP或者域名的IP地址对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());</span><br><span class="line">        System.out.println(ip2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ping www.baidu.com</span></span><br><span class="line">        System.out.println(ip2.isReachable(<span class="number">6000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口号：指的是计算机设备上运行的应用程序的标识，被规定为一个16位的二进制数据，范围（0~65535）</p>
<p>端口号分为一下几类（了解一下）</p>
<ul>
<li>周知端口：0~1023，被预先定义的知名应用程序占用（如：HTTP占用80，FTP占用21）</li>
<li>注册端口：1024~49151，分配给用户经常或者某些应用程序</li>
<li>动态端口：49152~65536，之所以称为动态端口，是因为它一般不固定分配给某进程，而是动态分配的。</li>
</ul>
<p>需要我们注意的是，同一个计算机设备中，不能出现两个应用程序，用同一个端口号</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>各位同学，前面我们已经学习了IP地址和端口号，但是想要完成数据通信还需要有通信协议。</p>
<p><strong>网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议。</strong></p>
<p>为了让世界上各种上网设备能够互联互通，肯定需要有一个组织出来，指定一个规则，大家都遵守这个规则，才能进行数据通信。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh139.png"></p>
<p>只要按照OSI网络参考模型制造的设备，就可以在国际互联网上互联互通。其中传输层有两个协议，是我们今天会接触到的（UDP协议、TCP协议）</p>
<ul>
<li><strong>UDP协议特点</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh140.png"></p>
<ul>
<li><p><strong>TPC协议特点</strong></p>
</li>
<li><p>特点:面向连接、可靠通信。</p>
</li>
<li><p>TCP的最终目的:要保证在不可靠的信道上实现可靠的传输。</p>
</li>
<li><p>TCP主要有三个步骤实现可靠传输:三次握手建立连接，传输数据进行确认，四次挥手断开连接。</p>
</li>
</ul>
<p>三次握手如下图所示<strong>：目的是确认通信双方，手法消息都是正常没问题的</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh141.png"></p>
<p>四次挥手如下图所示：<strong>目的是确保双方数据的收发已经完成，没有数据丢失</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh142.png"></p>
<h2 id="UDP通信代码（入门案例）"><a href="#UDP通信代码（入门案例）" class="headerlink" title="UDP通信代码（入门案例）"></a>UDP通信代码（入门案例）</h2><p>有了网络编程的三要素基础知识之后，我们就可以开始学习编写网络通信的程序了。首先学习基于UDP协议通信的代码编写。</p>
<p>UDP是面向无连接的、不需要确认双方是否存在，所以它是不可靠的协议。Java提供了一个类叫DatagramSocket来完成基于UDP协议的收发数据。使用DatagramSocket收发数据时，数据要以数据包的形式体现，一个数据包限制在64KB以内</p>
<p>具体流程如下图所示：假设我们把DatagramSocket看做是街道两天的人，现在左边的人要扔一盘韭菜到右边，这里的韭菜就是数据，但是数据需要用一个盘子装起来，这里的盘子就是DatagramPacket数据包的意思。通信双方都需要有DatagramSocket(扔、接韭菜人)，还需要有DatagramPacket(装韭菜的盘子)</p>
<p>下面我们看一个案例，需要有两个程序，一个表示客户端程序，一个表示服务端程序。</p>
<p>需求：客户端程序发一个字符串数据给服务端，服务端程序接收数据并打印。</p>
<h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建客户端对象（发韭菜出去的人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子）</span></span><br><span class="line">       <span class="comment">/* public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">             InetAddress address, int port)</span></span><br><span class="line"><span class="comment">               参数一：封装要发出去的数据。</span></span><br><span class="line"><span class="comment">               参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">               参数三：服务端的IP地址（找到服务端主机）</span></span><br><span class="line"><span class="comment">               参数四：服务端程序的端口。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我是快乐的客户端，我爱你abc&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length</span><br><span class="line">                , InetAddress.getLocalHost(),  <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式发送这个数据包的数据出去了</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端数据发送完毕~~~&quot;</span>);</span><br><span class="line">        socket.close(); <span class="comment">// 释放资源！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">// 64KB.</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">        <span class="comment">// 接收多少就倒出多少</span></span><br><span class="line">        <span class="comment">// 获取本次数据包接收了多少数据。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(packet.getPort());</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="UDP通信代码（多发多收）"><a href="#UDP通信代码（多发多收）" class="headerlink" title="UDP通信代码（多发多收）"></a>UDP通信代码（多发多收）</h2><p>刚才的案例，我们只能客户端发一次，服务端接收一次就结束了。下面我们想把这个代码改进一下，</p>
<p>需求：实现客户端不断的发数据，而服务端能不断的接收数据，客户端发送exit时客户端程序退出。</p>
<h3 id="客户端程序-1"><a href="#客户端程序-1" class="headerlink" title="客户端程序"></a>客户端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门：实现客户端反复的发。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建客户端对象（发韭菜出去的人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子）</span></span><br><span class="line">       <span class="comment">/* public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">             InetAddress address, int port)</span></span><br><span class="line"><span class="comment">               参数一：封装要发出去的数据。</span></span><br><span class="line"><span class="comment">               参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">               参数三：服务端的IP地址（找到服务端主机）</span></span><br><span class="line"><span class="comment">               参数四：服务端程序的端口。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一旦发现用户输入的exit命令，就退出客户端</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎下次光临！退出成功！&quot;</span>);</span><br><span class="line">                socket.close(); <span class="comment">// 释放资源</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出死循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length</span><br><span class="line">                    , InetAddress.getLocalHost(),  <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、开始正式发送这个数据包的数据出去了</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务端程序-1"><a href="#服务端程序-1" class="headerlink" title="服务端程序"></a>服务端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：完成UDP通信快速入门-服务端反复的收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">// 64KB.</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、开始正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">            <span class="comment">// 接收多少就倒出多少</span></span><br><span class="line">            <span class="comment">// 获取本次数据包接收了多少数据。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.println(rs);</span><br><span class="line"></span><br><span class="line">            System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">            System.out.println(packet.getPort());</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP通信（一发一收）"><a href="#TCP通信（一发一收）" class="headerlink" title="TCP通信（一发一收）"></a>TCP通信（一发一收）</h2><p>学习完UDP通信的代码编写之后，接下来我们学习TCP通信的代码如何编写。Java提供了一个java.net.Socket类来完成TCP通信。</p>
<p>我们先讲一下Socket完成TCP通信的流程，再讲代码怎么编写就很好理解了。如下图所示</p>
<ol>
<li>当创建Socket对象时，就会在客户端和服务端创建一个数据通信的管道，在客户端和服务端两边都会有一个Socket对象来访问这个通信管道。</li>
<li>现在假设客户端要发送一个“在一起”给服务端，客户端这边先需要通过Socket对象获取到一个字节输出流，通过字节输出流写数据到服务端</li>
<li>然后服务端这边通过Socket对象可以获取字节输入流，通过字节输入流就可以读取客户端写过来的数据，并对数据进行处理。</li>
<li>服务端处理完数据之后，假设需要把“没感觉”发给客户端端，那么服务端这边再通过Socket获取到一个字节输出流，将数据写给客户端</li>
<li>客户端这边再获取输入流，通过字节输入流来读取服务端写过来的数据。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh143.png"></p>
<h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><p>下面我们写一个客户端，用来往服务端发数据。由于原始的字节流不是很好用，这里根据我的经验，我原始的OutputStream包装为DataOutputStream是比较好用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-客户端开发：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Socket对象，并同时请求与服务端程序的连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、开始写数据出去了</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;在一起，好吗？&quot;</span>);</span><br><span class="line">        dos.close();</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放连接资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h3><p>上面我们只是写了TCP客户端，还没有服务端，接下来我们把服务端写一下。这里的服务端用来接收客户端发过来的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、使用数据输入流读取客户端发送过来的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        <span class="comment">// 其实我们也可以获取客户端的IP地址</span></span><br><span class="line">        System.out.println(socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">        dis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP通信（多发多收）"><a href="#TCP通信（多发多收）" class="headerlink" title="TCP通信（多发多收）"></a>TCP通信（多发多收）</h2><p>到目前为止，我们已经完成了客户端发送消息、服务端接收消息，但是客户端只能发一次，服务端只能接收一次。现在我想要客户端能过一直发消息，服务端能够一直接收消息。</p>
<p>下面我们把客户端代码改写一下，采用键盘录入的方式发消息，为了让客户端能够一直发，我们只需要将发送消息的代码套一层循环就可以了，当用户输入exit时，客户端退出循环并结束客户端。</p>
<h3 id="6-1-TCP客户端"><a href="#6-1-TCP客户端" class="headerlink" title="6.1 TCP客户端"></a>6.1 TCP客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-客户端开发：实现客户端可以反复的发消息出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Socket对象，并同时请求与服务端程序的连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一旦用户输入了exit，就退出客户端程序</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;欢迎您下次光临！退出成功！&quot;</span>);</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、开始写数据出去了</span></span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TCP服务端-1"><a href="#TCP服务端-1" class="headerlink" title="TCP服务端"></a>TCP服务端</h3><p>为了让服务端能够一直接收客户端发过来的消息，服务端代码也得改写一下。我们只需要将读取数据的代码加一个循环就可以了。</p>
<p>但是需要我们注意的时，如果客户端Socket退出之后，就表示连接客户端与服务端的数据通道被关闭了，这时服务端就会出现异常。服务端可以通过出异常来判断客户端下线了，所以可以用try…catch把读取客户端数据的代码套一起来，catch捕获到异常后，打印客户端下线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：实现服务端反复发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 5、使用数据输入流读取客户端发送过来的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(rs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;离线了！&quot;</span>);</span><br><span class="line">                dis.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP通信（多线程改进）"><a href="#TCP通信（多线程改进）" class="headerlink" title="TCP通信（多线程改进）"></a>TCP通信（多线程改进）</h2><p>上一个案例中我们写的服务端程序只能和一个客户端通信，如果有多个客户端连接服务端，此时服务端是不支持的。</p>
<p>为了让服务端能够支持多个客户端通信，就需要用到多线程技术。具体的实现思路如下图所示：每当有一个客户端连接服务端，在服务端这边就为Socket开启一条线程取执行读取数据的操作，来多少个客户端，就有多少条线程。按照这样的设计，服务端就可以支持多个客户端连接了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh144.png"></p>
<p>按照上面的思路，改写服务端代码。</p>
<h3 id="多线程改进"><a href="#多线程改进" class="headerlink" title="多线程改进"></a>多线程改进</h3><p>首先，我们需要写一个服务端的读取数据的线程类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，再改写服务端的主程序代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="案例拓展（群聊）"><a href="#案例拓展（群聊）" class="headerlink" title="案例拓展（群聊）"></a>案例拓展（群聊）</h3><p>接着前面的案例，下面我们案例再次拓展一下，这个并不需要同学们必须掌握，主要是为了锻炼同学们的编程能力、和编程思维。</p>
<p>我们想把刚才的案例，改进成全能够实现群聊的效果，就是一个客户端发的消息，其他的每一个客户端都可以收到。</p>
<p>刚才我们写的多个客户端可以往服务端发现消息，但是客户端和客户端是不能直接通信的。想要试下全群聊的效果，我们还是必须要有服务端在中间做中转。 具体实现方案如下图所示：</p>
<p>我们可以在服务端创建一个存储Socket的集合，每当一个客户端连接服务端，就可以把客户端Socket存储起来；当一个客户端给服务端发消息时，再遍历集合通过每个Socket将消息再转发给其他客户端。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh145.png"></p>
<p>下面我们改造服务端代码，由于服务端读取数据是在线程类中完成的，所以我们改<code>SerReaderThread</code>类就可以了。服务端的主程序不用改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">// 把这个消息分发给全部客户端进行接收。</span></span><br><span class="line">                    sendMsgToAll(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                    Server.onLineSockets.remove(socket);</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgToAll</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 发送给全部在线的socket管道接收。</span></span><br><span class="line">        <span class="keyword">for</span> (Socket onLineSocket : Server.onLineSockets) &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> onLineSocket.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BS架构程序（简易版）"><a href="#BS架构程序（简易版）" class="headerlink" title="BS架构程序（简易版）"></a>BS架构程序（简易版）</h2><p>前面我们所写的代码都是基于CS架构的。我们说网络编程还可以编写BS架构的程序，为了让同学们体验一下BS架构通信，这里我们写一个简易版的程序。仅仅只是体验下一，后期我们会详细学习BS架构的程序如何编写。</p>
<p>BS架构程序的实现原理，如下图所示：不需要开发客户端程序，此时浏览器就相当于是客户端，此时我们只需要写服务端程序就可以了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh146.png"></p>
<p>在BS结构的程序中，浏览器和服务器通信是基于HTTP协议来完成的，浏览器给客户端发送数据需要按照HTTP协议规定好的数据格式发给服务端，服务端返回数据时也需要按照HTTP协议规定好的数据给是发给浏览器，只有这两双方才能完成一次数据交互。</p>
<p>客户端程序不需要我们编写（浏览器就是），所以我们只需要写服务端就可以了。</p>
<p>服务端给客户端响应数据的数据格式（HTTP协议规定数据格式）如下图所示：左图是数据格式，右图是示例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh147.png"></p>
<p>接下来，我们写一个服务端程序按照右图示例的样子，给浏览器返回数据。<strong>注意：数据是由多行组成的，必须按照规定的格式来写。</strong></p>
<h3 id="服务端程序-2"><a href="#服务端程序-2" class="headerlink" title="服务端程序"></a>服务端程序</h3><p>先写一个线程类，用于按照HTTP协议的格式返回数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//  立即响应一个网页内容：“黑马程序员”给浏览器展示。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">// 必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写服务端的主程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务端主程序用线程池改进"><a href="#服务端主程序用线程池改进" class="headerlink" title="服务端主程序用线程池改进"></a>服务端主程序用线程池改进</h3><p>为了避免服务端创建太多的线程，可以把服务端用线程池改进，提高服务端的性能。</p>
<p>先写一个给浏览器响应数据的线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderRunnable</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//  立即响应一个网页内容：“黑马程序员”给浏览器展示。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">// 必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改写服务端的主程序，使用ThreadPoolExecutor创建一个线程池，每次接收到一个Socket就往线程池中提交任务就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建出一个线程池，负责处理通信管道的任务。</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">16</span> * <span class="number">2</span>, <span class="number">16</span> * <span class="number">2</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">8</span>) , Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单元测试、反射"><a href="#单元测试、反射" class="headerlink" title="单元测试、反射"></a>单元测试、反射</h1><p>Java主要的知识我们其实已经学习得差不多了。今天同学们再把单元测试、反射、注解、动态代理学习完。</p>
<p>首先，我们进入单元测试的学习。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="单元测试快速入门"><a href="#单元测试快速入门" class="headerlink" title="单元测试快速入门"></a>单元测试快速入门</h3><p>所谓单元测试，就是针对最小的功能单元，编写测试代码对其进行正确性测试。</p>
<p>我们想想，咱们之前是怎么进行测试的呢？</p>
<p>比如说我们写了一个学生管理系统，有添加学生、修改学生、删除学生、查询学生等这些功能。要对这些功能这几个功能进行测试，我们是在main方法中编写代码来测试的。</p>
<p>但是在main方法中写测试代码有如下的几个问题，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh148.png"></p>
<p>为了测试更加方便，有一些第三方的公司或者组织提供了很好用的测试框架，给开发者使用。这里给同学们介绍一种Junit测试框架。</p>
<p>Junit是第三方公司开源出来的，用于对代码进行单元测试的工具（IDEA已经集成了junit框架）。相比于在main方法中测试有如下几个优点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh149.png"></p>
<hr>
<p>我们知道单元测试是什么之后，接下来带领同学们使用一下。由于Junit是第三方提供的，所以我们需要把jar包导入到我们的项目中，才能使用，具体步骤如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh150.png"></p>
<p>接下来，我们就按照上面的步骤，来使用一下.</p>
<p>先准备一个类，假设写了一个StringUtil工具类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;名字长度：&quot;</span>+name.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，写一个测试类，测试StringUtil工具类中的方法能否正常使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtilTest</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrintNumber</span><span class="params">()</span>&#123;</span><br><span class="line">        StringUtil.printNumber(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        StringUtil.printNumber(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完代码之后，我们会发现测试方法左边，会有一个绿色的三角形按钮。点击这个按钮，就可以运行测试方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh151.png"></p>
<h3 id="单元测试断言"><a href="#单元测试断言" class="headerlink" title="单元测试断言"></a>单元测试断言</h3><p>接下来，我们学习一个单元测试的断言机制。<strong>所谓断言：意思是程序员可以预测程序的运行结果，检查程序的运行结果是否与预期一致。</strong></p>
<p>我们在StringUtil类中新增一个测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">(String data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们在StringUtilTest类中写一个测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtilTest</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetMaxIndex</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> StringUtil.getMaxIndex(<span class="literal">null</span>);</span><br><span class="line">       System.out.println(index1);</span><br><span class="line">        </span><br><span class="line">       <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> StringUtil.getMaxIndex(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">       System.out.println(index2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//断言机制：预测index2的结果</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;方法内部有Bug&quot;</span>,<span class="number">4</span>,index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试方法，结果如下图所示，表示我们预期值与实际值不一致</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh152.png"></p>
<h3 id="Junit框架的常用注解"><a href="#Junit框架的常用注解" class="headerlink" title="Junit框架的常用注解"></a>Junit框架的常用注解</h3><p>同学们，刚才我们以及学习了@Test注解，可以用来标记一个方法为测试方法，测试才能启动执行。</p>
<p>除了@Test注解，还有一些其他的注解，我们要知道其他注解标记的方法什么时候执行，以及其他注解在什么场景下可以使用。</p>
<p>注解                 说明<br>@Test<br>测试类中的方法必须用它修饰才能成为测试方法，才能启动执行<br>@Before<br>用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。<br>@After<br>用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。<br>@BeforeClass<br>用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。<br>@AfterClass<br>用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。</p>
<p>接下来，我们演示一下其他注解的使用。我们在StringUtilTest测试类中，再新增几个测试方法。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtilTest</span>&#123;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test1 Before 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test11 BeforeClass 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test2 After 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterCalss</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test22</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test22 AfterCalss 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的测试类，结果如下图所示，观察执行结果特点如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>被<span class="meta">@BeforeClass</span>标记的方法,执行在所有方法之前</span><br><span class="line"><span class="number">2.</span>被<span class="meta">@AfterCalss</span>标记的方法，执行在所有方法之后</span><br><span class="line"><span class="number">3.</span>被<span class="meta">@Before</span>标记的方法，执行在每一个<span class="meta">@Test</span>方法之前</span><br><span class="line"><span class="number">4.</span>被<span class="meta">@After</span>标记的方法，执行在每一个<span class="meta">@Test</span>方法之后</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh153.png"></p>
<p>我们现在已经知道每一个注解的作用了，那他们有什么用呢？应用场景在哪里?</p>
<p>我们来看一个例子，假设我想在每个测试方法中使用Socket对象，并且用完之后，需要把Socket关闭。代码就可以按照下面的结构来设计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtilTest</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test1 Before 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test11 BeforeClass 执行了&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化Socket对象</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test2 After 执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterCalss</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test22</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt; test22 AfterCalss 执行了&quot;</span>);</span><br><span class="line">         <span class="comment">//关闭Socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们再补充一点。前面的注解是基于Junit4版本的，再Junit5版本中对注解作了更新，但是作用是一样的。所以这里就不做演示了</p>
<p>注解                 说明<br>@Test<br>测试类中的方法必须用它修饰才能成为测试方法，才能启动执行<br>@Before<br>用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。<br>@After<br>用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。<br>@BeforeClass<br>用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。<br>@AfterClass<br>用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>各位小伙伴，接下来我们要学习反射技术。在学习反射之前，有几个点需要给同学们提前交代一下，接下来我们学习的反射、动态代理、注解等知识点，在以后开发中极少用到，这些技术都是以后学习框架、或者做框架的底层源码。给同学们讲这些技术的目的，是为了以后我们理解框架、或者自己开发框架给别人用作铺垫的。同时由于这些技术非常抽象，所以按照国际惯例，我们都会采用先带着大家充分的认识它们，然后再了解其作用和应用场景。</p>
<p>接下来，我们就需要带着同学们认识一下什么是反射。其实API文档中对反射有详细的说明，我们去了解一下。在java.lang.reflect包中对反射的解释如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh154.png"></p>
<p>翻译成人话就是：<strong>反射技术，指的是加载类的字节码到内存，并以编程的方法解刨出类中的各个成分（成员变量、方法、构造器等）。</strong></p>
<p>反射有啥用呢？其实反射是用来写框架用的，但是现阶段同学们对框架还没有太多感觉。为了方便理解，我给同学们看一个我们见过的例子：平时我们用IDEA开发程序时，用对象调用方法，IDEA会有代码提示，idea会将这个对象能调用的方法都给你列举出来，供你选择，如果下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh155.png"></p>
<p>问题是IDEA怎么知道这个对象有这些方法可以调用呢? 原因是对象能调用的方法全都来自于类，IDEA通过反射技术就可以获取到类中有哪些方法，并且把方法的名称以提示框的形式显示出来，所以你能看到这些提示了。</p>
<p>那记事本写代码为什么没有提示呢? 因为技术本软件没有利用反射技术开发这种代码提示的功能，哈哈！！</p>
<p>好了，认识了反射是什么之后，接下来我还想给同学们介绍一下反射具体学什么？</p>
<p>因为反射获取的是类的信息，那么反射的第一步首先获取到类才行。由于Java的设计原则是万物皆对象，获取到的类其实也是以对象的形式体现的，<strong>叫字节码对象</strong>，用Class类来表示。获取到字节码对象之后，再通过字节码对象就可以获取到类的组成成分了，这些组成成分其实也是对象，其中<strong>每一个成员变量用Field类的对象来表示</strong>、<strong>每一个成员方法用Method类的对象来表示</strong>，<strong>每一个构造器用Constructor类的对象来表示</strong>。</p>
<p>如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh156.png"></p>
<h3 id="获取类的字节码"><a href="#获取类的字节码" class="headerlink" title="获取类的字节码"></a>获取类的字节码</h3><p>反射的第一步：是将字节码加载到内存，我们需要获取到的字节码对象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh157.png"></p>
<p>比如有一个Student类，获取Student类的字节码代码有三种写法。不管用哪一种方式，获取到的字节码对象其实是同一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1Class</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获取全类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获取简单类名</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.d2_reflect.Student&quot;</span>);</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(c2 == c3); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取类的构造器"><a href="#获取类的构造器" class="headerlink" title="获取类的构造器"></a>获取类的构造器</h3><p>我们已经可以获取到类的字节码对象了。接下来，我们学习一下通过字节码对象获取构造器，并使用构造器创建对象。</p>
<p>获取构造器，需要用到Class类提供的几个方法，如下图所示：</p>
<p>方法                       说明<br>Constructor<?>[] getConstructors()
获取全部构造器(只能获取public修饰的)
Constructor<?>[] getDeclaredconstructors()<br>获取全部构造器(只要存在就能拿到)<br>constructor<T> getConstructor(class<?>... parameterTypes)
获取某个构造器(只能获取public修饰的)
Constructor<T> getDeclaredConstructor(Class<?>…parameterTypes)<br>获取某个构造器(只要存在就能拿到)</p>
<p>想要快速记住这个方法的区别，给同学们说一下这些方法的命名规律，按照规律来记就很方便了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get:获取</span><br><span class="line">Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个<span class="keyword">public</span>修饰的</span><br><span class="line">Constructor: 构造方法的意思</span><br><span class="line">后缀s: 表示可以获取多个，没有后缀s只能获取一个</span><br></pre></td></tr></table></figure>

<p>话不多少，上代码。假设现在有一个Cat类，里面有几个构造方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>接下来，我们写一个测试方法，来测试获取类中所有的构造器</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2Constructor</span>()&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：必须先得到这个类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类的全部构造器</span></span><br><span class="line">        Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">//3、遍历数组中的每一个构造器对象。</span></span><br><span class="line">        <span class="keyword">for</span>(Constructor constructor: constructors)&#123;</span><br><span class="line">            System.out.println(constructor.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试方法打印结果如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh158.png"></p>
<ul>
<li><ol start="2">
<li>刚才演示的是获取Cat类中所有的构造器，接下来，我们演示单个构造器试一试</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2Constructor</span>()&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetConstructor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：必须先得到这个类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类public修饰的空参数构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> c.getConstructor();</span><br><span class="line">        System.out.println(constructor1.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor1.getParameterCount());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、获取private修饰的有两个参数的构造器，第一个参数String类型，第二个参数int类型</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> </span><br><span class="line">            c.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(constructor2.getName()+<span class="string">&quot;---&gt; 参数个数：&quot;</span>+constructor1.getParameterCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh159.png"></p>
<h3 id="反射获取构造器的作用"><a href="#反射获取构造器的作用" class="headerlink" title="反射获取构造器的作用"></a>反射获取构造器的作用</h3><p>同学们，刚才上一节我们已经获取到了Cat类中的构造器。获取到构造器后，有什么作用呢？</p>
<p>其实构造器的作用：<strong>初始化对象并返回</strong>。</p>
<p>这里我们需要用到如下的两个方法，注意：这两个方法时属于Constructor的，需要用Constructor对象来调用。 </p>
<p>constructor提供的方法                     说明<br>T RewInstance(object. . . initargs)<br>调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回<br>public void setAccessible(boolean flag)<br>设置为true，表示禁止检查访问控制(暴力反射)</p>
<p>如下图所示，constructor1和constructor2分别表示Cat类中的两个构造器。现在我要把这两个构造器执行起来</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh160.png"></p>
<p>由于构造器是private修饰的，先需要调用<code>setAccessible(true)</code> 表示禁止检查访问控制，然后再调用<code>newInstance(实参列表)</code> 就可以执行构造器，完成对象的初始化了。</p>
<p>代码如下：为了看到构造器真的执行， 故意在两个构造器中分别加了两个打印语句</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh161.png"></p>
<p>代码的执行结果如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh162.png"></p>
<h3 id="反射获取成员变量-使用"><a href="#反射获取成员变量-使用" class="headerlink" title="反射获取成员变量&amp;使用"></a>反射获取成员变量&amp;使用</h3><p>同学们，上一节我们已经学习了获取类的构造方法并使用。接下来，我们再学习获取类的成员变量，并使用。</p>
<p>其实套路是一样的，在Class类中提供了获取成员变量的方法，如下图所示。</p>
<p>方法                                       说明<br>public Field[] getFields()                 获取类的全部成员变量(只能获取public修饰的)<br>public Field[] getDeclaredFields()         获取类的全部成员变量(只要存在就能拿到)<br>public Field getField(string name)         获取类的某个成员变量(只能获取public修饰的)<br>public Field getDeclaredField(string name) 获取类的某个成员变量(只要存在就能拿到)</p>
<p>这些方法的记忆规则，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get:获取</span><br><span class="line">Declared: 有这个单词表示可以获取任意一个，没有这个单词表示只能获取一个<span class="keyword">public</span>修饰的</span><br><span class="line">Field: 成员变量的意思</span><br><span class="line">后缀s: 表示可以获取多个，没有后缀s只能获取一个</span><br></pre></td></tr></table></figure>

<ul>
<li>假设有一个Cat类它有若干个成员变量，用Class类提供 的方法将成员变量的对象获取出来。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh163.png"></p>
<p>执行完上面的代码之后，我们可以看到控制台上打印输出了，每一个成员变量的名称和它的类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh164.png"></p>
<ul>
<li>获取到成员变量的对象之后该如何使用呢？</li>
</ul>
<p>在Filed类中提供给给成员变量赋值和获取值的方法，如下图所示。</p>
<p>方法                                    说明<br>void set(object obj, object value) :    赋值<br>object get(object obj)                  取值<br>public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制(暴力反射)</p>
<p>再次强调一下设置值、获取值的方法时Filed类的需要用Filed类的对象来调用，而且不管是设置值、还是获取值，都需要依赖于该变量所属的对象。代码如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh165.png"></p>
<p>执行代码，控制台会有如下的打印</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh166.png"></p>
<h3 id="反射获取成员方法"><a href="#反射获取成员方法" class="headerlink" title="反射获取成员方法"></a>反射获取成员方法</h3><p>各位同学，上面几节我们已经学习了反射获取构造方法、反射获取成员变量，还剩下最后一个就是反射获取成员方法并使用了。</p>
<p>在Java中反射包中，每一个成员方法用Method对象来表示，通过Class类提供的方法可以获取类中的成员方法对象。如下下图所示</p>
<p>方法                     说明<br>Method[] getMethods()<br>获取类的全部成员方法(只能获取public修饰的)<br>Method[] getDeclaredMethods()<br>获取类的全部成员方法(只要存在就能拿到)<br>Method getMethod( string name,class&lt;… parameterTypes)<br>获取类的某个成员方法(只能获取public修饰的)<br>Method getDeclaredMethod(String name，class&lt;?&gt;… parameterTypes)<br>获取类的某个成员方法(只要存在就能拿到)</p>
<p>接下来我们还是用代码演示一下：假设有一个Cat类，在Cat类中红有若干个成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空参数构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造方法执行了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&gt;^ω^&lt;)喵跑得贼快~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&gt;^ω^&lt;)喵爱吃猫粮~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">eat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&gt;^ω^&lt;)喵爱吃:&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，通过反射获取Cat类中所有的成员方法，每一个成员方法都是一个Method对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3Method</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：先获取到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类中的全部成员方法</span></span><br><span class="line">        Method[] methods = c.getDecalaredMethods();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、遍历这个数组中的每一个方法对象</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;--&gt;&quot;</span>+method.getParameterCount()+<span class="string">&quot;--&gt;&quot;</span>+method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，运行结果如下图所示：<strong>打印输出每一个成员方法的名称、参数格式、返回值类型</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh167.png"></p>
<p>也能获取单个指定的成员方法，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh168.png"></p>
<hr>
<p><strong>获取到成员方法之后，有什么作用呢？</strong></p>
<p>在Method类中提供了方法，可以将方法自己执行起来。</p>
<p>Method提供的方法                      说明<br>public object invoke(object obj, object. . . args)<br>触发某个对象的该方法执行。<br>7:-..idetccessible(boolean flag)<br>设置为true，表示禁止检查访问控制(暴力反射)</p>
<p>下面我们演示一下，把<code>run()</code>方法和<code>eat(String name)</code>方法执行起来。看分割线之下的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3Method</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1、反射第一步：先获取到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Cat.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、获取类中的全部成员方法</span></span><br><span class="line">        Method[] methods = c.getDecalaredMethods();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、遍历这个数组中的每一个方法对象</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            System.out.println(method.getName()+<span class="string">&quot;--&gt;&quot;</span>+method.getParameterCount()+<span class="string">&quot;--&gt;&quot;</span>+method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4、获取private修饰的run方法，得到Method对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">run</span> <span class="operator">=</span> c.getDecalaredMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        <span class="comment">//执行run方法,在执行前需要取消权限检查</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        run.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs1</span> <span class="operator">=</span> run.invoke(cat);</span><br><span class="line">        System.out.println(rs1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、获取private 修饰的eat(String name)方法，得到Method对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs2</span> <span class="operator">=</span> eat.invoke(cat,<span class="string">&quot;鱼儿&quot;</span>);</span><br><span class="line">        System.out.println(rs2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下图所示：run()方法执行后打印<code>猫跑得贼快~~</code>，返回<code>null</code>； eat()方法执行完，直接返回<code>猫最爱吃:鱼儿</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh169.png"></p>
<h3 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h3><p>按照前面我们学习反射的套路，我们已经充分认识了什么是反射，以及反射的核心作用是用来获取类的各个组成部分并执行他们。但是由于同学们的经验有限，对于反射的具体应用场景还是很难感受到的（这个目前没有太好的办法，只能慢慢积累，等经验积累到一定程度，就会豁然开朗了）。</p>
<p>我们一直说反射使用来写框架的，接下来，我们就写一个简易的框架，简单窥探一下反射的应用。反射其实是非常强大的，这个案例也仅仅值小试牛刀。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh170.png"></p>
<p>需求是让我们写一个框架，能够将任意一个对象的属性名和属性值写到文件中去。不管这个对象有多少个属性，也不管这个对象的属性名是否相同。</p>
<p>分析一下该怎么做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先写好两个类，一个Student类和Teacher类</span><br><span class="line"><span class="number">2.</span>写一个ObjectFrame类代表框本架</span><br><span class="line">	在ObjectFrame类中定义一个saveObject(Object obj)方法，用于将任意对象存到文件中去</span><br><span class="line">	参数：Object obj: 就表示要存入文件中的对象</span><br><span class="line">	</span><br><span class="line"><span class="number">3.</span>编写方法内部的代码，往文件中存储对象的属性名和属性值</span><br><span class="line">	<span class="number">1</span>)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。</span><br><span class="line">	<span class="number">2</span>)接着就通过反射获取类的成员变量信息了（变量名、变量值）</span><br><span class="line">	<span class="number">3</span>)把变量名和变量值写到文件中去</span><br></pre></td></tr></table></figure>

<p>写一个ObjectFrame表示自己设计的框架，代码如下图所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectFrame</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;模块名\\src\\data.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//1)参数obj对象中有哪些属性，属性名是什么实现值是什么，中有对象自己最清楚。</span></span><br><span class="line">		<span class="comment">//2)接着就通过反射获取类的成员变量信息了（变量名、变量值）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> obj.getClass(); <span class="comment">//获取字节码</span></span><br><span class="line">        ps.println(<span class="string">&quot;---------&quot;</span>+class.getSimpleName()+<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Field[] fields = c.getDeclaredFields(); <span class="comment">//获取所有成员变量</span></span><br><span class="line">		<span class="comment">//3)把变量名和变量值写到文件中去</span></span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">            ps.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自己设计的框架，往文件中写入Student对象的信息和Teacher对象的信息。</p>
<p>先准备好Student类和Teacher类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个测试类，在测试中类创建一个Student对象，创建一个Teacher对象，用ObjectFrame的方法把这两个对象所有的属性名和属性值写到文件中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5Frame</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黑马吴彦祖&quot;</span>,<span class="number">45</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">185.3</span>, <span class="string">&quot;篮球，冰球，阅读&quot;</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;播妞&quot;</span>,<span class="number">999.9</span>);</span><br><span class="line">        </span><br><span class="line">        ObjectFrame.save(s1);</span><br><span class="line">        ObjectFrame.save(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开data.txt文件，内容如下图所示，就说明我们这个框架的功能已经实现了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh171.png"></p>
<p>好了，同学们，恭喜大家！学习到这里，反射技术已经学习完毕了。</p>
<hr>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="认识注解-定义注解"><a href="#认识注解-定义注解" class="headerlink" title="认识注解&amp;定义注解"></a>认识注解&amp;定义注解</h3><p>接下来我们学习注解。注解和反射一样，都是用来做框架的，我们这里学习注解的目的其实是为了以后学习框架或者做框架做铺垫的。</p>
<p>那注解该怎么学呢？和反射的学习套路一样，我们先充分的认识注解，掌握注解的定义和使用格式，然后再学习它的应用场景。</p>
<blockquote>
<p><strong>先来认识一下什么是注解？</strong></p>
</blockquote>
<p><strong>Java注解是代码中的特殊标记，比如@Override、@Test等，作用是：让其他程序根据注解信息决定怎么执行该程序。</strong></p>
<p>比如：Junit框架的@Test注解可以用在方法上，用来标记这个方法是测试方法，被@Test标记的方法能够被Junit框架执行。</p>
<p>再比如：@Override注解可以用在方法上，用来标记这个方法是重写方法，被@Override注解标记的方法能够被IDEA识别进行语法检查。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh172.png"></p>
<ul>
<li><strong>注解不光可以用在方法上，还可以用在类上、变量上、构造器上等位置。</strong></li>
</ul>
<p>上面我们说的@Test注解、@Overide注解是别人定义好给我们用的，将来如果需要自己去开发框架，就需要我们自己定义注解。</p>
<blockquote>
<p><strong>接着我们学习自定义注解</strong></p>
</blockquote>
<p>自定义注解的格式如下图所示</p>
<p>public @interface 注解名称{<br>public 属性类型属性名() default默认值;<br>}</p>
<p>比如：现在我们自定义一个MyTest注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;	<span class="comment">//default true 表示默认值为true,使用时可以不赋值。</span></span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好MyTest注解之后，我们可以使用MyTest注解在类上、方法上等位置做标记。注意使用注解时需要加@符号，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest1</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：注解的属性名如何是value的话，并且只有value没有默认值，使用注解时value名称可以省略。比如现在重新定义一个MyTest2注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest2&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">//特殊属性</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好MyTest2注解后，再将@MyTest2标记在类上，此时value属性名可以省略，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest2(&quot;孙悟空&quot;)</span> <span class="comment">//等价于 @MyTest2(value=&quot;孙悟空&quot;)</span></span><br><span class="line"><span class="meta">@MyTest1(aaa=&quot;牛魔王&quot;,ccc=&#123;&quot;HTML&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest1</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest(aaa=&quot;铁扇公主&quot;,bbb=false, ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里关于定义注解的格式、以及使用注解的格式就学习完了。</p>
<blockquote>
<p><strong>注解本质是什么呢？</strong></p>
</blockquote>
<p>想要搞清楚注解本质是什么东西，我们可以把注解的字节码进行反编译，使用XJad工具进行反编译。经过对MyTest1注解字节码反编译我们会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>MyTest1注解本质上是接口，每一个注解接口都继承子Annotation接口</span><br><span class="line"><span class="number">2.</span>MyTest1注解中的属性本质上是抽象方法</span><br><span class="line"><span class="number">3.</span><span class="meta">@MyTest1</span>实际上是作为MyTest接口的实现类对象</span><br><span class="line"><span class="number">4.</span><span class="meta">@MyTest1(aaa=&quot;孙悟空&quot;,bbb=false,ccc=&#123;&quot;Python&quot;,&quot;前端&quot;,&quot;Java&quot;&#125;)</span>里面的属性值，可以通过调用aaa()、bbb()、ccc()方法获取到。 【别着急，继续往下看，再解析注解时会用到】</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh173.png"></p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>各位小伙伴，刚才我们已经认识了注解以及注解的基本使用。接下来我们还需要学习几种特殊的注解，叫做元注解。</p>
<blockquote>
<p><strong>什么是元注解？</strong></p>
</blockquote>
<p><strong>元注解是修饰注解的注解</strong>。这句话虽然有一点饶，但是非常准确。我们看一个例子</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh174.png"></p>
<p>接下来分别看一下@Target注解和@Retention注解有什么作用，如下图所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>是用来声明注解只能用在那些位置，比如：类上、方法上、成员变量上等</span><br><span class="line"><span class="meta">@Retetion</span>是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh175.png"></p>
<ul>
<li>@Target元注解的使用：比如定义一个MyTest3注解，并添加@Target注解用来声明MyTest3的使用位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>	<span class="comment">//声明@MyTest3注解只能用在类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们把@MyTest3用来类上观察是否有错，再把@MyTest3用在方法上、变量上再观察是否有错</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh176.png"></p>
<p>如果我们定义MyTest3注解时，使用@Target注解属性值写成下面样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest3注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>	</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再观察，@MyTest用在类上、方法上、变量上是否有错</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh177.png"></p>
<p>到这里@Target元注解的使用就演示完毕了。</p>
<ul>
<li>@Retetion元注解的使用：定义MyTest3注解时，给MyTest3注解添加@Retetion注解来声明MyTest3注解保留的时期</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retetion</span>是用来声明注解保留周期，比如：源代码时期、字节码时期、运行时期</span><br><span class="line">	<span class="meta">@Retetion(RetetionPloicy.SOURCE)</span>: 注解保留到源代码时期、字节码中就没有了</span><br><span class="line">	<span class="meta">@Retetion(RetetionPloicy.CLASS)</span>: 注解保留到字节码中、运行时注解就没有了</span><br><span class="line">	<span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span>：注解保留到运行时期</span><br><span class="line">	【自己写代码时，比较常用的是保留到运行时期】</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest3注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>	</span><br><span class="line"><span class="comment">//控制使用了@MyTest3注解的代码中，@MyTest3保留到运行时期</span></span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest3&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h3><p>各位小伙伴，通过前面的学习我们能够自己定义注解，也能够把自己定义的注解标记在类上或者方法上等位置，但是总感觉有点别扭，给类、方法、变量等加上注解后，我们也没有干什么呀！！！</p>
<p>接下来，我们就要做点什么。我们可以通过反射技术把类上、方法上、变量上的注解对象获取出来，然后通过调用方法就可以获取注解上的属性值了。<strong>我们把获取类上、方法上、变量上等位置注解及注解属性值的过程称为解析注解。</strong></p>
<p>解析注解套路如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果注解在类上，先获取类的字节码对象，再获取类上的注解</span><br><span class="line"><span class="number">2.</span>如果注解在方法上，先获取方法对象，再获取方法上的注解</span><br><span class="line"><span class="number">3.</span>如果注解在成员变量上，先获取成员变量对象，再获取变量上的注解</span><br><span class="line">总之：注解在谁身上，就先获取谁，再用谁获取谁身上的注解</span><br></pre></td></tr></table></figure>

<ul>
<li>Class、Method ,Field , Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。</li>
</ul>
<p>AnnotatedElement接口提供了解析注解的方法<br>说明<br>public Annotation[] getDeclaredAnnotations()<br>获取当前对象上面的注解。<br>public T getDeclaredAnnotation(class<T> annotationclass)<br>获取指定的注解对象<br>public boolean isAnnotationPresent(class<Annotation> annotationclass)<br>判断当前对象上是否存在某个注解</p>
<p>解析来看一个案例，来演示解析注解的代码编写</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh178.png"></p>
<p>按照需求要求一步一步完成</p>
<p>① 先定义一个MyTest4注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明@MyTest4注解只能用在类上和方法上</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span>	</span><br><span class="line"><span class="comment">//控制使用了@MyTest4注解的代码中，@MyTest4保留到运行时期</span></span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest4&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">aaa</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] bbb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 定义有一个类Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyTest4(value=&quot;蜘蛛侠&quot;,aaa=99.9, bbb=&#123;&quot;至尊宝&quot;,&quot;黑马&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest4(value=&quot;孙悟空&quot;,aaa=199.9, bbb=&#123;&quot;紫霞&quot;,&quot;牛夫人&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 写一个测试类AnnotationTest3解析Demo类上的MyTest4注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest3</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类上的注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取类上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)c.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Demo.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析Demo类中test1方法上的注解MyTest4注解</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(MyTest4.class))&#123;</span><br><span class="line">            <span class="comment">//获取方法上的MyTest4注解</span></span><br><span class="line">            <span class="type">MyTest4</span> <span class="variable">myTest4</span> <span class="operator">=</span> (MyTest4)m.getDeclaredAnnotation(MyTest4.class);</span><br><span class="line">            <span class="comment">//获取MyTests4注解的属性值</span></span><br><span class="line">            System.out.println(myTest4.value());</span><br><span class="line">            System.out.println(myTest4.aaa());</span><br><span class="line">            System.out.println(myTest4.bbb());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h3><p>各位同学，关于注解的定义、使用、解析注解就已经学习完了。接下来，我们再学习一下注解的应用场景，注解是用来写框架的，比如现在我们要模拟Junit写一个测试框架，要求有@MyTest注解的方法可以被框架执行，没有@MyTest注解的方法不能被框架执行。</p>
<p>第一步：先定义一个MyTest注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>	</span><br><span class="line"><span class="meta">@Retetion(RetetionPloicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：写一个测试类AnnotationTest4，在类中定义几个被@MyTest注解标记的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest4</span>&#123;</span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====test1====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====test2====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====test2====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">AnnotationTest4</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationTest4</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.先获取Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> AnnotationTest4.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.解析AnnotationTest4类中所有的方法对象</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m: methods)&#123;</span><br><span class="line">            <span class="comment">//3.判断方法上是否有MyTest注解，有就执行该方法</span></span><br><span class="line">            <span class="keyword">if</span>(m.isAnnotationPresent(MyTest.class))&#123;</span><br><span class="line">            	m.invoke(a);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学习到这里，关于注解的使用就学会了(<em>^▽^</em>)</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="动态代理介绍、准备功能"><a href="#动态代理介绍、准备功能" class="headerlink" title="动态代理介绍、准备功能"></a>动态代理介绍、准备功能</h3><p>这节课我们学习一个Java的高级技术叫做动态代理。首先我们认识一下代理长什么样？我们以大明星“杨超越”例。</p>
<p>假设现在有一个大明星叫杨超越，它有唱歌和跳舞的本领，作为大明星是要用唱歌和跳舞来赚钱的，但是每次做节目，唱歌的时候要准备话筒、收钱，再唱歌；跳舞的时候也要准备场地、收钱、再唱歌。杨超越越觉得我擅长的做的事情是唱歌，和跳舞，但是每次唱歌和跳舞之前或者之后都要做一些繁琐的事情，有点烦。于是杨超越就找个一个经济公司，请了一个代理人，代理杨超越处理这些事情，如果有人想请杨超越演出，直接找代理人就可以了。如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh179.png"></p>
<p>我们说杨超越的代理是中介公司派的，那中介公司怎么知道，要派一个有唱歌和跳舞功能的代理呢？</p>
<p>解决这个问题，Java使用的是接口，杨超越想找代理，在Java中需要杨超越实现了一个接口，接口中规定要唱歌和跳舞的方法。Java就可以通过这个接口为杨超越生成一个代理对象，只要接口中有的方法代理对象也会有。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh180.png"></p>
<p>接下来我们就先把有唱歌和跳舞功能的接口，和实现接口的大明星类定义出来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh181.png"></p>
<h3 id="生成动态代理对象"><a href="#生成动态代理对象" class="headerlink" title="生成动态代理对象"></a>生成动态代理对象</h3><p>下面我们写一个为BigStar生成动态代理对象的工具类。这里需要用Java为开发者提供的一个生成代理对象的类叫Proxy类。</p>
<p>通过Proxy类的newInstance(…)方法可以为实现了同一接口的类生成代理对象。 调用方法时需要传递三个参数，该方法的参数解释可以查阅API文档，如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh182.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStar bigStar)</span>&#123;</span><br><span class="line">       <span class="comment">/* newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                InvocationHandler h)</span></span><br><span class="line"><span class="comment">                参数1：用于指定一个类加载器</span></span><br><span class="line"><span class="comment">                参数2：指定生成的代理长什么样子，也就是有哪些方法</span></span><br><span class="line"><span class="comment">                参数3：用来指定生成的代理对象要干什么事情</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">        <span class="comment">// Star starProxy = ProxyUtil.createProxy(s);</span></span><br><span class="line">        <span class="comment">// starProxy.sing(&quot;好日子&quot;) starProxy.dance()</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">starProxy</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 回调方法</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// 代理对象要做的事情，会在这里写代码</span></span><br><span class="line">                        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;sing&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备话筒，收钱20万&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;dance&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备场地，收钱1000万&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStar, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> starProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用我们写好的ProxyUtil工具类，为BigStar对象生成代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigStar</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigStar</span>(<span class="string">&quot;杨超越&quot;</span>);</span><br><span class="line">        <span class="type">Star</span> <span class="variable">starProxy</span> <span class="operator">=</span> ProxyUtil.createProxy(s);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> starProxy.sing(<span class="string">&quot;好日子&quot;</span>);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        starProxy.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类，结果如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh183.png"></p>
<p>当你把上面的案例写出来，并且理解，那么动态代理的基本使用就学会了。</p>
<h3 id="动态代理应用"><a href="#动态代理应用" class="headerlink" title="动态代理应用"></a>动态代理应用</h3><p>学习完动态代理的基本使用之后，接下来我们再做一个应用案例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh184.png"></p>
<p>现有如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用户业务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 登录功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String loginName,String passWord)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">// 查询用户，返回数组的形式。</span></span><br><span class="line">    String[] selectUsers() <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面有一个UserService接口的实现类，下面每一个方法中都有计算方法运行时间的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户业务实现类（面向接口编程）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String loginName, String passWord)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录成功，欢迎光临本系统~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录失败，用户名或密码错误~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;login方法耗时：&quot;</span>+(time2-time1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除了1万个用户~&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;deleteUsers方法耗时：&quot;</span>+(time2-time1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectUsers() <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;查询出了3个用户&quot;</span>);</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;张全蛋&quot;</span>, <span class="string">&quot;李二狗&quot;</span>, <span class="string">&quot;牛爱花&quot;</span>&#125;;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;selectUsers方法耗时：&quot;</span>+(time2-time1));</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上面代码发现有什么问题吗？</p>
<p>我们会发现每一个方法中计算耗时的代码都是重复的，我们可是学习了动态代理的高级程序员，怎么能忍受在每个方法中写重复代码呢！况且这些重复的代码并不属于UserSerivce的主要业务代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh185.png"></p>
<p>所以接下来我们打算，把计算每一个方法的耗时操作，交给代理对象来做。</p>
<p>先在UserService类中把计算耗时的代码删除，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户业务实现类（面向接口编程）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String loginName, String passWord)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录成功，欢迎光临本系统~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您登录失败，用户名或密码错误~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功删除了1万个用户~&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectUsers() <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;查询出了3个用户&quot;</span>);</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;张全蛋&quot;</span>, <span class="string">&quot;李二狗&quot;</span>, <span class="string">&quot;牛爱花&quot;</span>&#125;;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为UserService生成一个动态代理对象，在动态代理中调用目标方法，在调用目标方法之前和之后记录毫秒值，并计算方法运行的时间。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createProxy</span><span class="params">(UserService userService)</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceProxy</span></span><br><span class="line">            <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            ProxyUtil.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;UserService.class&#125;, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                                                                            			<span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(                                                                             Object proxy, </span></span><br><span class="line"><span class="params">                              Method method, </span></span><br><span class="line"><span class="params">                                  Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;                             <span class="keyword">if</span>(</span><br><span class="line">                    method.getName().equals(<span class="string">&quot;login&quot;</span>) ||                                             method.getName().equals(<span class="string">&quot;deleteUsers&quot;</span>)||</span><br><span class="line">                    method.getName().equals(<span class="string">&quot;selectUsers&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">//方法运行前记录毫秒值         </span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">//执行方法</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                    <span class="comment">//执行方法后记录毫秒值</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    System.out.println(method.getName() + <span class="string">&quot;方法执行耗时：&quot;</span> + (endTime - startTime)/ <span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> rs;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                    <span class="keyword">return</span> rs;                                                                &#125;</span><br><span class="line">           &#125;                                                                 &#125;);</span><br><span class="line">        <span class="comment">//返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> userServiceProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中为UserService创建代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：使用动态代理解决实际问题，并掌握使用代理的好处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1、创建用户业务对象。</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ProxyUtil.createProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、调用用户业务的功能。</span></span><br><span class="line">        userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        userService.deleteUsers();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] names = userService.selectUsers();</span><br><span class="line">        System.out.println(<span class="string">&quot;查询到的用户是：&quot;</span> + Arrays.toString(names));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下图所示<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh186.png"></p>
<p>动态代理对象的执行流程如下图所示，每次用代理对象调用方法时，都会执行InvocationHandler中的invoke方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/hh187.png"></p>
<p>动态代理我们已经学习完了。到此整个JavaSE的课程也学习完了。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Smith</div><div class="post-copyright__author_desc">人生太短，要干的事太多，我要争分夺秒</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://smithhs.cn/2021/06/15/2021-06-15-Java%E5%AD%A6%E4%B9%A03/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://smithhs.cn/2021/06/15/2021-06-15-Java%E5%AD%A6%E4%B9%A03/')">Java学习3</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://smithhs.cn/2021/06/15/2021-06-15-Java%E5%AD%A6%E4%B9%A03/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java学习3&amp;url=https://smithhs.cn/2021/06/15/2021-06-15-Java%E5%AD%A6%E4%B9%A03/&amp;pic=https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://smithhs.cn" target="_blank">Smith</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">6</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/dataanalysis.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/12/2021-06-12-java%E5%AD%A6%E4%B9%A02/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java学习2</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/20/2021-06-20-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/gg1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端学习路线</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/05/16/2021-05-16-java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="Java学习路线"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-16</div><div class="title">Java学习路线</div></div></a></div><div><a href="/2021/05/17/2021-05-17-Java%E5%AD%A6%E4%B9%A0/" title="Java学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-17</div><div class="title">Java学习</div></div></a></div><div><a href="/2021/06/30/2021-06-30-java%E9%80%9F%E6%88%90/" title="Java速成"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-06-30</div><div class="title">Java速成</div></div></a></div><div><a href="/2021/06/12/2021-06-12-java%E5%AD%A6%E4%B9%A02/" title="Java学习2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/java%E5%AD%A6%E4%B9%A0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-06-12</div><div class="title">Java学习2</div></div></a></div><div><a href="/2024/05/24/2024-05-24%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E9%B2%81Java%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/" title="手把手带你鲁Java代码生成工具"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/javeEE.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-24</div><div class="title">手把手带你鲁Java代码生成工具</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">简单认识算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 选择排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">查找算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99"><span class="toc-number">2.2.</span> <span class="toc-text">书写规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">正则表达式应用案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%9F%A5%E6%89%BE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.</span> <span class="toc-text">用于查找信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2%E3%80%81%E5%88%86%E5%89%B2%E5%86%85%E5%AE%B9"><span class="toc-number">2.5.</span> <span class="toc-text">用于搜索替换、分割内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text">认识异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">异常的处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">4.</span> <span class="toc-text">集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">Collection的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">Collection的遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="toc-number">4.3.2.</span> <span class="toc-text">增强for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">4.3.3.</span> <span class="toc-text">forEach遍历集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">4.3.4.</span> <span class="toc-text">遍历集合案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">4.4.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E3%80%81%E7%89%B9%E6%9C%89%E6%96%B9%E5%BC%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text">特点、特有方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.3.</span> <span class="toc-text">ArrayList集合的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkList%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.4.</span> <span class="toc-text">LinkList集合的底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">4.5.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.2.</span> <span class="toc-text">HashSet集合的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.3.</span> <span class="toc-text">LinkedHashSet集合的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet%E9%9B%86%E5%90%88"><span class="toc-number">4.5.4.</span> <span class="toc-text">TreeSet集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">注意事项：集合的并发修改异常问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collection%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">5.</span> <span class="toc-text">Collection的其他相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9A%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">前置知识：可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections"><span class="toc-number">5.2.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">5.3.</span> <span class="toc-text">综合案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%97%E5%9C%B0%E4%B8%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">斗地主案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-1"><span class="toc-number">6.3.</span> <span class="toc-text">遍历方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">6.4.</span> <span class="toc-text">Map集合案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">6.5.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkHashMap"><span class="toc-number">6.6.</span> <span class="toc-text">LinkHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-number">6.7.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9A%E9%9B%86%E5%90%88%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">6.8.</span> <span class="toc-text">补充知识：集合的嵌套</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">7.</span> <span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Stream"><span class="toc-number">7.1.</span> <span class="toc-text">认识Stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">Stream的常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E3%80%81IO%E6%B5%81"><span class="toc-number">8.</span> <span class="toc-text">File、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#File"><span class="toc-number">8.1.</span> <span class="toc-text">File</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%951%EF%BC%9A%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E3%80%81%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">8.1.2.</span> <span class="toc-text">常见方法1：判断文件类型、获取文件信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%952%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E3%80%81%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">8.1.3.</span> <span class="toc-text">常用方法2：创建文件、删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%953%EF%BC%9A%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">8.1.4.</span> <span class="toc-text">常用方法3：遍历文件夹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92"><span class="toc-number">8.2.</span> <span class="toc-text">方法递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%BC%95%E5%85%A5"><span class="toc-number">8.2.1.</span> <span class="toc-text">递归算法引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">递归算法的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2"><span class="toc-number">8.2.3.</span> <span class="toc-text">递归文件搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">8.3.</span> <span class="toc-text">字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E6%9D%A5%E5%8E%86"><span class="toc-number">8.3.1.</span> <span class="toc-text">字符集的来历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%89%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84%E7%BC%96%E7%A0%81%E7%89%B9%E7%82%B9"><span class="toc-number">8.3.2.</span> <span class="toc-text">汉字和字母的编码特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unicode%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">8.3.3.</span> <span class="toc-text">Unicode字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%B0%8F%E7%BB%93"><span class="toc-number">8.3.4.</span> <span class="toc-text">字符集小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-number">8.3.5.</span> <span class="toc-text">编码和解码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">IO流（字节流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-number">8.4.1.</span> <span class="toc-text">IO流概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInputStream%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">8.4.2.</span> <span class="toc-text">FileInputStream读取一个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInputStream%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">8.4.3.</span> <span class="toc-text">FileInputStream读取多个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInputStream%E8%AF%BB%E5%8F%96%E5%85%A8%E9%83%A8%E5%AD%97%E8%8A%82"><span class="toc-number">8.4.4.</span> <span class="toc-text">FileInputStream读取全部字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileOutputStream%E5%86%99%E5%AD%97%E8%8A%82"><span class="toc-number">8.4.5.</span> <span class="toc-text">FileOutputStream写字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.6.</span> <span class="toc-text">字节流复制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">8.5.</span> <span class="toc-text">IO流资源释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK7%E4%BB%A5%E5%89%8D%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">8.5.1.</span> <span class="toc-text">JDK7以前的资源释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK7%E4%BB%A5%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">8.5.2.</span> <span class="toc-text">JDK7以后的资源释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">8.6.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader%E7%B1%BB"><span class="toc-number">8.6.1.</span> <span class="toc-text">FileReader类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileWriter%E7%B1%BB"><span class="toc-number">8.6.2.</span> <span class="toc-text">FileWriter类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileWriter%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.6.3.</span> <span class="toc-text">FileWriter写的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">8.7.</span> <span class="toc-text">缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">8.7.1.</span> <span class="toc-text">缓冲字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">8.7.2.</span> <span class="toc-text">2.2 字符缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">8.7.3.</span> <span class="toc-text">缓冲流性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">8.8.</span> <span class="toc-text">三、转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader%E7%B1%BB"><span class="toc-number">8.8.1.</span> <span class="toc-text">InputStreamReader类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputStreamWriter%E7%B1%BB"><span class="toc-number">8.8.2.</span> <span class="toc-text">OutputStreamWriter类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">8.9.</span> <span class="toc-text">打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">8.9.1.</span> <span class="toc-text">打印流基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.9.2.</span> <span class="toc-text">重定向输出语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">8.10.</span> <span class="toc-text">数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataOutputStream%E7%B1%BB"><span class="toc-number">8.10.1.</span> <span class="toc-text">DataOutputStream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataInputStream%E7%B1%BB"><span class="toc-number">8.10.2.</span> <span class="toc-text">DataInputStream类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">8.11.</span> <span class="toc-text">序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectOutputStraem%E7%B1%BB"><span class="toc-number">8.11.1.</span> <span class="toc-text">ObjectOutputStraem类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectInputStream%E7%B1%BB"><span class="toc-number">8.11.2.</span> <span class="toc-text">ObjectInputStream类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9AIO%E6%A1%86%E6%9E%B6"><span class="toc-number">8.12.</span> <span class="toc-text">补充知识：IO框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">特殊文件、日志技术、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.</span> <span class="toc-text">属性文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.1.</span> <span class="toc-text">特殊文件概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.2.</span> <span class="toc-text">Properties属性文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XML%E6%96%87%E4%BB%B6"><span class="toc-number">9.2.</span> <span class="toc-text">XML文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">XML文件概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E8%A7%A3%E6%9E%901"><span class="toc-number">9.2.2.</span> <span class="toc-text">XML解析1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E8%A7%A3%E6%9E%902"><span class="toc-number">9.2.3.</span> <span class="toc-text">XML解析2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-number">9.2.4.</span> <span class="toc-text">XML文件写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E7%BA%A6%E6%9D%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">9.2.5.</span> <span class="toc-text">XML约束（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><span class="toc-number">9.3.</span> <span class="toc-text">日志技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0"><span class="toc-number">9.3.1.</span> <span class="toc-text">日志概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%93%E7%B3%BB"><span class="toc-number">9.3.2.</span> <span class="toc-text">日志的体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logback%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">9.3.3.</span> <span class="toc-text">Logback快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">9.3.4.</span> <span class="toc-text">日志配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-number">9.3.5.</span> <span class="toc-text">3.5 配置日志级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F1"><span class="toc-number">9.4.1.</span> <span class="toc-text">线程创建方式1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F2"><span class="toc-number">9.4.2.</span> <span class="toc-text">线程创建方式2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F2%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.4.3.</span> <span class="toc-text">线程创建方式2—匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F3"><span class="toc-number">9.4.4.</span> <span class="toc-text">线程的创建方式3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-1"><span class="toc-number">10.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">多线程常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0"><span class="toc-number">10.2.1.</span> <span class="toc-text">线程安全问题概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">10.2.2.</span> <span class="toc-text">线程安全问题的代码演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-number">10.2.3.</span> <span class="toc-text">线程同步方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">10.2.4.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.5.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E9%94%81"><span class="toc-number">10.2.6.</span> <span class="toc-text">Lock锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">线程通信（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.4.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0"><span class="toc-number">10.4.1.</span> <span class="toc-text">线程池概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.4.2.</span> <span class="toc-text">创建线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8CRunnable%E4%BB%BB%E5%8A%A1"><span class="toc-number">10.4.3.</span> <span class="toc-text">线程池执行Runnable任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8CCallable%E4%BB%BB%E5%8A%A1"><span class="toc-number">10.4.4.</span> <span class="toc-text">线程池执行Callable任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88Executors%EF%BC%89"><span class="toc-number">10.4.5.</span> <span class="toc-text">线程池工具类（Executors）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="toc-number">10.5.</span> <span class="toc-text">补充知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">10.5.1.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.5.2.</span> <span class="toc-text">线程的生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text">网络编程概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">11.2.</span> <span class="toc-text">网络编程三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">11.2.1.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-number">11.2.2.</span> <span class="toc-text">InetAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">11.2.3.</span> <span class="toc-text">端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.2.4.</span> <span class="toc-text">协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81%EF%BC%88%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">UDP通信代码（入门案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.3.1.</span> <span class="toc-text">客户端程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.3.2.</span> <span class="toc-text">服务端程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1%E4%BB%A3%E7%A0%81%EF%BC%88%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6%EF%BC%89"><span class="toc-number">11.4.</span> <span class="toc-text">UDP通信代码（多发多收）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F-1"><span class="toc-number">11.4.1.</span> <span class="toc-text">客户端程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F-1"><span class="toc-number">11.4.2.</span> <span class="toc-text">服务端程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%E5%8F%91%E4%B8%80%E6%94%B6%EF%BC%89"><span class="toc-number">11.5.</span> <span class="toc-text">TCP通信（一发一收）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">11.5.1.</span> <span class="toc-text">TCP客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">11.5.2.</span> <span class="toc-text">TCP服务端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%EF%BC%88%E5%A4%9A%E5%8F%91%E5%A4%9A%E6%94%B6%EF%BC%89"><span class="toc-number">11.6.</span> <span class="toc-text">TCP通信（多发多收）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">11.6.1.</span> <span class="toc-text">6.1 TCP客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-number">11.6.2.</span> <span class="toc-text">TCP服务端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%B9%E8%BF%9B%EF%BC%89"><span class="toc-number">11.7.</span> <span class="toc-text">TCP通信（多线程改进）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%B9%E8%BF%9B"><span class="toc-number">11.7.1.</span> <span class="toc-text">多线程改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%8B%93%E5%B1%95%EF%BC%88%E7%BE%A4%E8%81%8A%EF%BC%89"><span class="toc-number">11.7.2.</span> <span class="toc-text">案例拓展（群聊）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BS%E6%9E%B6%E6%9E%84%E7%A8%8B%E5%BA%8F%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89"><span class="toc-number">11.8.</span> <span class="toc-text">BS架构程序（简易版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F-2"><span class="toc-number">11.8.1.</span> <span class="toc-text">服务端程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BB%E7%A8%8B%E5%BA%8F%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%94%B9%E8%BF%9B"><span class="toc-number">11.8.2.</span> <span class="toc-text">服务端主程序用线程池改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-number">12.</span> <span class="toc-text">单元测试、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">12.1.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">12.1.1.</span> <span class="toc-text">单元测试快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%AD%E8%A8%80"><span class="toc-number">12.1.2.</span> <span class="toc-text">单元测试断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Junit%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.1.3.</span> <span class="toc-text">Junit框架的常用注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">12.2.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">12.2.1.</span> <span class="toc-text">获取类的字节码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">12.2.2.</span> <span class="toc-text">获取类的构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.2.3.</span> <span class="toc-text">反射获取构造器的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.4.</span> <span class="toc-text">反射获取成员变量&amp;使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.5.</span> <span class="toc-text">反射获取成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">12.2.6.</span> <span class="toc-text">反射的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.3.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%B3%A8%E8%A7%A3-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.3.1.</span> <span class="toc-text">认识注解&amp;定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.3.2.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.3.3.</span> <span class="toc-text">解析注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.3.4.</span> <span class="toc-text">注解的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">12.4.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%8B%E7%BB%8D%E3%80%81%E5%87%86%E5%A4%87%E5%8A%9F%E8%83%BD"><span class="toc-number">12.4.1.</span> <span class="toc-text">动态代理介绍、准备功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.4.2.</span> <span class="toc-text">生成动态代理对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BA%94%E7%94%A8"><span class="toc-number">12.4.3.</span> <span class="toc-text">动态代理应用</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2024 By <a class="footer-bar-link" href="/" title="Smith" target="_blank">Smith</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/Smithhss/smithhs.github.io.git" title="Hexo">Hexo</a></div></div></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">55</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8805965276" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=464586318&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.6/translate/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.14/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script>var meting_api = "https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("07/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.5.3",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Smith 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";</script><script>//动态标题
let leaveTitle = '再看看嘛🌈！';
let backTitle = '欢迎回来✌️！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/waterfall.js/1.1.0/waterfall.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | Smith")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {if (typeof addFriendLinksInFooter === "function") {addFriendLinksInFooter();}}, 200)</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div></body></html>