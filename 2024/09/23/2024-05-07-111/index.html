<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Smith | Smith</title><meta name="author" content="Smith"><meta name="copyright" content="Smith"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Smith"><meta name="application-name" content="Smith"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Smith"><meta property="og:url" content="https://smithhs.cn/2024/09/23/2024-05-07-111/index.html"><meta property="og:site_name" content="Smith"><meta property="og:description" content="3.2.2 字符填充的首尾定界符法​  3.2.4 违规编码法​  3.3 差错控制​  3.3.1 检错编码​  3.4 流量控制与可靠传输机制3.4.1 滑动窗口机制 发送窗口：在任意时刻，发送方都维持一组连续的允许发送的帧的序号。  发送窗口用来对发送方进行流量控制，而发送窗口的大小WT，代表"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><meta property="article:author" content="Smith"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://smithhs.cn/2024/09/23/2024-05-07-111/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.14/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":240},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Smith',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-14 20:25:52',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>if (GLOBAL_CONFIG.preloader.source == "2" || GLOBAL_CONFIG.preloader.source == "3") {
  const loadingPercentage = document.getElementById("loading-percentage");
  let loadingPercentageTimer = setInterval(function() {
    var progressBar = document.querySelector(".pace-progress");
    if (!progressBar) return
    var currentValue = progressBar.getAttribute("data-progress-text");
    if (currentValue !== loadingPercentage.textContent) {
      loadingPercentage.textContent = currentValue;
      if (currentValue === "100%") {
        clearInterval(loadingPercentageTimer);
      }
    }
  }, 100);
}

const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://smithhs.cn/" title="博客" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="http://robot.onliu.cn/" title="Robot" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cupfox.png" alt="Robot"/><span class="back-menu-item-text">Robot</span></a><a class="back-menu-item" href="http://res.onliu.cn" title="Sale" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alandodo-1315761622.cos.ap-beijing.myqcloud.com/blog-tuce/tubiao.jpg" alt="Sale"/><span class="back-menu-item-text">Sale</span></a><a class="back-menu-item" href="http://se.onliu.cn/" title="资源共享" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://alandodo-1315761622.cos.ap-beijing.myqcloud.com/blog/x126.png" alt="资源共享"/><span class="back-menu-item-text">资源共享</span></a><a class="back-menu-item" href="https://github.com/Smithhss" title="Github" target="_blank"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/GitHub.png" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Smith</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/App/" style="font-size: 1.05rem;">App<sup>2</sup></a><a href="/tags/Butterfly/" style="font-size: 1.05rem;">Butterfly<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/Cisco-Packet-Tracer/" style="font-size: 1.05rem;">Cisco Packet Tracer<sup>1</sup></a><a href="/tags/Easypan/" style="font-size: 1.05rem;">Easypan<sup>2</sup></a><a href="/tags/FurtherMathematics/" style="font-size: 1.05rem;">FurtherMathematics<sup>1</sup></a><a href="/tags/GPT/" style="font-size: 1.05rem;">GPT<sup>1</sup></a><a href="/tags/Git2/" style="font-size: 1.05rem;">Git2<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/JavaWeb/" style="font-size: 1.05rem;">JavaWeb<sup>2</sup></a><a href="/tags/Jrebel/" style="font-size: 1.05rem;">Jrebel<sup>1</sup></a><a href="/tags/LeetCode/" style="font-size: 1.05rem;">LeetCode<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>2</sup></a><a href="/tags/Markdown/" style="font-size: 1.05rem;">Markdown<sup>2</sup></a><a href="/tags/Maven/" style="font-size: 1.05rem;">Maven<sup>2</sup></a><a href="/tags/Mysql/" style="font-size: 1.05rem;">Mysql<sup>1</sup></a><a href="/tags/NoSql/" style="font-size: 1.05rem;">NoSql<sup>1</sup></a><a href="/tags/Nodejs/" style="font-size: 1.05rem;">Nodejs<sup>2</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>3</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>2</sup></a><a href="/tags/VMware/" style="font-size: 1.05rem;">VMware<sup>2</sup></a><a href="/tags/Vue/" style="font-size: 1.05rem;">Vue<sup>1</sup></a><a href="/tags/WeChat/" style="font-size: 1.05rem;">WeChat<sup>1</sup></a><a href="/tags/YouHou/" style="font-size: 1.05rem;">YouHou<sup>1</sup></a><a href="/tags/books/" style="font-size: 1.05rem;">books<sup>1</sup></a><a href="/tags/butterfly/" style="font-size: 1.05rem;">butterfly<sup>1</sup></a><a href="/tags/clash/" style="font-size: 1.05rem;">clash<sup>1</sup></a><a href="/tags/project/" style="font-size: 1.05rem;">project<sup>4</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/" style="font-size: 1.05rem;">开发框架<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" style="font-size: 1.05rem;">开发环境<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">数据结构与算法<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 1.05rem;">软件工程<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">17</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time datetime="2024-09-23T03:54:38.722Z" title="发表于 2024-09-23 11:54:38">2024-09-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">58.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>195分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为石家庄"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>石家庄</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h5 id="3-2-2-字符填充的首尾定界符法"><a href="#3-2-2-字符填充的首尾定界符法" class="headerlink" title="3.2.2 字符填充的首尾定界符法"></a>3.2.2 字符填充的首尾定界符法</h5><p>​ </p>
<h5 id="3-2-4-违规编码法"><a href="#3-2-4-违规编码法" class="headerlink" title="3.2.4 违规编码法"></a>3.2.4 违规编码法</h5><p>​ </p>
<h4 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h4><p>​ </p>
<h5 id="3-3-1-检错编码"><a href="#3-3-1-检错编码" class="headerlink" title="3.3.1 检错编码"></a>3.3.1 检错编码</h5><p>​ </p>
<h4 id="3-4-流量控制与可靠传输机制"><a href="#3-4-流量控制与可靠传输机制" class="headerlink" title="3.4 流量控制与可靠传输机制"></a>3.4 流量控制与可靠传输机制</h4><h5 id="3-4-1-滑动窗口机制"><a href="#3-4-1-滑动窗口机制" class="headerlink" title="3.4.1 滑动窗口机制"></a>3.4.1 滑动窗口机制</h5><ul>
<li><p>发送窗口：在任意时刻，发送方都维持一组连续的允许发送的帧的序号。</p>
<ul>
<li>发送窗口用来对发送方进行流量控制，而发送窗口的大小WT，代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C85dd69ed8258a66378818b20985cfb50pngpic_center.jpg" alt="image-20230814175558669"></p>
</li>
<li><p>接收窗口：接收方也维持一组连续的允许接收帧的序号。</p>
<ul>
<li>接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。</li>
<li>在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。</li>
<li>若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cdbd72c7c3d1df85a59eb74085b7d44e3pngpic_center.jpg" alt="image-20230814175636711"></p>
</li>
</ul>
<p><strong>滑动窗口特性：</strong></p>
<ul>
<li>只有接收窗口向前滑动（同时接收方发送了确认帧）时，发送窗口才有可能（只有发送方收到确认帧后才一定）向前滑动。</li>
<li>从滑动窗口的概念看，停止-等待协议、后退N帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别：<ul>
<li>停止-等待协议：发送窗口大小&#x3D;1，接收窗口大小&#x3D;1。</li>
<li>后退N帧协议：发送窗口大小&gt;1，接收窗口大小&#x3D;1。</li>
<li>选择重传协议：</li>
</ul>
</li>
<li>接收窗口的大小为1时，可保证帧的有序接收。</li>
<li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意与第5章传输层的滑动窗口协议的区别）。</li>
</ul>
<p><strong>可靠传输机制</strong>：</p>
<ul>
<li><strong>确认</strong>：确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为<strong>捎带确认</strong>。</li>
<li><strong>超时重传</strong>：超时重传是指发送方在发送某个数据帧后就开启一个<strong>计时器</strong>，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止。</li>
<li><strong>自动重传请求</strong>（Automatic Repeat reQuest, ARQ）：通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一。传统ARQ有三种：停止-等待（Stop-and-Wait） ARQ、 后退 N帧（Go-Back-N）ARQ 和选择性重传（Selective Repeat）ARQ。</li>
</ul>
<blockquote>
<p>在数据链路层中流量控制机制和可靠传输机制是交织在一起的，都由滑动窗口机制解决。</p>
</blockquote>
<h5 id="3-4-2-单帧滑动窗口与停止-等待协议"><a href="#3-4-2-单帧滑动窗口与停止-等待协议" class="headerlink" title="3.4.2 单帧滑动窗口与停止-等待协议"></a>3.4.2 单帧滑动窗口与停止-等待协议</h5><ol>
<li>定义</li>
</ol>
<p>​ 在停止-等待协议中，源站每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cecc67be207bae6623f6ae6d30398f6adpngpic_center.jpg" alt="image-20230815092106246"></p>
<ol start="2">
<li>有差错情况</li>
</ol>
<ul>
<li><p>超时计时器：每次发送一个帧就启动一个计时，超时计时器设置的重传时间应当<strong>比帧传输的平均RTT更长</strong>。</p>
<ul>
<li>发完一个帧后，必须保留它的副本。</li>
<li>发送的帧交替地用0和1来标识，确认帧分别用ACK0和ACK1来表示，收到的确认帧有误时，重传已发送的帧。</li>
</ul>
</li>
<li><p>发送失败的三种情况：</p>
<ul>
<li>数据帧丢失或检测到帧出错：数据帧丢失时，或者接收方检测到数据帧有错，不返回ACK，超时重传。</li>
<li>ACK丢失：接收方接收到数据帧，返回ACK时丢失，发送方超时重传。</li>
<li>ACK迟到：接收方收到数据帧后，返回ACK0，但是ACK到达时间超过重传时间，发送方重新发送数据，接收到ACK0时丢失，因为此刻等待ACK1的接收。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C5040a8b4acf2aa0c3bbf63bf4ad685b6pngpic_center.jpg" alt="image-20230815122833126"></p>
</li>
</ul>
<ol start="3">
<li>性能分析</li>
</ol>
<p>​ 由于要花费大量时间等待ack确认，信道利用率太低。<br>信道利用率 U &#x3D; T D T D + R T T + T A 信道利用率U&#x3D;\frac {T_D} {T_D+RTT+T_A} 信道利用率U=TD​+RTT+TA​TD​​<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C5c6faebf70936981b30fa9e809124413pngpic_center.jpg" alt="image-20230815094310472"></p>
<h5 id="3-4-3-多帧滑动窗口与后退N帧协议（GBN）"><a href="#3-4-3-多帧滑动窗口与后退N帧协议（GBN）" class="headerlink" title="3.4.3 多帧滑动窗口与后退N帧协议（GBN）"></a>3.4.3 多帧滑动窗口与后退N帧协议（GBN）</h5><p>​ 在后退N帧式ARQ中，发送方无须在收到上一个帧的ACK后才能开始发送下一帧，而是可以连续发送帧。</p>
<p>​ 发送窗口大小&gt;1，接收窗口大小&#x3D;1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Ceda9159e6194009a68ab1cc48e6f5686pngpic_center.jpg" alt="image-20230815101525038"></p>
<ol>
<li><p>发送方</p>
<ul>
<li>上层的调用：上层要发送数据时，发送方先检查发送窗口是否己满，如果未满，则产生一个带序号的帧并将其发送；如果窗口已满发送方可以缓存这些数据，窗口不满时再发送帧。</li>
<li>收到了一个ACK：GBN协议中，对n号帧的确认采用累积确认的方式，标明接收方已经收到n号帧和它之前的全部帧。</li>
<li>超时事件：协议的名字为后退N帧&#x2F;回退N帧，来源于出现<strong>丢失和时延过长帧</strong>时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有己发送但未被确认的帧。</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li><p>如果正确按序收到n号帧，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。</p>
</li>
<li><p>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。</p>
<p>接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum（下一个按序接收的帧序号）。</p>
</li>
</ul>
</li>
<li><p>窗口大小</p>
<p>接收窗口为1，可以保证按序接收数据帧。</p>
<p>若采用n比特对帧编号，则其发送窗口的尺寸WT应满足 1 ＜ W T ≤ 2 n − 1 1＜W_T≤2^n-1 1＜WT​≤2n−1。若发送窗口大于 2 n − 1 2^n-1 2n−1，则会造成接收方无法分辨新帧和旧帧。</p>
</li>
<li><p>性能分析</p>
<ul>
<li>优点：因连续发送数据帧而提高了信道利用率</li>
<li>缺点：在重传时必须把原来已经正确传送的数据帧重传，是传送效率降低。</li>
</ul>
</li>
</ol>
<p>​ 信道的传输质量很差导致误码率较大时，后退N帧协议不一定优于停止-等待协议。</p>
<h5 id="3-4-4-多帧滑动窗口与选择重传协议（SR）"><a href="#3-4-4-多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="3.4.4 多帧滑动窗口与选择重传协议（SR）"></a>3.4.4 多帧滑动窗口与选择重传协议（SR）</h5><p>​ 为解决GBN会重传正确传送的帧，设法只重传出现差错和超时的数据帧，这需要加大接收窗口，因此提出了选择重传协议。</p>
<p>​ 发送窗口大小&gt;1，接收窗口大小&gt;1。</p>
<ol>
<li><p>发送方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cecfc2b541d2378f3bea8cb6b67f84582png.jpg" alt="image-20230815104723761"></p>
<ul>
<li><p>上层的调用：从上层收到数据后，发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输。</p>
</li>
<li><p>收到了一个ACK：如果收到ACK，假如该帧序号在窗口内，则SR发送方将那个被确认的帧标记为<strong>已接收</strong>。</p>
<p>如果该帧序号是窗口的<strong>下界</strong>（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。</p>
</li>
<li><p>超时事件：<strong>每个帧都有自己的定时器</strong>，一个超时事件发生后只重传一个帧。</p>
</li>
</ul>
</li>
<li><p>接收方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C514f592b666fb9006fe220c62800e8f1png.jpg" alt="image-20230815105104266"></p>
<ul>
<li>来者不拒（窗口内的帧）：SR接收方将确认一个正确接收的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧的确认帧【<strong>收谁确认谁</strong>】，直到<strong>所有帧（即序号更小的帧）皆被收</strong>到为止，这时才可以将一批帧<strong>按序交付给上层</strong>，然后向前移动滑动窗口。</li>
<li>如果收到了**窗口序号外（小于窗口下界）**的帧，就返回一个ACK。其他情况，就忽略该帧。</li>
</ul>
</li>
<li><p>窗口大小</p>
</li>
</ol>
<p>​ 发送窗口尺寸WT和接收窗口尺寸WR都大于1，一次可接收发送多个帧。</p>
<p>​ WT &#x3D; WR时最好，若采用n比特对帧编号，则需满足 W T m a x &#x3D; W R m a x &#x3D; 2 n − 1 W_{Tmax}&#x3D;W_{Rmax}&#x3D;2^{n-1} WTmax​=WRmax​=2n−1，且 W T + W R ≤ 2 n W_T+W_R≤2^n WT​+WR​≤2n。</p>
<p>​ 如果不满足窗口大小大于序号范围一半，当一个或多个确认帧丢失时，发送方就会超时重传之前的数据帧，但接收方无法分辨是新的数据帧还是重传的数据帧。</p>
<ol start="4">
<li><p>性能分析</p>
<ul>
<li><p>信道利用率：也称信道效率，是对发送方而言的，是指发送方在一个发送周期的时间内，有效地发送数据所需要的时间占整个发送周期的比率。发送方从开始发送数据到收到第一个确认帧为止，称为一个发送周期。</p>
<p>设一个发送周期为T，发送周期内共发送L比特的数据，发送方数据传输率为C，则发送方发送有效数据时间为 L &#x2F; C L&#x2F;C L&#x2F;C，信道利用率为 ( L &#x2F; C ) &#x2F; T (L&#x2F;C)&#x2F;T (L&#x2F;C)&#x2F;T。</p>
</li>
<li><p>信道吞吐率： 信道吞吐率 &#x3D; 信道利用率 × 发送方发送速率 信道吞吐率&#x3D;信道利用率×发送方发送速率 信道吞吐率=信道利用率×发送方发送速率</p>
</li>
<li><p>最小帧长： 最小帧长 &#x3D; 2 × 数据传输速率 × 总线传播时延 最小帧长&#x3D;2×数据传输速率×总线传播时延 最小帧长=2×数据传输速率×总线传播时延</p>
</li>
</ul>
</li>
</ol>
<h4 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h4><p>​ 介质访问控制的内容就是，采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制(Medium Access Control, MAC)子层。</p>
<h5 id="3-5-1-信道划分介质访问控制"><a href="#3-5-1-信道划分介质访问控制" class="headerlink" title="3.5.1 信道划分介质访问控制"></a>3.5.1 信道划分介质访问控制</h5><p>​ <strong>信道划分介质访问控制</strong>是将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。通常采用多路复用技术，把多个输入通道的信息整合到一个复用通道中，在接收端把收到的信息分离。</p>
<ol>
<li><p>频分多路复用（FDM）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C6a804292331066ed8d0cc6acdd5b2d65pngpic_center.jpg" alt="image-20230815114754984"></p>
<p>​ 用户在相同时间占用不同频率带宽资源。每个子信道分配的带宽可不相同，但它们的总和必须不超过信道的总带宽。在实际应用中为了防止子信道之间的干扰，相邻信道之间需要加入“保护频带”。共享时间。</p>
</li>
<li><p>时分多路复用（TDM）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cad2100389833ca5471c3d548de1c0b0epngpic_center.jpg" alt="image-20230815114926548"></p>
<p>​ 每一个时分复用的用户在每一个TDM帧占用<strong>固定序号的时隙</strong>，所有用户轮流占用信道。</p>
<p>​ 不会发生碰撞，TDM帧是在物理层传送的比特流所划分的帧，标志一个周期。共享空间。</p>
<ul>
<li><p>统计时分多路复用（STDM）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C8b3a5aec67945722c87f562d27b5be94png.jpg" alt="image-20230815115246126"></p>
<p>每一个STDM帧中的<strong>时隙数</strong>小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器<strong>按顺序依次扫描</strong>输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。STDM帧不是固定分配时隙，而是<strong>按需动态分配时隙</strong>。</p>
</li>
</ul>
</li>
<li><p>波分多路复用（WDM）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cc6ea0a85f3e152eb155cc0ba2725825dpngpic_center.jpg" alt="image-20230815115441883"></p>
<p>波分多路复用就是光的频分多路复用，在<strong>一根光纤</strong>中传输<strong>多种不同波长（频率）的光信号</strong>，由于波长（频率）不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p>
</li>
<li><p>码分多路复用（CDM）</p>
<p>码分多路复用是靠不同的编码来区分各路原始信号的一种复用方式。<strong>既共享信道的频率，又共享时间</strong>。</p>
<p><strong>码分多址（CDMA）</strong>：每个比特时间再划分成m个短的时间槽，称为码片(Chip)，通常m的值是64或128。每个站点指派m位码片序列，发送1时发原码，0时发反码。各个站点码片序列<strong>相互正交</strong>。</p>
<blockquote>
<p>CDMA原理：</p>
<p>假如站点A的码片序列被指派为00011011，则A站发送00011011就表示发送比特1，发送11100100就表示发送比特0。为了方便，按惯例将码片中的0写为-1，将1写为+1，因此A站的码片序列是-1-1-1+1+1-1+1+1。</p>
<p>令向量S表示A站的码片向量，令T表示B站的码片向量。两个不同站的码片序列正交，即向量S和T的规格化内积（Inner Product）为0：<br>S ⋅ T &#x3D; 1 m ∑ i &#x3D; 1 m S i T i &#x3D; 0 S·T&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^{m} {S_iT_i}&#x3D;0 S⋅T=m1​i=1∑m​Si​Ti​=0<br>任何一个码片向量和该码片向量自身的规格化内积都是1，任何一个码片向量和该码片反码的向量的规格化内积是-1</p>
<p>例：A站码片00011011、B站码片00101110；此时A、B站向量相乘内积为0。</p>
<p>当A站向C站发送数据1时，就发送了向量（-1-1-1+1+1-1+1+1）。</p>
<p>当B站向C站发送数据0时，就发送了向量（+1+1-1+1-1-1-1+1）。</p>
<p>两个向量到了公共信道上就进行叠加，实际上就是线性相加，得到S+T&#x3D;(0 0 -2 2 0 -2 0 2)</p>
<p>到达C站后，想获得A站数据，就与A站码片S内积化， S ⋅ ( S + T ) &#x3D; 1 S·(S+T)&#x3D;1 S⋅(S+T)=1，所以A站数据是1；同理， T ⋅ ( S + T ) &#x3D; − 1 T·(S+T)&#x3D;-1 T⋅(S+T)=−1，所以B站发过来的向量是个反码向量，代表0。</p>
</blockquote>
</li>
</ol>
<h5 id="3-5-2-随机访问介质访问控制"><a href="#3-5-2-随机访问介质访问控制" class="headerlink" title="3.5.2 随机访问介质访问控制"></a>3.5.2 随机访问介质访问控制</h5><p>​ 随机访问介质中使用争用型协议 ，胜利者通过争用获得信道，从而获得信息的发送权。将广播信道转化为点到点信道。信道并非在用户通信时固定分配给用户</p>
<ol>
<li><p>ALOHA协议</p>
<ul>
<li><p>纯ALOHA协议</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C840ee86312a876e84b65b95be9127acepng.jpg" alt="image-20230815134438174"></p>
<ul>
<li>思想：不监听信道，不按时间槽发送，随机重发。想发就发</li>
<li>冲突检测：如果发生冲突，接收方在就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突。</li>
<li>冲突解决：超时后<strong>等一随机时间</strong>再重传。</li>
</ul>
</li>
<li><p>时隙ALOHA协议</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C134f65dc237f37739263a6e5fd9d5fc0pngpic_center.jpg" alt="image-20230815134629248"></p>
<ul>
<li>思想：把时间分成<strong>若干个相同的时间片</strong>，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。控制想发就发的随意性。</li>
<li>吞吐量是纯ALOHA协议的两倍。</li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA协议</p>
<p><strong>载波监听多路访问</strong>（CSMA）指的是每个站点在发送前都先监听一下共用信道，发现信道空闲后再发送。</p>
<p>监听：当几个站同时在总线上发送数据时，总线上的信号<strong>电压摆动值将会增大</strong>（互相叠加）。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p>
<ul>
<li><p>1-坚持 CSMA</p>
<p>坚持指的是对于监听信道忙之后的坚持。</p>
<ul>
<li>思想：如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，不必等待。忙则一直监听，直到<strong>空闲马上传输</strong>。如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。</li>
<li>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。</li>
<li>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</li>
</ul>
</li>
<li><p>非坚持CSMA</p>
<p>非坚持指的是对于监听信道忙之后就不继续监听。</p>
<ul>
<li>思想：如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。</li>
<li>优点：采用随机的重发延迟时间可以减少冲突发生的可能性。</li>
<li>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。</li>
</ul>
</li>
<li><p>p-坚持 CSMA</p>
<p>P坚持指的是对于监听信道空闲的处理。</p>
<ul>
<li>思想：如果一个主机要发送消息，那么它先监听信道。空闲则<strong>以p概率直接传输</strong>，不必等待；概<strong>率1-p等待到下一个时间槽再传输</strong>。忙则持续监听直到信道空闲再以p概率发送。若冲突则等到下一个时间槽开始再监听并重复上述过程。</li>
<li>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</li>
<li>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">信道状态</th>
<th align="center">1-坚持</th>
<th align="center">非坚持</th>
<th align="center">p-坚持</th>
</tr>
</thead>
<tbody><tr>
<td align="center">空闲</td>
<td align="center">立即发送数据</td>
<td align="center">立即发送数据</td>
<td align="center">以概率p发送数据</td>
</tr>
<tr>
<td align="center">以概率1-p推迟到下一个时隙</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">忙</td>
<td align="center">继续坚持监听</td>
<td align="center">放弃监听，等待随机的时间后再监听</td>
<td align="center">持续监听，直至信道空闲</td>
</tr>
</tbody></table>
</li>
<li><p>CSMA&#x2F;CD 协议</p>
<p>​ 载波监听多路访问&#x2F;碰撞检测（CSMA&#x2F;CD）协议是CSMA的改进方案，适用于<strong>总线形网络或半双工网络</strong>。</p>
<p>​ <strong>碰撞检测</strong>就是<strong>边发送边监听</strong>，如果 监听到了碰撞，则立即停止数据发送，等待一段随机时间后，重新开始尝试发送数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cb532210d96e7a1c78566be62de7620d0pngpic_center.jpg" alt="image-20230815142904674"></p>
<ul>
<li><p><strong>工作流程</strong>：先听后发，边听边发，冲突停发，随机重发</p>
<p>1）适配器从网络中获得分组，封装成以太帧，缓存等待发送<br>2）适配器侦听信道，空闲则发送，忙则持续监听，直到空闲发送<br>3）发送过程中持续检测信道，若检测到碰撞，停止发连并发送一个拥塞信号<br>4）中止发送后，执行指数退避法确定重传时机</p>
</li>
</ul>
<blockquote>
<p>争议期：两端往返传播时延。只要经过2τ（传播时延）时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞。</p>
<p>最小帧长&#x3D;总线传播时延×数据传输速率×2</p>
<p>以太网规定取51.2μs为争用期的长度。对于10Mb&#x2F;s的以太网，在争用期内可发送512bit，即64B。</p>
<p>如果只发送小于64B的帧，如40B的帧，那么需要在MAC子层中于数据字段的后面加入一个整数字节的填充字段，以保证以太网的MAC帧的长度不小于64B。</p>
</blockquote>
<ul>
<li><p><strong>截断二进制指数规避算法</strong>:</p>
<p>1.确定基本退避（推迟）时间为争用期2τ。</p>
<p>2.定义参数k，它等于<strong>重传次数</strong>，但k不超过10，即k&#x3D;min[重传次数,10]。</p>
<p>3.从离散的整数集合[0,1…2k-1]中随机取出一个数r, 重传所需要退避的时间就是<strong>r倍基本退避时间</strong>，即2rτ。</p>
<p>4.当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报错。</p>
<p>使用截断二进制指数退避算法可使重传需要推迟的平均时间随重传次数的增大而增大（这也称动态退避），因而能降低发生碰撞的概率，有利于整个系统的稳定。</p>
</li>
</ul>
</li>
<li><p>CSMA&#x2F;CA协议</p>
<p>CSMA&#x2F;CD协议无法用于无线局域网，因为其无法做到360°全面检测碰撞。会出现<strong>隐蔽站</strong>问题。</p>
<p><strong>隐蔽站</strong>：当A和C都检测不到信号，认为信道空闲时，同时向终端B发送数据帧，就会导致冲突。</p>
<p><strong>载波监听多路访问&#x2F;碰撞避免</strong>（CSMA&#x2F;CA）：协议的设计要尽量降低碰撞发生的概率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C525bb84129f21abba9c40b1c4dddcf16pngpic_center.jpg" alt="image-20230815144613729"></p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<p>1）发送数据前，先检测信道是否空闲。<br>2）空闲则发出<strong>RTS（request to send）</strong>，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。<br>3）接收端收到RTS后，将响应<strong>CTS（clear to send）</strong>。CTS帧 ①给源站明确的发送许可；②指示其他站点在预约期内不要发送。<br>4）发送端收到CTS后，开始发送数据帧（同时<strong>预约信道</strong>：发送方告知其他站点自己要传多久数据）。<br>5）接收端收到数据帧后，将用循环冗余码CRC来检验数据是否正确，正确则响应<strong>ACK帧</strong>。<br>6）发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避:算法来确定随机的推迟时间）。</p>
</li>
<li><p><strong>帧间间隔（IFS）</strong>：为了尽量避免碰撞，802.11规定，所有的站完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。</p>
<p>1）SIFS（短IFS）：最短的IFS，用来分隔属于一次对话的各帧，使用SIFS的帧类型有ACK帧、CTS帧、分片后的数据帧，以及所有回答AP探询的帧等。<br>2）PIFS（点协调IFS）：中等长度的IFS，在PCF操作中使用。<br>3）DIFS（分布式协调IFS）：最长的IFS，用于异步帧竞争访问的时延。</p>
</li>
<li><p><strong>CSMA&#x2F;CD与CSMA&#x2F;CA主要有如下区别</strong>：</p>
<p>1.传输介质不同：CSMA&#x2F;CD用于总线式以太网【有线】，而CSMA&#x2F;CA用于无线局域网【无线】。</p>
<p>2.载波检测方式不同：因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。</p>
<p>CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；</p>
<p>而CSMA&#x2F;CA采用能量检测（ED）、载波检测（CS）和能量载波混合检测三种检测信道空闲的方式。</p>
<p>3.CSMA&#x2F;CD检测冲突，CSMA&#x2F;CA避免冲突，二者出现冲突后都会进行有上限的重传。</p>
</li>
</ul>
</li>
</ol>
<h5 id="3-5-3-轮询访问：令牌传递协议"><a href="#3-5-3-轮询访问：令牌传递协议" class="headerlink" title="3.5.3 轮询访问：令牌传递协议"></a>3.5.3 轮询访问：令牌传递协议</h5><p>​ 在轮询访问中，用户不能随机地发送信息，而要通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。</p>
<p>​ <strong>令牌传递协议</strong>：每个结点都可以在一定的时间内（令牌持有时间）获得发送数据的权利，并不是无限制地持有令牌。主要用在令牌环局域网（物理星型拓扑，逻辑环形拓扑）。</p>
<p>​ 令牌：一个特殊的MAC控制帧，它不包含信息，仅控制信道的使用，确保同一时刻只有一个站点独占信道。</p>
<ul>
<li><p><strong>传递过程</strong>：</p>
<p>1）网络空闲时，环路中只有令牌帧在循环传递<br>2）令牌传递到有数据要发送的站点时，该站点就修改令牌中的一个标志位，并在令牌中附加自己需要传输的数据，将令牌变成一个数据帧，然后将这个数据帧发送出去<br>3）数据帧沿着环路传输，接收到的站点一边转发数据，一边查看帧的目的地址。如果目的地址和自己的地址相同，那么接收站就复制该数据帧以便进一步处理。<br>4）数据帧沿着环路传输，直到到达该帧的源站点，源站点收到自己发出去的帧后便不再转发。同时，通过检验返回的帧来查看数据传输过程中是否出错，若有错则重传。<br>5）源站点传送完数据后，重新产生一个令牌，并传递给下一站点，以交出信道控制权。</p>
</li>
<li><p>应用：采用令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中。</p>
</li>
</ul>
<h4 id="3-6-局域网"><a href="#3-6-局域网" class="headerlink" title="3.6 局域网"></a>3.6 局域网</h4><h5 id="3-6-1-局域网的基本概念和体系结构"><a href="#3-6-1-局域网的基本概念和体系结构" class="headerlink" title="3.6.1 局域网的基本概念和体系结构"></a>3.6.1 局域网的基本概念和体系结构</h5><p>​ 局域网（LAN）指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<ol>
<li><p>特点</p>
<ul>
<li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li>
<li>使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb&#x2F;s~10Gb&#x2F;s）。</li>
<li>通信延迟时间短，误码率低，可靠性较高。</li>
<li>各站为平等关系，共享传输信道。</li>
<li>多采用分布式控制和广播式通信，能进行广播和组播。</li>
</ul>
</li>
<li><p>局域网拓扑结构</p>
<p>①星形结构；②环形结构；③总线形结构；④星形和总线形结合的复合型结构。</p>
</li>
<li><p>传输介质</p>
<p>局域网可以使用双绞线、铜缆和光纤等多种传输介质，其中双绞线为主流传输介质。</p>
</li>
<li><p>介质访问控制方法</p>
<p>主要有CSMA&#x2F;CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</p>
</li>
<li><p>局域网拓扑</p>
<ul>
<li>以太网（目前使用范围最广的局域网）。逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。</li>
<li>令牌环（Token Ring，IEEE802.5）。逻辑拓扑是环形结构，物理拓扑是星形结构。</li>
<li>FDDI（光纤分布数字接口，EEE802.8）。逻辑拓扑是环形结构，物理拓扑是双环结构。</li>
</ul>
</li>
<li><p>MAC子层和LLC子层</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cc81e54ae7467a451e47f50edce4565d8pngpic_center.jpg" alt="image-20230815152648577"></p>
<ul>
<li><p><strong>LLC子层</strong>：逻辑链路控制子层，负责识别网络层协议，然后对它们进行封装（给帧加序号）。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。</p>
<p>主要功能：建立和释放数据链路层的逻辑连接、提供与高层的接口、差错控制、给帧加序号。与传输媒体无关。</p>
</li>
<li><p><strong>MAC子层</strong>：介质访问控制子层，向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口。</p>
<p>主要功能包括：组帧和拆卸帧、比特传输差错检测、透明传输。</p>
</li>
</ul>
</li>
</ol>
<h5 id="3-6-2-以太网与-IEEE-802-3"><a href="#3-6-2-以太网与-IEEE-802-3" class="headerlink" title="3.6.2 以太网与 IEEE 802.3"></a>3.6.2 以太网与 IEEE 802.3</h5><p>​ <strong>IEEE 802.3标准</strong>是一种基带总线形的局域网标准，它描述物理层和数据链路层的MAC子层的实现方法。</p>
<p>​ <strong>以太网</strong>逻辑上采用<strong>总线形拓扑结构</strong>，物理星型结构，以太网中的所有计算机共享同一条总线，信息以<strong>广播方式</strong>发送。为了保证数据通信的方便性和可靠性，以太网简化了通信流程并使用了 <strong>CSMA&#x2F;CD方</strong>式对总线进行访问控制。</p>
<p>​ ①采用**无连接<strong>的工作方式，不对发送的数据帧编号，也不要求接收方发送确认，即以太网尽最大努力交付数据，提供的是</strong>不可靠服务**，对于差错的纠正则由高层完成；</p>
<p>​ ②发送的数据都使用<strong>曼彻斯特编码</strong>的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来。</p>
<ol>
<li>以太网的传输介质与网卡</li>
</ol>
<p>​ 以太网采用10BASE-T网络，采用的是无屏蔽双绞线（UTP），传输速率是10Mb&#x2F;s。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">10BASE5</th>
<th align="center">10BASE2</th>
<th align="center">10BASE-T</th>
<th align="center">10BASE-FL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">传输媒体</td>
<td align="center">基带同轴电缆（粗缆）</td>
<td align="center">基带同轴电缆（细缆）</td>
<td align="center">非屏蔽双绞线</td>
<td align="center">光纤对（850nm）</td>
</tr>
<tr>
<td align="center">编码</td>
<td align="center">曼彻斯特编码</td>
<td align="center">曼彻斯特编码</td>
<td align="center">曼彻斯特编码</td>
<td align="center">曼彻斯特编码</td>
</tr>
<tr>
<td align="center">拓扑结构</td>
<td align="center">总线形</td>
<td align="center">总线形</td>
<td align="center">星形</td>
<td align="center">点对点</td>
</tr>
<tr>
<td align="center">最大段长</td>
<td align="center">500m</td>
<td align="center">185m</td>
<td align="center">100m</td>
<td align="center">2000m</td>
</tr>
<tr>
<td align="center">最多结点数目</td>
<td align="center">100</td>
<td align="center">30</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>​ 计算机与外界局域网的连接是通过<strong>网卡</strong>（网络适配器，又称网络接口板&#x2F;卡）实现的。网卡上装有<strong>处理器和存储器</strong>，是工作在<strong>数据链路层</strong>的网络组件。网卡和<strong>局域网的通信</strong>是通过<strong>电缆或双绞线</strong>以<strong>串行</strong>方式进行的，而网卡和<strong>计算机的通信</strong>则是通过计算机主板上的<strong>I&#x2F;O总线</strong>以<strong>并行</strong>方式进行的。网卡的重要功能就是进行<strong>数据的串并转换</strong>。</p>
<p>​ <strong>MAC地址</strong>：介质访问控制（MAC）地址，每块网卡在出厂时的唯一代码，用于控制主机在网络上的数据通信。数据链路层设备（网桥、交换机等）都使用各个网卡的MAC地址。另外，网卡控制着主机对介质的访问，因此网卡也工作在物理层，因为它只关注比特，而不关注任何地址信息和高层协议信息。</p>
<ol start="2">
<li><p>以太网的MAC帧</p>
<p>​ MAC地址也称<strong>物理地址</strong>，MAC地址长6字节，一般用由连字符（或冒号）分 隔的12个十六进制数表示，如 06 − E A − 56 − 3 B − 4 F − 4 D 06-EA-56-3B-4F-4D 06−EA−56−3B−4F−4D。高24位为厂商代码，低24位为厂商自行分配 的网卡序列号。</p>
<p>​ 以太网MAC帧格式有两种标准：DIX Ethernet V2标准（即以太网V2标准）和IEEE 802.3 标准。这里先介绍最常用的以太网V2的MAC帧格式，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C667f8a6756c4151453eda3f4c3260667pngpic_center.jpg" alt="image-20230815155854188"></p>
</li>
</ol>
<ul>
<li>前导码：使接收端与发送端时钟同步。在帧前面插入的8字节可再分为两个字段：第一个字段共7字节，是<strong>前同步码</strong>，用来快速实现MAC帧的比特同步；第二个字段是<strong>帧开始定界符</strong>，表示后面的信息就是MAC帧。</li>
<li>地址：通常使用6字节（48bit）地址（MAC地址）。</li>
<li>类型：2字节，指出数据域中携带的数据应交给哪个协议实体处理。</li>
<li>数据：46<del>1500字节，包含高层的协议消息。由于CSMA&#x2F;CD算法的限制，以太网帧必须满足最小长度要求64字节，数据较少时必须加以填充（0</del>46字节）。</li>
</ul>
<blockquote>
<p>注意：46是怎么来的？由CSMA&#x2F;CD可知以太网帧的最短顿长为64B，而MAC帧的首部和尾部的长度为18字节，所以数据字段最短为64-18&#x3D;46字节。最大的1500字节是规定的。</p>
</blockquote>
<ul>
<li>填充：0~46字节，当帧长太短时填充帧，使之达到64字节的最小长度。</li>
<li>校验码（FCS）：4字节，校验范围从目的地址段到数据段的末尾，算法采用32位循环冗余码（CRC），不但需要检验MAC帧的数据部分，还要检验目的地址、源地址和类型字段，但<strong>不校验前导码</strong>。</li>
</ul>
<p>​ 802.3帧格式与DIX以太帧格式的不同之处在于用长度域替代了 DIX帧中的类型域，指出数据域的长度。</p>
<ol start="3">
<li><p>高速以太网</p>
<p>速率≥100Mb&#x2F;s的以太网称为高速以太网。</p>
<ul>
<li><p>100BASE-T 以太网</p>
<p>在双绞线上传送100Mb&#x2F;s基带信号的星型拓扑以太网，仍使用IEEE802.3的CSMA&#x2F;CD协议。</p>
<p>支持全双工和半双工，可在全双工方式下工作而无冲突。</p>
</li>
<li><p>吉比特以太网</p>
<p>在光纤或双绞线上传送1Gb&#x2F;s信号。</p>
<p>支持全双工和半双工，可在全双工方式下工作而无冲突。</p>
</li>
<li><p>10吉比特以太网</p>
<p>10吉比特以太网在光纤上传送10Gb&#x2F;s信号。</p>
<p><strong>只支持全双工</strong>，无争用问题。</p>
</li>
</ul>
</li>
</ol>
<h5 id="3-6-3-IEEE-802-11无线局域网"><a href="#3-6-3-IEEE-802-11无线局域网" class="headerlink" title="3.6.3 IEEE 802.11无线局域网"></a>3.6.3 IEEE 802.11无线局域网</h5><ol>
<li><p>无线局域网的组成</p>
<p>1）<strong>有固定基础设施无线局域网</strong></p>
<p>​ 802.11使用星形拓扑，其中心称为<strong>接入点</strong>(Access Point, AP)，在MAC层使用CSMA&#x2F;CA协议。使用802.11系列协议的局域网又称Wi-Fi。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C95502f65451c2c9539b63489ee3a7ab6pngpic_center.jpg" alt="image-20230815161549000"></p>
<p>​ 无线局域网的最小构件是<strong>基本服务集BSS</strong> (Basic Service Set, BSS)。一个基本服务集包括一个接入点和若干移动站。各站在本BSS内之间的通信，或与本BSS外部站的通 信，都必须通过本BSS的AP。</p>
<p>​ AP就是基本服务集中的<strong>基站</strong>(base station)。安装AP时，必须为该AP分配一个不超过32字节的<strong>服务集标识符</strong>(Service Set IDentifier, SSID)和一个信道。SSID是指使用该AP的无线局域网的名字。</p>
<p>​ 一个基本服务集覆盖的地理范围称为一个<strong>基本服务区</strong>（Basic Service Area，BSA），无线局域网的基本服务区的范围直径一般不超过100m。</p>
<p>​ 一个基本服务集可以是孤立的，也可通过AP连接到一个<strong>分配系统</strong>(Distribution System, DS)，然后再连接到另一个基本服务集，就构成了一个<strong>扩展的服务集</strong>(Extended Service Set, ESS)。</p>
<p>​ ESS还可以通过一种称为 <strong>Porta</strong>l (门户)的设备为无线用户提供到有线连接的以太网的接入。门户的作用相当于一个网桥。</p>
<p>​ 移动站A如果要和另一个基本服务集中的移动站B通信，就必须经过两个接入点AP1和AP2，即A→AP1→AP2→B，注意AP，到AP2的通信是使用有线传输的。</p>
<p>2）<strong>无固定基础设施移动自组织网络</strong></p>
<p>​ 另一种无线局域网是无固定基础设施的无线局域网，又称<strong>自组网络</strong>（ad hoc network）。自组网络没有上述基本服务集中的AP，而是由一些平等状态的移动站相互通信组成的临时网络。各结点之间地位平等，中间结点都为转发结点，因此都具有路由器的功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Ca979b3db986cb38208c971b322e3daacpngpic_center.jpg" alt="image-20230815163416468"></p>
</li>
<li><p>802.11局域网的MAC帧</p>
</li>
</ol>
<p>​ 802.11帧共有三种类型，即数据帧、控制帧和管理帧。</p>
<ul>
<li><p>数据帧</p>
<p>1）MAC首部，共30字节。帧的复杂性都在MAC首部。<br>2）帧主体，即帧的数据部分，不超过2312字节。它比以太网的最大长度长很多。<br>3）帧检验序列FCS是尾部，共4字节。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C0455f9ca81d66c170dd75dec951e975apngpic_center.jpg" alt="image-20230815175801593"></p>
<p>​ 其中帧控制的去往AP和来自AP决定着地址内容，具体如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">去往AP</th>
<th align="center">来自AP</th>
<th align="center">地址1</th>
<th align="center">地址2</th>
<th align="center">地址3</th>
<th align="center">地址4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">接收地址&#x3D;目的地址</td>
<td align="center">发送地址&#x3D;AP地址</td>
<td align="center">源地址</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">接收地址&#x3D;AP地址</td>
<td align="center">发送地址&#x3D;源地址</td>
<td align="center">目的地址</td>
<td align="center">——</td>
</tr>
</tbody></table>
<p>​ 地址1是直接接收数据帧的结点地址，地址2是实际发送数据帧的结点地址。</p>
<h5 id="3-6-4-VLAN基本概念与基本原理"><a href="#3-6-4-VLAN基本概念与基本原理" class="headerlink" title="3.6.4 VLAN基本概念与基本原理"></a>3.6.4 VLAN基本概念与基本原理</h5><p>​ 虚拟局域网（VLAN）可以把一个较大的局域网分割成一些较小的与地理位置无关，逻辑上的VLAN，而每个VLAN是一个较小的广播域。VLAN分割了广播域。</p>
<p>​ 802.3ac标准定义了支持VLAN的以太网帧格式的扩展，称为<strong>802.1Q帧</strong>。它在以太网帧中插入一个4字节的标识符（插入在源地址字段和类型字段之间），称为VLAN标签，用来指明发送该帧的计算机属于哪个虚拟局域网。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C8437524111095a95877142e0e33f40b9pngpic_center.jpg" alt="image-20230816100549650"></p>
<p>​ VLAN标签的前两个字节置为0x8100，表示这是一个802.1Q帧。在VLAN标签的后两个字节中，前4位没有用，后12位是该<strong>VLAN的标识符VID</strong>，它唯一标识了该802.1Q帧属于哪个VLAN。</p>
<p>​ VID的<strong>取值范围</strong>为0<del>4095，但0和4095都不用来表示VLAN，因此用于表示VLAN的有效VID取值范围为1</del>4094。12位的VID可识别4096个不同的VLAN。插入VID后，802.1Q帧的<strong>FCS必须重新计算</strong>。</p>
<p>​ IEEE 802.1Q帧是由交换机来处理的，而不是由用户主机来处理的。（即主机和交换机之间只交换普通的以太网帧）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C1bd0caceee42cc875bf7fabb0ea2dd2bpngpic_center.jpg" alt="image-20230816102619901"></p>
<p>​ 如上图所示，交换机1连接了7台计算机，该局域网划分为<strong>两个虚拟局域网</strong>VLAN 10和VLAN 20，其中10和20是管理员分配的VID。主机不知道自己的VID，交换机知道所有的VID，主机与交换机用以太网帧交互。VLAN范围可以跨越交换机，交换机1与交换机2相连，并同时连接着两个VLAN。</p>
<p>​ 这两个VLAN虽然都跨越了两个交换机，但<strong>各自都是一个广播域</strong>。</p>
<table>
<thead>
<tr>
<th align="center">发送地址</th>
<th align="center">目的地址</th>
<th align="center">转发路径</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">交换机1查询目的地址接口，识别B属于本交换机管理的同VLAN设备</td>
</tr>
<tr>
<td align="center"><strong>直接转发以太网帧</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">E</td>
<td align="center">交换机1查询目的地址接口，将帧转发到交换机2，并插入VLAN标签</td>
</tr>
<tr>
<td align="center"><strong>交换机之间转发Q帧</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">C</td>
<td align="center">属于不同网络，需要通过路由器或者三层交换机完成转发</td>
</tr>
</tbody></table>
<h4 id="3-7-广域网"><a href="#3-7-广域网" class="headerlink" title="3.7 广域网"></a>3.7 广域网</h4><h5 id="3-7-1-广域网基本概念"><a href="#3-7-1-广域网基本概念" class="headerlink" title="3.7.1 广域网基本概念"></a>3.7.1 广域网基本概念</h5><p>​ 广域网通常是指覆盖范围很广（远超一个城市的范围）的长距离网络。广域网的通信子网主要使用分组交换技术。广域网由一些<strong>结点交换机</strong>（不是路由器）及连接这些交换机的链路组成。结点之间都是点到点连接，但为了提高网络的可靠性，通常一个结点交换机往往与多个结点交换机相连。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C5f781f386013ae168a2100ff122b376fpngpic_center.jpg" alt="image-20230816120701955"></p>
<p>​ 广域网不等于互联网。互联网可以连接不同类型的网络（既可以连接局域网，又可以连接广域网），通常使用路由器来连接。</p>
<p>​ 广域网与局域网有相同有不同，相似点如下：</p>
<ul>
<li>广域网和局域网都是互联网的重要组成构件，从互联网的角度上看，二者平等（不是包含关系）</li>
<li>连接到一个广域网或一个局域网上的主机在该网内进行通信时，只需要使用其网络的物理地址</li>
</ul>
<p>​ 不同点如下所示：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">广域网</th>
<th align="center">局域网</th>
</tr>
</thead>
<tbody><tr>
<td align="center">覆盖范围</td>
<td align="center">很广，通常跨区域</td>
<td align="center">较小，通常在一个区域内</td>
</tr>
<tr>
<td align="center">连接方式</td>
<td align="center">结点之间都是点到点连接，但为了提高网络的可靠性，</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">一个结点交换机往往与多个结点交换机相连</td>
<td align="center">普遍采用多点接入技术</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">OSI参考模型层次</td>
<td align="center">三层：物理层，数据链路层，网络层</td>
<td align="center">两层：物理层，数据链路层</td>
</tr>
<tr>
<td align="center">着重点</td>
<td align="center">强调资源共享</td>
<td align="center">强调数据传输</td>
</tr>
</tbody></table>
<p>​ 广域网中的一个重要问题是路由选择和分组转发。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组是通过转发表进行转发的。</p>
<h5 id="3-7-2-PPP协议"><a href="#3-7-2-PPP协议" class="headerlink" title="3.7.2 PPP协议"></a>3.7.2 PPP协议</h5><p>​ <strong>点对点协议</strong>（Point–to-Point Protocol，PPP）是使用<strong>串行线路通信</strong>的<strong>面向字节</strong>的协议，该协议应用在<strong>直接连接两个结点</strong>的链路上。<strong>不可靠</strong>。</p>
<ol>
<li><p>组成部分</p>
<ul>
<li><strong>链路控制协议（LCP）</strong>。一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</li>
<li><strong>网络控制协议（NCP）</strong>。PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li>
<li><strong>一个将IP数据报封装到串行链路的方法</strong>。P数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元（MTU）的限制。</li>
</ul>
<p>PPP帧格式如图所示，PPP帧前3个字段和最后两个字段与HDLC帧相同。PPP是面向字节的，因 而所有PPP帧的长度都是<strong>整数个字节</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cf9cba4ed4ec5df9561c270d43a48e006pngpic_center.jpg" alt="image-20230816123730025"></p>
<ul>
<li><p>标注字段（F）为7E（01111110），前后各占1字节。</p>
</li>
<li><p>若标注字段出现在信息字段中，就必须做字节填充，使用的控制转义字节是7D （01111101)。</p>
</li>
<li><p>地址字段（A）占1字节，规定为0xFF，</p>
</li>
<li><p>控制字段（C）占1字节，规定为0x03,两者的内容始终是固定不变的。</p>
</li>
<li><p>协议字段占2字节，说明信息段中运载的是什么种类的分组。HDLC无此字段。</p>
</li>
<li><p>信息部分长度可变，大于或等于0且小于或等于1500B。</p>
</li>
<li><p>帧检验序列（FCS），占2字节，即循环冗余码检验中的冗余码。</p>
</li>
</ul>
<blockquote>
<p>因为PPP是，点对点的，并不是总线形，所以无须采用CSMA&#x2F;CD协议，自然就没有最短帧，所以信息段占01500字节，而不是46~1500字节。</p>
</blockquote>
</li>
<li><p>PPP链路建立、使用、撤销</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Caa40f2efebae11d7144f299b188c47dbpngpic_center.jpg" alt="image-20230816131220967"></p>
<ul>
<li>静止：当线路处于静止状态时，不存在物理层连接。</li>
<li>建立：当线路检测到载波信号时，建立物理连接，线路变为建立状态。</li>
<li>LCP开始选项商定，商定成功后就进入身份验证状态。身份验证通过后，进入网络层协议状态。</li>
<li>采用NCP配置网络层，配置成功后，进入打开状态，然后就可进行数据传输。</li>
<li>撤销：当数据传输完成后，线路转为终止状态。载波停止后则回到静止状态。</li>
</ul>
</li>
<li><p>特点</p>
<p>1）PPP提供<strong>差错检测但不提供纠错功能</strong>，只保证<strong>无差错接收</strong>（通过硬件进行CRC校验）。它是不可靠的传输协议，因此也不使用序号和确认机制。<br>2）它仅支持<strong>点对点的链路通信</strong>，不支持多点线路。<br>3）PPP只支持<strong>全双工链路</strong>。<br>4）PPP的两端可以<strong>运行不同的网络层协议</strong>，但仍然可使用同一个PPP进行通信。<br>5）PPP是<strong>面向字节</strong>的，当信息字段出现和标志字段一致的比特组合时，PPP有两种不同的处理方法：若PPP用在异步线路（默认），则采用<strong>字符填充法</strong>；若PPP用在SONET&#x2F;SDH等同步线路，则协议规定采用硬件来完成<strong>比特填充</strong>（和HDLC的做法一样）。</p>
</li>
</ol>
<h5 id="3-7-3-HDLC协议"><a href="#3-7-3-HDLC协议" class="headerlink" title="3.7.3 HDLC协议"></a>3.7.3 HDLC协议</h5><p>​ 高级数据链路控制（HDLC）协议是<strong>面向比特</strong>的数据链路层协议。实现<strong>可靠传输</strong>。</p>
<ol>
<li>特点</li>
</ol>
<ul>
<li>该协议不依赖于任何一种字符编码集</li>
<li>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</li>
<li>全双工通信，有较高的数据链路传输效率</li>
<li>所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重发，传输可靠性高</li>
<li>传输控制功能与处理功能分离，具有较大的灵活性。</li>
</ul>
<ol start="2">
<li><p>帧格式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cf35c76b3de6d65844bf444500cdb86ebpngpic_center.jpg" alt="image-20230816132019427"></p>
<ul>
<li>标志字段F，为01111110。在接收端只要找到标志字段就可确定一个帧的位置。</li>
<li>HDLC协议采用比特填充的首尾标志法实现透明传输。</li>
<li>地址字段A，共8位，根据不同的传送方式，表示从站或应答站的地址。</li>
<li>控制字段C，共8位，HDLC的许多重要功能都靠控制字段来实现。</li>
</ul>
</li>
<li><p>PPP与HDLC的不同</p>
<ul>
<li>PPP协议是面<strong>向字节</strong>的，HDLC协议是<strong>面向比特</strong>的。</li>
<li>PPP帧比HDLC帧<strong>多一个2字节的协议字段</strong>。当协议字段值为0x0021时，表示信息字段是IP数据报。</li>
<li>PPP协议<strong>不使用序号和确认机制</strong>，只保证无差错接收（CRC检验），而端到端差错检测由高层协议负责。HDLC协议的信息帧使用了<strong>编号和确认机制</strong>，能够提供<strong>可靠传输</strong>。</li>
</ul>
</li>
</ol>
<h4 id="3-8-数据链路层设备"><a href="#3-8-数据链路层设备" class="headerlink" title="3.8 数据链路层设备"></a>3.8 数据链路层设备</h4><h5 id="3-8-1-网桥"><a href="#3-8-1-网桥" class="headerlink" title="3.8.1 网桥"></a>3.8.1 网桥</h5><p>​ 两个或多个以太网通过网桥连接后，就成为一个更大的以太网，而原来的每个以太网就称为一个网段。网桥工作在链路层的MAC子层，可以使以太网各网段成为<strong>隔离开的碰撞域</strong>。</p>
<p>​ 网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）。</p>
<ul>
<li><strong>冲突域</strong>：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间只能有一台设备发送信息的范围。</li>
<li><strong>广播域</strong>：网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为一个广播域。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">层次</th>
<th align="center">设备</th>
<th align="center">隔离冲突域</th>
<th align="center">隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td align="center">网络层</td>
<td align="center">路由器</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">数据链路层</td>
<td align="center">网桥、交换机</td>
<td align="center">能</td>
<td align="center">不能</td>
</tr>
<tr>
<td align="center">物理层</td>
<td align="center">中继器、集线器</td>
<td align="center">不能</td>
<td align="center">不能</td>
</tr>
</tbody></table>
<h5 id="3-8-2-局域网交换机"><a href="#3-8-2-局域网交换机" class="headerlink" title="3.8.2 局域网交换机"></a>3.8.2 局域网交换机</h5><ol>
<li><p>交换机的原理和特点</p>
<p>局域网交换机，又称以太网交换机，以太网交换机实质上就是一个<strong>多端口的网桥</strong>，工作在数据链路层。</p>
<p>以太网交换机的每个端口都直接与单台主机或另一个交换机相连，通常都工作在<strong>全双工方式</strong>。</p>
<ul>
<li><p><strong>原理</strong>：它检测从以太端口来的数据帧的源和目的地的MAC地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表中，并将数据帧发送给相应的目的端口。</p>
</li>
<li><p>交换机能经济地将网络<strong>分成小的冲突域</strong>，为每个工作站提供<strong>更高的带宽</strong>。</p>
</li>
</ul>
<blockquote>
<p>对于传统10Mb&#x2F;s的共享式以太网，若共有N个用户，则每个用户占有的平均带宽只有总带宽的1&#x2F;N。</p>
<p>使用交换机时，每个端口到主机的带宽还是10Mb&#x2F;s，用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此拥有N个端口的交换机的总容量为N×10Mb&#x2F;s。</p>
</blockquote>
<p><strong>特点</strong>：</p>
<ul>
<li>以太网交换机的<strong>每个端口都直接与单台主机相连</strong>（网桥的端口往往连接到一个网段），并且一般都工作在<strong>全双工方式</strong>。</li>
<li>以太网交换机<strong>同时连通多对端口</strong>，使每对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。</li>
<li>以太网交换机是一种<strong>即插即用</strong>设备，其内部的帧的转发表是通过<strong>自学习算法</strong>自动地逐渐建立起来的。</li>
<li>以太网交换机由于使用<strong>专用的交换结构芯片</strong>，交换速率较高。</li>
<li>以太网交换机<strong>独占传输媒体的带宽</strong>。</li>
</ul>
<p><strong>交换模式</strong>：</p>
<ul>
<li><p><strong>直通式交换机</strong>：查完目的MAC地址（6B）就立刻转发。延迟小，可靠性低，无法支持具有不同速率的端口的交换。</p>
</li>
<li><p><strong>存储转发式交换机</strong>：将帧放入<strong>高速缓存</strong>，并检查否正确，正确则转发，错误则丢弃。延迟大，可靠性高，可以支持具有不同速率的端口的交换。</p>
<blockquote>
<p>以太网交换机一股都具有多种速率的端口，例如可以具有10Mb&#x2F;s、100Mb&#x2F;s和1Gb&#x2F;s的端口的各种组合，因此大大方便了各种不同情况的用户。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>交换机的自学习功能</p>
<p>交换机的过滤和转发借助于交换表（switch table）完成。</p>
<p><strong>过滤</strong>：决定一个帧是应该转发到某个端口还是应该将其丢弃称。</p>
<p><strong>转发</strong>：决定一个帧应该被移动到哪个接口。</p>
<p><strong>交换表</strong>：包含多个表项，每个表项包含①一个MAC地址；②连通该MAC地址的交换机端口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cfa24e80664dee86b9a4c84b47ca6adddpngpic_center.jpg" alt="image-20230816140541143"></p>
<p><strong>自学习过程</strong>：</p>
<ul>
<li>A先向B发送一帧，从端口1进入交换机。</li>
<li>交换机收到帧后，查找交换表，找不到MAC地址为B的表项。</li>
<li>交换机将该帧的源地址A和端口1（A,1）写入交换表，并向除端口1外的所有端口广播这个帧（该帧就是从端口1进入的，因此不应该将它再从端口1转发出去）。</li>
<li>C和D丢弃该帧，因为目的地址不对。只有B才收下这个目的地址正确的帧。</li>
<li>B通过端口3向A发送一帧，交换机查找交换表后，发现有表项 (A,1)，将该帧从端口1转发给A。同时，将该帧的源地址B和端口 3 (B,3) 写入交换表，表明以后如有发送给B的帧，应该从端口3转发出去。</li>
<li>经过一段时间，只要主机C和D也向其他主机发送帧，交换机就会把C和D及对应的端口号写入交换表。这样，转发给任何主机的帧，都能很快地在交换表中找到相应的转发端口。</li>
</ul>
<blockquote>
<p>交换表中的每个表项都设有一定的有效时间，<strong>过期的表项会自动删除</strong>。这就保证了交换表中的数据符合当前网络的实际状况。</p>
</blockquote>
</li>
</ol>
<h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4 网络层"></a>4 网络层</h3><h4 id="4-1-网络层功能"><a href="#4-1-网络层功能" class="headerlink" title="4.1 网络层功能"></a>4.1 网络层功能</h4><p>​ 互联网在网络层的设计思路是，向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。也就是说，所传送的分组可能出错、丢失、重复、失序或超时，这就使得网络中的路由器比较简单，而且价格低廉。</p>
<h5 id="4-1-1-异构网络互联"><a href="#4-1-1-异构网络互联" class="headerlink" title="4.1.1 异构网络互联"></a>4.1.1 异构网络互联</h5><p>​ 网络互连是指将两个以上的计算机网络，通过一定的方法，用一些中间设备（又称中继系统）相互连接起来，以构成更大的网络系统。根据所在的层次，中继系统分为以下4种：</p>
<ul>
<li>物理层中继系统：转发器，集线器。</li>
<li>数据链路层中继系统：网桥或交换机。</li>
<li>网络层中继系统：路由器。</li>
<li>网络层以上的中继系统：网关。</li>
</ul>
<p>​ 使用物理层或数据链路层的中继系统时，只是把一个网络扩大了，而从网络层的角度看，它仍然是同一个网络，一般并不称为网络互连。因此网络互连通常是指用路由器进行<strong>网络互连</strong>和<strong>路由选择</strong>。路由器是一台专用计算机，用于在互联网中进行路由选择。</p>
<p>​ TCP&#x2F;IP体系在网络互连上采用的做法是在网络层采用标准化协议，但相互连接的网络可以是<strong>异构</strong>的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C39cfda182f70915f1769ead07be786e7pngpic_center.jpg" alt="image-20230816150325020"></p>
<p>​ 上图表示用许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的IP协议，因此可以把互连后的网络视为如图（b）所示的一个虚拟IP网络。</p>
<p>​ IP网络：是通过IP协议使性能各异的网络在网络层上看起来好像是一个统一的网络。</p>
<h5 id="4-1-2-路由转发"><a href="#4-1-2-路由转发" class="headerlink" title="4.1.2 路由转发"></a>4.1.2 路由转发</h5><p>​ 路由器主要完成两个功能：一是路由选择（确定哪一条路径）；二是分组转发（当一个分组到达时所采取的动作）。</p>
<ul>
<li>路由选择：指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由。</li>
<li>分组转发：指路由器根据转发表将用户的IP数据报从合适的端口转发出去。</li>
</ul>
<p>​ 路由表是根据路由选择算法得出的，而转发表是从路由表得出的。转发表的结构应当使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</p>
<h5 id="4-1-3-SDN基本概念"><a href="#4-1-3-SDN基本概念" class="headerlink" title="4.1.3 SDN基本概念"></a>4.1.3 SDN基本概念</h5><p>​ 网络层的主要任务是转发和路由选择。可以将网络层抽象地划分为数据平面（也称转发层面）和控制平面，<strong>转发</strong>是数据平面实现的功能，而<strong>路由选择</strong>是控制平面实现的功能。</p>
<p>​ <strong>数据平面</strong>：数据平面对于数据处理过程中各种具体处理转发过程。数据平面执行的主要功能是根据转发表进行转发，这是路由器的本地动作。</p>
<p>​ <strong>控制平面</strong>：控制平面用于控制和管理网络协议的运行，比如OSPF协议、RIP协议、BGP协议。用于实现路由选择，控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。时间长，通常软件解决。</p>
<p>​ <strong>软件定义网络</strong>（SDN）是近年流行的一种创新网络架构，它采用<strong>集中式的控制平面</strong>和<strong>分布式的数据平面</strong>，两个平面相互分离，控制平面利用<strong>控制-数据接口</strong>对数据平面上的路由器进行集中式控制，方便软件来控制网络。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C19ba011642f50e018956ea9c48c065d5pngpic_center.jpg" alt="image-20230816152221821"></p>
<p>​ 在网络的控制平面有一个逻辑上的<strong>远程控制器</strong>（可以由多个服务器组成）。远程控制器掌握各主机和整个网络的状态，为每个分组计算出最佳路由，通过Openflow协议（也可以通过其他途径）将转发表（在SDN中称为流表）下发给路由器。</p>
<p>​ <strong>路由器</strong>的工作很单纯，即收到分组、查找转发表、转发分组。</p>
<p>​ SDN的可编程性通过为开发者们提供强大的编程接口，使得网络具有很好的编程性。</p>
<ul>
<li><strong>北向接口</strong>：对<strong>上层应用</strong>的开发者，SDN提供的编程接口称为北向接口。北向接口提供了一系列丰富的API，开发者可以在此基础上设计自己的应用，而不必关心底层的硬件细节。</li>
<li><strong>南向接口</strong>：SDN控制器和<strong>转发设备</strong>建立双向会话的接口称为南向接口，通过不同的南向接口协议（如Openflow），SDN控制器就可兼容不同的硬件设备，同时可以在设备中实现上层应用的逻辑。</li>
<li><strong>东西向接口</strong>：SDN控制器集群内部控制器之间的通信接口称为东西向接口，用于增强整个控制平面的可靠性和可拓展性。</li>
</ul>
<p><strong>SDN优点</strong>：</p>
<ul>
<li><strong>全局集中式控制和分布式高速转发</strong>，既利于控制平面的全局优化，又利于高性能的网络转发。</li>
<li><strong>灵活可编程与性能的平衡</strong>，控制和转发功能分离后，使得网络可以由专有的自动化工具以编程方式配置。</li>
<li><strong>降低成本</strong>，控制和数据平面分离后，尤其是在使用开放的接口协议后，就实现了网络设备的制造与功能软件的开发相分离，从而有效降低了成本。</li>
</ul>
<p><strong>SDN的问题</strong>：</p>
<ul>
<li><strong>安全风险</strong>，集中管理容易受攻击，如果崩溃，整个网络会受到影响。</li>
<li><strong>瓶颈问题</strong>，原本分布式的控制平面集中化后，随着网络规模扩大，控制器可能成为网络性能的瓶颈。</li>
</ul>
<h5 id="4-1-4-拥塞控制"><a href="#4-1-4-拥塞控制" class="headerlink" title="4.1.4 拥塞控制"></a>4.1.4 拥塞控制</h5><p>​ <strong>拥塞</strong>：在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞。</p>
<p>​ 例如，某个路由器所在链路的带宽为 R R R B&#x2F;S，如果IP分组只从它的某个端口进入，那么其速率为rinB&#x2F;s。当rin=R时，并非好事。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C6e5cd8f9fbe24571634a0520d95fbc6bpngpic_center.jpg" alt="image-20230816155911692"></p>
<p>​ 当分组到达路由器的速率接近R时，平均时延急剧增加，并且会有大量的分组被丢弃（路由器端口的缓冲区是有限的），整个网络的吞吐量会骤降，源与目的地之间的平均时延也会变得近乎无穷大。</p>
<p><strong>判断网络是否拥塞方法</strong>：观察网络的吞吐量与网络负载的关系</p>
<ul>
<li>轻度拥塞状态：随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量。</li>
<li>拥塞状态：网络的吞吐量随着网络负载的增大而下降。</li>
<li>死锁状态：网络的负载继续增大，而网络的吞吐量下降到零。</li>
</ul>
<p>​ <strong>拥塞控制</strong>的作用是确保子网能够承载所达到的流量，这是一个全局性的过程，涉及各方面的 行为：主机、路由器及路由器内部的转发处理过程等。单一地增加资源并不能解决拥塞。</p>
<blockquote>
<p>流量控制和拥塞控制的区别：</p>
<p><strong>流量控制</strong>往往是指在发送端和接收端之间的<strong>点对点通信量</strong>的控制。流量控制所要做的是<strong>抑制发送端发送数据的速率</strong>，以便使接收端来得及接收。</p>
<p>而<strong>拥塞控制</strong>必须确保通信子网能够<strong>传送待传送的数据</strong>，是一个全局性的问题，涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。</p>
</blockquote>
<p><strong>拥塞控制的方法</strong>：</p>
<ul>
<li><strong>开环控制</strong>：在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。<br>这是一种<strong>静态</strong>的预防方法。一旦整个系统启动并运行，中途就不再需要修改。<br>开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度策略等。所有这些手段的共性是，在做决定时<strong>不考虑当前网络的状态</strong>。</li>
<li><strong>闭环控制</strong>：事先不考虑有关发生拥塞的各种因素，采用<strong>监测网络系统</strong>去监视，及时检测哪里发生了拥塞，然后将拥塞信息传到合适的地方,以便调整网络系统的运行，并解决出现的问题。<br>闭环控制是<strong>基于反馈环路</strong>的概念，是一种<strong>动态</strong>的方法。</li>
</ul>
<h4 id="4-2-路由算法和路由协议"><a href="#4-2-路由算法和路由协议" class="headerlink" title="4.2 路由算法和路由协议"></a>4.2 路由算法和路由协议</h4><h5 id="4-2-1-静态路由与动态路由"><a href="#4-2-1-静态路由与动态路由" class="headerlink" title="4.2.1 静态路由与动态路由"></a>4.2.1 静态路由与动态路由</h5><p>​ 路由器转发分组是通过路由表转发的，而路由表是通过各种算法得到的。从能否随网络的通信量或拓扑自适应地进行调整变化来划分，路由算法可以分为如下两大类。</p>
<ul>
<li><strong>静态路由算法</strong>（又称非自适应路由算法）。指由网络<strong>管理员手工配置</strong>的路由信息。<br>当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。它不能及时适应网络状态的变化，对于简单的小型网络，可以采用静态路由。</li>
<li><strong>动态路由算法</strong>（又称自适应路由算法）。指路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，而这些路由信息会在一定时间间隙里不断更新，以适应不断变化的网络，随时获得最优的寻路效果。</li>
</ul>
<h5 id="4-2-2-距离-向量路由算法"><a href="#4-2-2-距离-向量路由算法" class="headerlink" title="4.2.2 距离-向量路由算法"></a>4.2.2 距离-向量路由算法</h5><ol>
<li><p>距离向量算法</p>
<p>​ 常见的距离-向量路由算法是<strong>RIP算法</strong>，<strong>每个路由器</strong>定期与所有相邻路由器交换<strong>整个路由表</strong>，更新路由项。</p>
<p>​ 这种路由表包含：①每条路径的目的地（另一结点）。②路径的代价（也称距离）。</p>
<blockquote>
<p>这里的距离是一个抽象的概念，如RIP就将距离定义为“跳数”。跳数指从源端口到达目的端口所经过的路由器个数，每经过一个路由器，跳数加1。</p>
</blockquote>
<ul>
<li><p>更新路由表的情况：</p>
<ul>
<li><p><strong>被通告一条新的路由</strong>，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。</p>
</li>
<li><p><strong>路由信息有一条较短的距离</strong>，发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离。此时，就用经过发送路由信息的结点的新路由替换路由表中到达那个目的地的现有路由。</p>
</li>
</ul>
</li>
</ul>
<p>​ 距离-向量路由算法的<strong>实质</strong>是，迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短（最小代价）通路。</p>
<ul>
<li><strong>问题</strong>：大的通信子网导致大的更新报文，路由信息变得很大。</li>
</ul>
<blockquote>
<p>距离-向量路由算法中，路由器只掌握物理相连的邻居及链路费用</p>
</blockquote>
</li>
<li><p><strong>RIP（路由信息协议）</strong> 封装UDP 应用层协议 只适用于小互联网</p>
<p>RIP是一种分布式的基于距离向量的路由选择协议，其最大优点就是简单。</p>
<ul>
<li><p><strong>协议规定</strong>：</p>
<ul>
<li><p>1）网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（距离向量）</p>
</li>
<li><p>2）距离也称为跳数，规定从一路由器到直接连接的跳数为1。每经过一个路由器，跳数加1</p>
</li>
<li><p>3）RIP认为好的路由就是它通过的路由器的数目少，即优<strong>先选择跳数少的路径</strong></p>
</li>
<li><p>4）RIP允许一条路径最多只能包含15个路由器（即<strong>最多允许15跳</strong>）距离<strong>等于16时，表示网络不可到达</strong></p>
</li>
<li><p>5）RIP默认在任意两个使用RIP的路由器之间每30s广播一次RIP路由更新信息，<strong>动态维护</strong>路由表</p>
</li>
<li><p>6）在RIP中<strong>不支持子网掩码</strong>的RIP广播，RIP中每个网络的<strong>子网掩码必须相同</strong>。在RIP2中，支持变长子网掩码和CIDR</p>
</li>
</ul>
</li>
<li><p><strong>RIP报文格式</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C774679c5f0e19c3b8aad806a3df08107pngpic_center.jpg" alt="image-20230818133004500"></p>
<p>​ RIP报文由首部和路由部分组成。</p>
</li>
<li><p><strong>RIP的特点</strong>：</p>
<ul>
<li><p>1）仅和相邻路由器交换信息。</p>
</li>
<li><p>2）路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。</p>
</li>
<li><p>3）按固定的时间间隔交换路由信息，如每隔30秒。</p>
</li>
</ul>
</li>
<li><p><strong>距离向量算法</strong>：每个路由表项目都有三个关键数据： &lt; 目的网络 N ，距离 d ，下一跳路由器地址 X &gt; &lt;目的网络N，距离d，下一跳路由器地址X&gt; &lt;目的网络N，距离d，下一跳路由器地址X&gt;。</p>
<ul>
<li><p>1）对地址为X的相邻路由器发来的报文，修改此报文中的所有项目【**’下一跳’的地址都改为X，把所有’距离’的值+1**】</p>
</li>
<li><p>2）对修改后的报文中的每一个项目，进行以下步骤：</p>
<ul>
<li>①当原来的路由表中没有目的网络N，则把该项目添加到路由表中</li>
<li>②当原来的路由表中有目的网络N，且下一跳路由器地址【是X】时，用收到的项目替换原路由表中的项目</li>
<li>③当原来的路由表中有目的网络N，且下一跳路由器地址【不是X】，若收到的项目中的<strong>距离d&lt;路由表中的距离</strong>，用收到的项目替换原路由表中的项目，否则什么也不做</li>
</ul>
</li>
<li><p>3）如果180s（默认<strong>超时时间是180s</strong>）没有收到相邻路由器的更新路由表，把此相邻路由器记为<strong>不可达路由</strong>，把距离置为16</p>
</li>
<li><p>4）返回</p>
</li>
</ul>
<blockquote>
<p>例：已知路由器R6有表a所示的路由表。现在收到相邻路由器R4发来的路由更新信息，如表b所示。试更新路由器R6的路由表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C7cc7132153ec7c74d37cfd2282ce6abapngpic_center.jpg" alt="image-20230818135130787"></p>
<p>先把表b中的距离都加1，并把下一跳路由器都改为R4。得出表c。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cbce19f6867279d0175482646c465c106pngpic_center.jpg" alt="image-20230818135536228"></p>
<p>把这个表的每一行和表a进行比较。</p>
<ul>
<li>第一行在表a中没有，因此要把这一行添加到表a中。</li>
<li>第二行的Net2在表a中有，且下一跳路由器也是R4。因此要更新（距离增大了）。</li>
<li>第三行的Net3在表a中有，但下一跳路由器不同。于是就要比较距离。新的路由信息的距离是2，小于原来表中的4，因此要更新。</li>
</ul>
<p>这样，得出更新后的R6的路由表如表d所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Ccdc1ecd7f28356a5269fd7f3011de3fcpngpic_center.jpg" alt="image-20230818135836501"></p>
<p>在更新完路由后，每一个路由器到每一个目的网络的路由都是最短的</p>
</blockquote>
</li>
<li><p><strong>RIP优点</strong>：实现简单、开销小、收敛过程较快</p>
<blockquote>
<p>收敛：路由器刚开始工作时，只知道直接连接的网络的距离（距离为1），接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</p>
<p>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“收敛”。</p>
</blockquote>
</li>
<li><p><strong>RIP缺点</strong>：好消息传得快，坏消息传得慢</p>
<ul>
<li><p>1）RIP限制了网络的规模，它能使用的最大距离为15（16表示不可达）。</p>
</li>
<li><p>2）路由器之间交换的是路由器中的完整路由表，因此<strong>网络规模越大，开销也越大</strong>。</p>
</li>
<li><p>3）网络出现故障时，会出现<strong>慢收敛</strong>现象（即需要较长时间才能将此信息传送到所有路由器），使更新过程的收敛时间长。</p>
</li>
</ul>
<blockquote>
<p>慢收敛例子：</p>
<p>​ 现在假定路由器R1，到网1的链路出了故障，R1无法到达网1。于是路由器R1把到网1的距离改为16（表示到网1不可达），因而在R1的路由表中的相应项目变为“1，16，直接”。但是，很可能要经过30秒钟后R1才把更新信息发送给R2。然而R2可能已经先把自己的路由表发送给了R1，其中有“1，2，R1”这一项。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C3b090b891c3d5f8329527c1890902cd4pngpic_center.jpg" alt="image-20230821093055417"></p>
<p>​ R1收到R2的更新报文后，误认为可经过R2到达网1，于是把收到的路由信息“1，2，R，”修改为：“1，3，R2”，表明“我到网1的距离是3，下一跳经过R2”，并把更新后的信息发送给R2。<br>​ 同理，R2接着又更新自己的路由表为“1，4，R1”，以为“我到网1距离是4，下一跳经过R1”。<br>​ 这样的更新一直继续下去，直到R1和R2到网1的距离都增大到16时，R1和R2才知道原来网1是不可达的。RIP协议的这一特点叫做：<strong>好消息传播得快，而坏消息传播得慢</strong>。网络出故障的传播时间往往需要较长的时间（例如数分钟）。这是RIP的一个主要缺点。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h5 id="4-2-3-链路状态路由算法"><a href="#4-2-3-链路状态路由算法" class="headerlink" title="4.2.3 链路状态路由算法"></a>4.2.3 链路状态路由算法</h5><ol>
<li><p>链路状态路由算法</p>
<ul>
<li><p>链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息，它们执行下述两项任务。</p>
<ul>
<li><p>第一，<strong>主动测试所有邻接结点的状态</strong>。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。</p>
</li>
<li><p>第二，<strong>定期地将链路状态</strong>传播给所有其他结点（或称路由结点）。</p>
</li>
</ul>
</li>
</ul>
<p>​ 典型的链路状态算法是<strong>OSPF算法</strong>。</p>
<ul>
<li><p><strong>特征</strong>：</p>
<ul>
<li><p>向本自治系统中所有路由器发送信息（洪泛法）。</p>
<blockquote>
<p>洪泛法，即路由器通过所有端 口向所有相邻的路由器发送信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cb596515af37c7c1b35f6e3a25a543a35pngpic_center.jpg" alt="image-20230818150509867"></p>
<p>设路由器R用洪泛法发出链路状态更新分组。图中用一些小的箭头表示更新分组。第一次先发给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要发送一次确认）。图中的空心箭头表示确认分组。</p>
</blockquote>
</li>
<li><p>发送的信息是与路由器相邻的所有路由器的链路状态。</p>
<blockquote>
<p>OSPF算法中，链路状态的“度量”主要用来表示费用、距离、时延、带宽等。</p>
</blockquote>
</li>
<li><p>只有链路状态发生变化，才向所有路由器发送信息。</p>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><p>每个路由结点使用同样的原始状态数据独立的计算路径。</p>
</li>
<li><p>链路状态不加改变的传播，该算法易于查找故障。</p>
</li>
<li><p>仅运载来自单个结点关于直接链路的信息，其大小与网络中的路由结点数目无关，有更好的规模可伸展性。</p>
</li>
</ul>
</li>
</ul>
<p>​ 链路状态路由算法可以用于大型的或路由信息变化聚敛的互联网环境。因为一个路由器的链路状态只涉及相邻路由器的连通状态，而与整个互联网的规模并无直接关系。</p>
<blockquote>
<p>链路状态路由算法中，所有路由器掌握完整的网络拓扑和链路费用信息。</p>
</blockquote>
</li>
<li><p><strong>OSPF（开放最短路径优先）协议</strong> 网络层协议 封装IP</p>
<ul>
<li><p><strong>OSPF特点</strong>：</p>
<ul>
<li>1）OSPF对不同的链路可根据IP分组的不同服务类型（TOS）而设置成不同的代价。因此，OSPF对于不同类型的业务可计算出不同的路由，十分灵活。</li>
<li>2）如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这称为多路径间的负载平衡。</li>
<li>3）所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li>
<li>4）支持可变长度的子网划分和无分类编址CIDR。</li>
<li>5）每个链路状态都带上一个32位的序号，序号越大，状态就越新。</li>
</ul>
</li>
<li><p><strong>OSPF与RIP的区别</strong>：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RIP</th>
<th align="center">OSPF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">工作层次</td>
<td align="center">应用层 基于UDP</td>
<td align="center">网络层 基于IP</td>
</tr>
<tr>
<td align="center">转发范围</td>
<td align="center">相邻路由器</td>
<td align="center">整个本自治系统（洪泛法）</td>
</tr>
<tr>
<td align="center">发送内容</td>
<td align="center">整个路由表</td>
<td align="center">相邻路由器链路状态</td>
</tr>
<tr>
<td align="center">何时发送</td>
<td align="center">定期交换 收敛慢</td>
<td align="center">链路状态改变（洪泛法） 收敛快</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>OSPF报文格式</strong>：</p>
<p>OSPF直接用IP数据报传送，工作在网络层。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C76af6a1123daf7c8e5da956025eb0aebpngpic_center.jpg" alt="image-20230818144119117"></p>
</li>
<li><p><strong>OSPF的基本工作原理</strong>：</p>
<p>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>（area）。每一个区域都有一个32位的区域标识符（用点分十进制表示）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C7b99a95e2c42f9d7452e6ab5483af33apngpic_center.jpg" alt="image-20230818142755180"></p>
<p>​ 划分区域后，洪泛法交换链路状态信息的范围<strong>局限于每一个区域</strong>，减少网络的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。每个区域路由器应不超200个。</p>
<p>​ OSPF采用<strong>层次结构的区域划分</strong>，使每个区域能够与其他区域通信。</p>
<ul>
<li><p>在上层的区域叫做<strong>主干区域</strong>backbone area）。主千区域的标识符规定为0.0.0.0。主干区域的作用是用来<strong>连通其他在下层的区域</strong>。</p>
</li>
<li><p>从其他区域来的信息都由<strong>区域边界路由器</strong>（area border router）进行概括。如路由器R3，R4和R7。</p>
</li>
<li><p>在主干区域内的路由器叫做<strong>主干路由器</strong>（backbone router），如R3，R4，R5，R6和R7。</p>
</li>
<li><p>在主干区域内需要一个路由器和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong>，如R6。</p>
<p>​ 采用层次划分后，使每一个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于<strong>规模很大的自治系统</strong>中。</p>
</li>
</ul>
</li>
<li><p><strong>OSPF分组类型</strong>：</p>
<ul>
<li>1）<strong>问候分组</strong>，用来发现和维持邻站的可达性。</li>
<li>2）<strong>数据库描述分组</strong>，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li>
<li>3）<strong>链路状态请求分组</strong>，向对方请求发送某些链路状态项目的详细信息。</li>
<li>4）<strong>链路状态更新分组</strong>，用洪泛法对全网更新链路状态。</li>
<li>5）<strong>链路状态确认分组</strong>，对链路更新分组的确认。</li>
</ul>
<p>​ 通常每隔10秒，每两个相邻路由器要交换一次问候分组，以便知道哪些站可达。路由器刚开始工作时，OSPF让每个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链 路状态摘要信息。然后，路由器使用链路状态请求分组，向对方请求发送自己所缺少的某些链路 状态项目的详细信息。经过一系列的这种分组交换，就建立了全网同步的链路数据库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C0223e2420c7817d30b9eeb2528bd1e61pngpic_center.jpg" alt="image-20230818145357592"></p>
</li>
<li><p><strong>OSPF链路状态路由算法</strong>：</p>
<ul>
<li><p>1.每个路由器发现它的邻居结点【HELLO问候分组】，并了解邻居节点的网络地址。</p>
</li>
<li><p>2.设置到它的每个邻居的成本度量metric。</p>
</li>
<li><p>3.构造【DD数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</p>
</li>
<li><p>4.如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR链路状态请求分组】请求自己没有的和比自己更新的信息。</p>
</li>
<li><p>5.收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新。</p>
</li>
<li><p>6.更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行确认。</p>
</li>
</ul>
<p>只要一个<strong>路由器的链路状态发生变化</strong>：</p>
<ul>
<li><p>5.泛洪发送【LSU链路状态更新分组】进行更新。</p>
</li>
<li><p>6.更新完毕后，其他站返回一个【LSAck链路状态确认分组】进行确认。</p>
</li>
<li><p>7.使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。</p>
</li>
</ul>
<blockquote>
<p>OSPF算法例子：</p>
<p>因特网中的一个自治系统的内部结构如下图所示。路由选择协议采用OSPF协议时，计算R6的关于网络N1、N2、N3、N4的路由表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C04046bdd772fc9cfe1ae1d1da4d07b63pngpic_center.jpg" alt="image-20230821095646559"></p>
<p>根据Dijkstra算法，得出以下路径表格，其中主意，经过N3网络路径代价未增加。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">R1</th>
<th align="center">R2</th>
<th align="center">R3</th>
<th align="center">R4</th>
<th align="center">R5</th>
<th align="center">N1</th>
<th align="center">N2</th>
<th align="center">N3</th>
<th align="center">N4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第1轮</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">6</td>
<td align="center"></td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">第2轮</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">6</td>
<td align="center">14</td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">第3轮</td>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>7</strong></td>
<td align="center">6</td>
<td align="center">14</td>
<td align="center">6</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">第4轮</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">14</td>
<td align="center">6</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>路由表如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C945fa0bc4054bf44e0de22f708541c64pngpic_center.jpg" alt="image-20230821100223264"></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h5 id="4-2-4-层次路由"><a href="#4-2-4-层次路由" class="headerlink" title="4.2.4 层次路由"></a>4.2.4 层次路由</h5><ol>
<li><p>层次路由</p>
<p>网络规模扩大，路由器的路由表成比例地增大。这样会消耗大量资源，因此路由选择应按照层次的方式进行。</p>
<p>因特网将整个互联网划分为许多较小的<strong>自治系统（AS）</strong>（注意一个自治系统中包含很多局域网）。</p>
<blockquote>
<p>自治系统（Autonomous System，AS）：单一技术管理下的一组路由器，这些路由器使用一种<strong>AS内部的路由选择协议</strong>和共同的度量来确定分组在该AS内的路由，同时还使用一种<strong>AS之间的路由选择协议</strong>来确定分组在AS之间的路由。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C267153a394a482eb120b940daee864cdpngpic_center.jpg" alt="image-20230818113334901"></p>
<p>​ 每个自治系统有权自主地决定本系统内应采用何种路由选择协议。如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。因此将选择协议分为以下两种类型：</p>
<ul>
<li><strong>内部网关协议（IGP）</strong>：也称域内路由选择，指一个自治系统内部所使用的路由选择协议，具体的协议有RIP和OSPF等。</li>
<li><strong>外部网关协议（EGP）</strong>：也称域间路由选择，指自治系统之间所使用的路由选择协议，在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径。具体的协议有BGP。</li>
</ul>
<p>使用层次路由时，OSPF将一个自治系统再划分为若干区域（Area），每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。因而使OSPF协议能够用于规模很大的自治系统中。</p>
</li>
<li><p><strong>BGP（外部网关协议）</strong> 应用层 TCP封装</p>
<p>​ 边界网关协议（Border Gateway Protocol，BGP）是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。</p>
<ul>
<li><p><strong>目的</strong>：力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子）</p>
</li>
<li><p><strong>困难</strong></p>
<ul>
<li>互联网的规模太大，使得自治系统AS之间路由选择非常困难</li>
<li>自治系统AS之间的路由选择必须考虑有关策略。</li>
</ul>
</li>
<li><p><strong>交换过程</strong></p>
<p>BGP所交换的<strong>网络可达性的信息</strong>就是要<strong>到达某个网络所要经过的一系列AS</strong>。</p>
<p>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。</p>
</li>
<li><p><strong>BGP的工作原理</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C7ff8cd43f74cf089dd4fd5232615f004pngpic_center.jpg" alt="image-20230818153227250"></p>
<ul>
<li><p>每一个自治系统的管理员要选择至少一个路由器（可多个）作为该自治系统的”BGP发言人”</p>
</li>
<li><p>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要先<strong>建立TCP连接</strong></p>
</li>
<li><p>然后在此连接上交换BGP报文以<strong>建立BGP会话</strong>，再利用BGP会话交换路由信息</p>
</li>
<li><p>当所有BGP发言人都相互交换网络可达性的信息后，各BGP发言人就可找出到达各个自治系统的比较好的路由</p>
</li>
</ul>
<blockquote>
<p>BGP发言人交换路径向量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C18b3fdca916ca6aa29cfd254d55dac06pngpic_center.jpg" alt="image-20230818153606293"></p>
<p>自治系统AS2的BGP发言人通知主干网的BGP发言人：“要到达网络N1，N2，N3和N4可经过AS2。”主干网在收到这个通知后，就发出通知：“要到达网络N1，N2，N3和N4可沿路径（AS1，AS2）。”同理，主干网还可发出通知：“要到达网络N5，N6和N可沿路径（AS1，AS3）。”</p>
</blockquote>
</li>
<li><p><strong>BGP报文格式</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cf8d9d7bee58fbf32d3c9047f36e18addpngpic_center.jpg" alt="image-20230818152557320"></p>
</li>
<li><p><strong>特点</strong>：</p>
<p>1）BGP协议交换路由信息的结点数量级是自治系统的数量级，比这些自治系统中的网络数少很多</p>
<p>2）每一个自治系统中BGP发言人（或边界路由器）的数目是很少的，这样自治系统之间的路由选择不会很复杂</p>
<p>3）BGP支持CIDR，BGP的路由表包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列</p>
<p>4）在BGP刚运行时，BGP的邻站交换整个BGP路由表。但以后只需要在发生变化时更新有变化的部分</p>
</li>
<li><p><strong>BGP-4的四种报文</strong></p>
<ul>
<li>打开（Open）报文。用来与相邻的另一个BGP发言人建立关系。</li>
<li>更新（Update）报文。用来发送某一路由的信息，以及列出要撤销的多条路由。</li>
<li>保活（Keepalive）报文。用来确认打开报文并周期性地证实邻站关系。</li>
<li>通知（Notification）报文。用来发送检测到的差错。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>​ RIP、OSPF与BGP的比较如表所示。</p>
<table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">RIP</th>
<th align="center">OSPF</th>
<th align="center">BGP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">内部</td>
<td align="center">内部</td>
<td align="center">外部</td>
</tr>
<tr>
<td align="center">路由算法</td>
<td align="center">距离-向量</td>
<td align="center">链路状态</td>
<td align="center">路径-向量</td>
</tr>
<tr>
<td align="center">传递协议</td>
<td align="center">应用层 UDP</td>
<td align="center">网络层 IP</td>
<td align="center">应用层 TCP</td>
</tr>
<tr>
<td align="center">路径选择</td>
<td align="center">跳数最少</td>
<td align="center">代价最低</td>
<td align="center">较好，非最佳</td>
</tr>
<tr>
<td align="center">交换结点</td>
<td align="center">和本结点相邻的路由器</td>
<td align="center">网络中的所有路由器</td>
<td align="center">和本结点相邻的路由器</td>
</tr>
<tr>
<td align="center">交换内容</td>
<td align="center">自己的整个路由表</td>
<td align="center">与本路由器相邻的所有路由器的链路状态</td>
<td align="center">首次：整个路由表</td>
</tr>
<tr>
<td align="center">非首次：有变化的部分</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="4-3-IPv4"><a href="#4-3-IPv4" class="headerlink" title="4.3 IPv4"></a>4.3 IPv4</h4><h5 id="4-3-1-IPv4分组"><a href="#4-3-1-IPv4分组" class="headerlink" title="4.3.1 IPv4分组"></a>4.3.1 IPv4分组</h5><ol>
<li>IPv4分组的格式</li>
</ol>
<p>​ 一个IP分组由首部和数据部分组成。首部长度<strong>20B</strong>固定，后面有可选字段，长度可变。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C7504f5659b9cb9baffecd4ccd8ebdc0epngpic_center.jpg" alt="image-20230816172140328"></p>
<ul>
<li><p>版本：指IP协议的版本，目前广泛使用的版本号为4。</p>
</li>
<li><p>首部长度：单位是4B，最小为5，表示20B，最大是15，表示60B。</p>
</li>
<li><p>区分服务：指示期望获得哪种类型的服务。</p>
</li>
<li><p>总长度：首部+数据，单位是1B。</p>
</li>
<li><p>标识：16位，用于IP分片，同一数据报的分片使用同一标识。</p>
</li>
<li><p>标志：3位，只有后两位有意义，中间位DF，DF&#x3D;1，禁止分片；DF&#x3D;0，允许分片。最低位MF，MF&#x3D;1，后面“还有分片”；MF&#x3D;0，代表最后一片&#x2F;没分片。</p>
</li>
<li><p>片偏移：指出较长分组分片后，某片在原分组中的相对位置；以8B位单位。除了最后一个分片，每个分片数据部分长度一定是8B的整数倍。</p>
</li>
<li><p>生存时间（TTL）：IP分组的保质期。经过一个路由器-1变成0则丢弃。</p>
</li>
<li><p>协议：数据部分的协议，占8位。</p>
<table>
<thead>
<tr>
<th align="center">协议名</th>
<th align="center">ICMP</th>
<th align="center">IGMP</th>
<th align="center">TCP</th>
<th align="center">EGP</th>
<th align="center">IGP</th>
<th align="center">UDP</th>
<th align="center">IPv6</th>
<th align="center">ESP</th>
<th align="center">OSPF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字段值</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">17</td>
<td align="center">41</td>
<td align="center">50</td>
<td align="center">89</td>
</tr>
</tbody></table>
</li>
<li><p>首部检验和：16位，只检验首部。</p>
</li>
<li><p>源IP地址和目的IP地址：32位。</p>
</li>
<li><p>可选字段：0~40B，用来支持排错测量以及安全等措施</p>
</li>
<li><p>填充：全0，把首部补成4B的整数倍</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">段</th>
<th align="center">总长度</th>
<th align="center">片偏移</th>
<th align="center">首部长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">长度</td>
<td align="center">1B</td>
<td align="center">8B</td>
<td align="center">4B</td>
</tr>
</tbody></table>
<ol start="2">
<li>IP数据报分片</li>
</ol>
<p>​ <strong>最大传送单元（MTU）</strong>：一个链路层数据报能承载的最大数据量。以太网的MTU是<strong>1500字节</strong>。</p>
<p>​ 当IP数据报的总长度大于链路MTU时，就需要将IP数据报中的数据分装在多个较小的IP数据报中，这些较小的数据报称为<strong>片</strong>。 片在目的地的网络层被重新组装。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Ca8c993a128334eda38199e04eab91e49pngpic_center.jpg" alt="image-20230817115152840"></p>
<p>​ IP分片利用首部的标识、标志和片偏移三部分完成。</p>
<ul>
<li>标识：创建IP数据报时，源主机为其加一个标识号，同一个数据报分片后，每片具有相同的标识。</li>
<li>标志：共3位，只有后两位有意义，<ul>
<li><strong>中间位DF</strong>（Don’t Fragment），DF&#x3D;1，禁止分片；DF&#x3D;0，允许分片。</li>
<li><strong>最低位MF</strong>（More Fragment），MF&#x3D;1，后面“还有分片”；MF&#x3D;0，代表最后一片&#x2F;没分片。</li>
</ul>
</li>
<li>片偏移：指出数据报分片后某片在原分组中的相对位置，以8B位单位。除了最后一个分片，每个分片数据部分长度一定是8B的整数倍。</li>
</ul>
<blockquote>
<p>如上图所示，一个长4000B的IP数据报（首部20B，数据报部分3980B）到达路由器后，需要在以太网转发（MTU &#x3D; 1500B）。需要将3980B数据分片，前2片，每片有效数据部分1480B，首部20B；后一片数据部分为1020B&#x3D;（3980-1480-1480）B，首部20B。</p>
<p>每一片的DF都为0，表示都允许分片。前两片MF&#x3D;1，表示并非最后一片;最后一片MF&#x3D;0，表示为最后一片。</p>
<p>第一片片偏移为0，第二片片偏移为首位数据地址&#x2F;8&#x3D;1480&#x2F;8&#x3D;185；第三片片偏移&#x3D;2960&#x2F;8&#x3D;370。</p>
</blockquote>
<h5 id="4-3-2-IPv4地址与NAT"><a href="#4-3-2-IPv4地址与NAT" class="headerlink" title="4.3.2 IPv4地址与NAT"></a>4.3.2 IPv4地址与NAT</h5><ol>
<li><p>IPv4地址</p>
<p>​ 连接到因特网的每台主机都分配一个32比特的全球唯一标识符，即<strong>IP地址</strong>。IP地址由互联网名字和数字地址分配机构ICANN进行分配。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C8bf5879a67252c714739ec8e8077e1dbpngpic_center.jpg" alt="image-20230817142123571"></p>
<p>IP地址由网络号和主机号组成。<br>I P 地址 : : &#x3D; { &lt; 网络号 &gt; , &lt; 主机号 &gt; } IP地址::&#x3D;\{&lt;网络号&gt;,&lt;主机号&gt;\} IP地址::&#x3D;{&lt;网络号&gt;,&lt;主机号&gt;}<br><strong>网络号</strong>标志主机（或路由器）所连接到的网络。一个网络号在整个因特网唯一。</p>
<p><strong>主机号</strong>标志该主机（或路由器）自身。一台主机号在相同网络号范围是唯一的。</p>
<p>​ IPv4被分为了5类地址，分别适用于不同规模的网络。</p>
<table>
<thead>
<tr>
<th align="center">网络类型</th>
<th align="center">网络号</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A类</td>
<td align="center">前8位，第1位为0（1-126）</td>
<td align="center">用于大型网络</td>
</tr>
<tr>
<td align="center">B类</td>
<td align="center">前16位，前2位为10（128-191）</td>
<td align="center">用于中等规模网络</td>
</tr>
<tr>
<td align="center">C类</td>
<td align="center">前24位，前3位为110（192~223）</td>
<td align="center">用于小型网络</td>
</tr>
<tr>
<td align="center">D类</td>
<td align="center">开头1110（224-239）</td>
<td align="center">多播地址，用于向多个目标发送数据</td>
</tr>
<tr>
<td align="center">E类</td>
<td align="center">开头1111（240-255）</td>
<td align="center">保留地址，目前还没有被使用</td>
</tr>
</tbody></table>
<p>​ 某些IP地址有着特殊用途，不能做主机IP地址。</p>
<ul>
<li><strong>主机号全为0</strong>表示<strong>本网络本身</strong>，如202.98.174.0。</li>
<li><strong>主机号全为1</strong>表示<strong>本网络的广播地址</strong>，又称直接广播地址，如202.98.174.255。</li>
<li><strong>127.×.×.×</strong>保留为<strong>环回自检</strong>（Loopback Test）地址，此地址表示任意主机本身，目的地址为环回地址的P数据报永远不会出现在任何网络上。</li>
<li><strong>32位全为0</strong>，即0.0.0.0表示本网络上的<strong>本主机</strong>。</li>
<li><strong>32位全为1</strong>，即255.255.255.255表示整个TCP&#x2F;P网络的广播地址，又称<strong>受限广播地址</strong>。实际使用时，由于路由器对广播域的隔离，255.255.255.255等效为<strong>本网络的广播地址</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">网络类别</th>
<th align="center">最大可用网络数</th>
<th align="center">第一个可用的网络号</th>
<th align="center">最后一个可用的网络号</th>
<th align="center">网络中最大主机数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">27-2</td>
<td align="center">1</td>
<td align="center">126</td>
<td align="center">224-2</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">214</td>
<td align="center">128.0</td>
<td align="center">191.255</td>
<td align="center">216-2</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">221</td>
<td align="center">192.0.0</td>
<td align="center">223.255.255</td>
<td align="center">28-2</td>
</tr>
</tbody></table>
<blockquote>
<p>A类地址可用的网络数为27-2，减2的原因是：第一，网络号字段全为0的IP地址是保留地址，意思是“本网络”；第二，网络号为127的P地址是环回自检地址。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">网络号</th>
<th align="center">主机号</th>
<th align="center">作为源地址</th>
<th align="center">作为目的地址</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全0</td>
<td align="center">全0</td>
<td align="center">可以</td>
<td align="center">不可以</td>
<td align="center">本网范围内表示主机，路由表中用于表示默认路由</td>
</tr>
<tr>
<td align="center">（表示整个Internet网络）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">全0</td>
<td align="center">特定值</td>
<td align="center">可以</td>
<td align="center">不可以</td>
<td align="center">表示本网内某个特定主机</td>
</tr>
<tr>
<td align="center">全1</td>
<td align="center">全1</td>
<td align="center">不可以</td>
<td align="center">可以</td>
<td align="center">本网广播地址（路由器不转发）</td>
</tr>
<tr>
<td align="center">特定值</td>
<td align="center">全0</td>
<td align="center">不可以</td>
<td align="center">不可以</td>
<td align="center">网络地址，表示一个网络</td>
</tr>
<tr>
<td align="center">特定值</td>
<td align="center">全1</td>
<td align="center">不可以</td>
<td align="center">可以</td>
<td align="center">直接广播地址，对特定网络上的所有主机进行广播</td>
</tr>
<tr>
<td align="center">127</td>
<td align="center">任何数</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">非全0&#x2F;1</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">用于本地软件环回测试，称为环回地址</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>IP地址特点</strong>：</p>
<ul>
<li><p>IP地址是一种分等级的地址结构。其好处如下：</p>
<p>①在分配IP地址时只分配网络号，而主机号则由得到该网络的单位自行分配，方便了 IP地址的管理；</p>
<p>②路由器仅根据目的主机所连接的网络号来转发分组，减小了路由表所占的存储空间。</p>
</li>
<li><p>IP地址是标志一台主机（或路由器）和一条链路的接口。</p>
</li>
</ul>
<p>当一台主机同时连接到两个网络时，该主机就必须同时具有两个相应的IP地址，每个IP地址的网络号必须与所在网络的网络号相同，且这两个IP地址的主机号是不同的。</p>
<p>IP网络上的一个路由器必然至少应具有两个IP地址（路由器每个端口必须至少分配一个IP地址）。</p>
<ul>
<li><p>用网桥连接的若干LAN仍然是同一个网络（同一个广播域），因此该LAN中所有主机的IP地址的网络号必须相同，但主机号必须不同。</p>
</li>
<li><p>在IP地址中，所有分配到网络号的网络（无论是LAN还是WAN）都是平等的。</p>
</li>
<li><p>在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的。</p>
</li>
</ul>
<blockquote>
<p>由于广泛使用无分类IP地址进行路由选择，这种传统分类的IP地址已成为历史。</p>
</blockquote>
</li>
<li><p>网络地址转换（NAT）</p>
<p>​ <strong>网络地址转换</strong>（NAT）是指通过将专用网络地址（如Intranet）转换为公用地址（如Internet），从而对外隐藏内部管理的IP地址。其优势如下：</p>
<ul>
<li>它使得整个专用网只<strong>需要一个全球IP地址</strong>就可以与因特网连通。</li>
<li>由于<strong>专用网本地IP地址是可重用</strong>的，所以NAT大大节省了IP地址的消耗。</li>
<li>它隐藏了内部网络结构，从而<strong>降低了内部网络受到攻击的风险</strong>。</li>
</ul>
<p>为了网络安全，划出了部分IP地址为<strong>私有IP地址</strong>。其特点如下：</p>
<ul>
<li><p>私有IP只用于LAN，不用于WAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet。</p>
</li>
<li><p>私有IP地址被LAN重复使用。有效地解决了P地址不足的问题。</p>
</li>
</ul>
<p><strong>私有IP地址网段</strong>如下：</p>
<ul>
<li>A类：1个A类网段，即<strong>10</strong>.0.0.0~<strong>10</strong>.255.255.255。</li>
<li>B类：16个B类网段，即<strong>172.16</strong>.0.0~<strong>172.31</strong>.255.255。</li>
<li>C类：256个C类网段，即<strong>192.168</strong>.0.0~<strong>192.168</strong>.255.255。</li>
</ul>
<p>​ 在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。</p>
<p>​ 这种采用私有 IP地址的互联网络称为<strong>专用互联网</strong>或<strong>本地互联网</strong>。私有IP地址也称<strong>可重用地址</strong>。</p>
<p>​ 使用NAT时需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部<strong>全球IP地址</strong>。使用本地地址的主机和外界通信时，NAT路由器使用<strong>NAT转换表</strong>进行本地IP地址和全球IP地址的转换。</p>
<p>​ NAT转换表存放着 { 本地 I P 地址：端口 } \{本地IP地址：端口\} {本地IP地址：端口}到 { 全球 I P 地址：端口 } \{全球IP地址：端口\} {全球IP地址：端口}的映射。该端口号是逻辑上的端口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C6c30e5e4c0eca1ee039a63bf4dfac707pngpic_center.jpg" alt="image-20230817154901058"></p>
<blockquote>
<p>例，一个宿舍办理了电信宽带，拥有了一个全球IP：138.76.29.7；宿舍内4台主机有了私有地址：192.168.0.0网段。宿舍网关开启NAT功能，NAT表如上图所示。</p>
<p>当路由器LAN端收到源IP为192.168.0.2,2233时，将其映射为138.76.29.7,5001，从WAN口发至因特网。</p>
<p>当路由器从WAN端收到目的地址为138.76.29.7,5060的数据报时，将其映射成192.168.0.3,1234，然后从LAN端口发送给相应的本地主机。</p>
</blockquote>
</li>
</ol>
<p>​ <strong>NAT工作原理</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C99e83e2d74a73b12407f9b4f74938ef8pngpic_center.jpg" alt="image-20230817161347419"></p>
<ul>
<li>①假设用户主机10.0.0.1（随机端口3345）向Web服务器128.119.40.186（端口80）发送请求。</li>
<li>②NAT路由器收到IP分组后，为该IP分组生成一个新端口号5001，将IP分组的源地址更改为138.76.29.7（即NAT路由器的全球IP地址），将源端口号更改为5001。NAT路由器在NAT转换表中增加一个表项。</li>
<li>③Web服务器并不知道刚抵达的IP分组已被NAT路由器进行了改装，更不知道用户的专用地址，它响应的IP分组的目的地址是NAT路由器的全球IP地址，目的端口号是5001。</li>
<li>④响应分组到达NAT路由器后，通过NAT转换表将IP分组的目的IP地址更改为10.0.0.1，将目的端口号更改为3345。</li>
</ul>
<blockquote>
<p>普通路由器在转发P数据报时，不改变其源P地址和目的P地址。而NAT路由器在转发IP数据报时，一定要更换其IP地址（转换源P地址或目的IP地址）。</p>
<p>普通路由器仅工作在<strong>网络层</strong>，而NAT路由器转发数据报时需要查看和转换<strong>传输层的端口号</strong>。</p>
</blockquote>
<h5 id="4-3-3-子网划分与子网掩码、CIDR"><a href="#4-3-3-子网划分与子网掩码、CIDR" class="headerlink" title="4.3.3 子网划分与子网掩码、CIDR"></a>4.3.3 子网划分与子网掩码、CIDR</h5><ol>
<li><p>子网划分</p>
<p>由于两级IP地址有以下缺点，于是在IP增加<strong>子网号段</strong>：</p>
<ul>
<li><p>IP地址空间的利用率有时很低</p>
</li>
<li><p>给每个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏</p>
</li>
<li><p>两级的IP地址不够灵活。</p>
</li>
</ul>
<p><strong>子网划分</strong>：增加子网号段，使两级IP变成三级IP地址。基本思路如下：</p>
<ul>
<li><p>子网划分纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</p>
</li>
<li><p>从主机号借位作为子网号；三级IP地址结构如下：<br>I P 地址 &#x3D; { &lt; 网络号 &gt; , &lt; 子网号 &gt; , &lt; 主机号 &gt; } IP地址&#x3D;\{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;\} IP地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</p>
</li>
<li><p>凡是从其他网络发送给本单位某台主机的IP数据报，仍然是根据IP数据报的目的网络号先找到连接到本单位网络上的路由器。然后该路由器在收到IP数据报后，按目的网络号和子网号找到目的子网。最后把IP数据报直接交付给目的主机。</p>
</li>
</ul>
<p><strong>性质</strong>：</p>
<ul>
<li><p>子网中的主机号为全0或全1的地址都不能被指派</p>
</li>
<li><p>子网中的主机号全0的地址为子网的<strong>网络号</strong>，主机号全1的地址为子网的<strong>广播地址</strong></p>
</li>
</ul>
</li>
<li><p>子网掩码</p>
<p>​ 为了告诉主机或路由器对网络进行了子网划分，使用<strong>子网掩码</strong>来表达对原网络中主机号的<strong>借位</strong>。</p>
<p>​ <strong>子网掩码</strong>是一个与IP地址相对应的、长32bit的二进制串，它由一串1和跟随的一串0组成。1对应于IP地址中的网络号及子网号，而0对应于主机号。</p>
<p>​ 规定所有网络必需使用子网掩码，不划分采用默认子网掩码：</p>
<ul>
<li>A类：255.0.0.0</li>
<li>B类：255.255.0.0</li>
<li>C类：255.255.255.0</li>
</ul>
<p>注意：</p>
<p>1）一个主机在设置IP地址信息的同时，必须设置子网掩码</p>
<p>2）同属于一个子网的所有主机以及路由器的相应端口，必须设置相同的子网掩码</p>
<p>3）路由器的路由表中，所包含的信息其主要内容必须有：目的网络地址、子网掩码、下一跳地址</p>
</li>
<li><p>无分类编址CIDR</p>
<p>​ <strong>无分类域间路由选择CIDR</strong>是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法。 IP地址结构如下：<br>I P : : &#x3D; { &lt; 网络前缀 &gt; , &lt; 主机号 &gt; } IP::&#x3D;\{&lt;网络前缀&gt;,&lt;主机号&gt;\} IP::&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;}<br>​ CIDR地址块中的地址数一定是2的整数次幕，实际可指派的地址数通常为2N-2；N表示主机号的位数，主机号全0代表网络号，主机号全1为广播地址。</p>
<p>​ <strong>CIDR记法</strong>：IP地址后加上“&#x2F;”，然后写上网络前缀（可以任意长度）的位数。</p>
<blockquote>
<p>例如，对于128.14.32.5&#x2F;20这个地址，它的掩码是20个连续的1和后续12个连续的0，通过逐位相“与”的方法可以得到该地址的网络前缀（或直接截取前20位）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cc4d25b2997a4fc8e8cb72888a0fe7ef7pngpic_center.jpg" alt="image-20230817170446467"></p>
</blockquote>
<p>​ <strong>构成超网</strong>：将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p>
<p>​ 路由聚合使得路由表中的一个项目可以表示多个原来传统分类地址的路由，有利于减少路由器之间的信息的交换，从而提高网络性能。</p>
<p>​ 方法：将网络前缀缩短（所有网络地址取交集）。</p>
<blockquote>
<p>例如，网络1的地址块是206.1.0.0&#x2F;17；网络2的地址块是206.1.128.0&#x2F;17。</p>
<p>可以看出两个网络前16位相同，第17位分别是0和1，因此可以聚合成更大地址块206.1.0.0&#x2F;16。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C372575f9bca2f1f2d2d0fc67d39b8509pngpic_center.jpg" alt="image-20230817171351432"></p>
<p>如果不使用路由聚合，那么R1的路由表中需要分别有到网络1和网络2的路由表项。聚合后，到网络1和网络2的两条路由就可以聚合成一条到206.1.0.0&#x2F;16的路由。</p>
</blockquote>
<p>​ <strong>最长前缀匹配</strong>：使用CIDR时，查找路由表可能得到几个匹配结果（跟网络掩码按位相与），应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。</p>
<p>​ <strong>CIDR查找路由表的方法</strong>：为了更加有效地查找最长前缀匹配，通常将无分类编址的路由表存放在一种层次式数据结构中，然后自上而下地按层次进行查找。这里最常用的数据结构就是二叉线索。</p>
</li>
<li><p>网络层转发分组的过程</p>
</li>
</ol>
<p>​ 分组转发都是基于目的主机所在网络的，这是因为互联网上的网络数远小于主机数，可以极大地压缩转发表的大小。当分组到达路由器后，路由器根据目的IP地址的网络前缀来查找转发表，确定下一跳应当到哪个路由器。</p>
<p>​ 在转发表中，每条路由必须有下面两条信息：<br>( 目的地址，下一跳地址 ) (目的地址，下一跳地址) (目的地址，下一跳地址)<br>​ 这样，IP数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次间接交付），当到达最后一个路由器时，才试图向目的主机进行直接交付。</p>
<p>​ 采用CIDR编址时，如果一个分组在转发表中可以找到多个匹配的前缀，那么应当选择前缀最长的一个作为匹配的前缀，称为最长前缀匹配。</p>
<p>​ 为了更快地查找转发表，可以按照<strong>前缀的长短排序</strong>，将前缀最长的排在第1行，按前缀长度的降序排列。这样，从第1行最长的开始查找，只要检索到匹配的，就不必再继续查找。</p>
<p>​ 此外，转发表中还可以增加两种特殊的路由：</p>
<ul>
<li><p><strong>主机路由</strong>：对特定目的主机的IP地址专门指明一个路由，以方便网络管理员控制和测试网络。若特定主机的IP地址是a.b.c.d，则转发表中对应项的目的网络是a.b.c.d&#x2F;32。<br>&#x2F;32表示的子网掩码没有意义，但这个特殊的前缀可以用在转发表中。</p>
</li>
<li><p><strong>默认路由</strong>：用特殊前缀0.0.0.0&#x2F;0表示默认路由，全0掩码和任何目的地址进行按位与运算，结果必然为全0，即必然和转发表中的0.0.0.0&#x2F;0相匹配。只要目的网络是其他网络（不在转发表中），就一律选择默认路由。</p>
<p><strong>分组转发算法</strong>如下：</p>
<p>1）从收到的IP分组的首部提取目的主机的IP地址D（即目的地址）。</p>
<p>2）若查找到特定主机路由（目的地址为D），就按照这条路由的下一跳转发分组；否则从转发表中的下一条（即按前缀长度的顺序）开始检查，执行步骤3）。</p>
<p>3）将这一行的子网掩码与目的地址D进行按位与运算。若运算结果与本行的前缀匹配，则查找结束，按照“下一跳”指出的进行处理（或者直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器）。否则，若转发表还有下一行，则对下一行进行检查，重新执行步骤3）。否则，执行步骤4）。</p>
<p>4）若转发表中有一个默认路由，则把分组传送给默认路由；否则，报告转发分组出错。</p>
</li>
</ul>
<h5 id="4-3-4-ARP、DHCP与ICMP"><a href="#4-3-4-ARP、DHCP与ICMP" class="headerlink" title="4.3.4 ARP、DHCP与ICMP"></a>4.3.4 ARP、DHCP与ICMP</h5><ol>
<li><p>IP地址与硬件地址</p>
<p><strong>IP地址</strong>是网络层使用的地址，它是分层次等级的。</p>
<p><strong>硬件地址</strong>是数据链路层使用的地址（MAC地址），它是平面式的。</p>
<p>​ 在网络层及网络层之上使用IP地址，IP地址放在IP数据报的首部，而MAC地址放在MAC帧的首部。通过数据封装，把IP数据报分组封装为MAC帧后，数据链路层看不见数据报分组中的IP地址。</p>
<p>​ 1）在IP层抽象的互联网上只能看到IP数据报。</p>
<p>​ 2）虽然在IP数据报首部中有源IP地址，但路由器只根据目的IP地址进行转发。</p>
<p>​ 3）在局域网的链路层，只能看见MAC帧。IP数据报被封装在MAC帧中，通过路由器转发IP分组时，IP分组在每个网络中都被路由器解封装和重新封装，其MAC帧首部中的源地址和目的地址会不断改变。这也决定了无法使用MAC地址跨网络通信。</p>
<p>​ 4）尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层这些复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机与主机或路由器之间的通信。</p>
</li>
<li><p>地址解析协议（ARP）</p>
<p>​ 无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用<strong>硬件地址</strong>。</p>
<p>​ **地址解析协议（ARP）**作用是完成IP地址到MAC地址的映射。</p>
<p>​ <strong>ARP表</strong>：局域网上各主机和路由器的<strong>IP地址到MAC地址的映射表</strong>，称<strong>ARP表</strong>。使用ARP来动态维护ARP表。</p>
<p>​ <strong>工作原理</strong>：</p>
<ul>
<li><p>主机A欲向本局域网上的某台主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的IP地址。</p>
<ul>
<li>如果有，就可查出其对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。</li>
<li>如果没有，那么就通过使用目的MAC地址为FFFF-FF-FF-FF-FF的帧来封装并广播ARP请求分组（广播发送），使同一个局域网里的所有主机都收到此ARP请求。</li>
</ul>
</li>
<li><p>主机B收到该ARP请求后，向主机A发出ARP响应分组（单播发送），分组中包含<strong>主机B的IP与MAC地址的映射关系</strong>，主机A收到ARP响应分组后就将此映射写入ARP缓存，然后按查询到的硬件地址发送MAC帧。</p>
<blockquote>
<p>ARP由于“看到了”IP地址，所以它工作在网络层，而NAT路由器由于“看到了”端口，所以它工作在传输层。</p>
</blockquote>
<p><strong>使用ARP的4种典型情况总结如下</strong>：</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cc2c2bbd0b3e6adddb1a74a01d1ca8de5pngpic_center.jpg" alt="image-20230817175108090"></p>
<ul>
<li>发送方是<strong>主机</strong>（如H1），要把IP数据报发送到<strong>本网络上的另一台主机</strong>（如H2）。这时H1在网1用ARP找到目的主机H2的硬件地址。</li>
<li>发送方是<strong>主机</strong>（如H1），要把IP数据报发送到<strong>另一个网络上的一台主机</strong>（如H3）。这时H1用ARP找到与网1连接的<strong>路由器R1</strong>的硬件地址，剩下的工作由R1来完成。</li>
<li>发送方是<strong>路由器</strong>（如R1），要把IP数据报转发到<strong>与R1连接的网络（网2）上的一台主机（如H3）</strong>。这时R1在网2用ARP找到目的主机H3的硬件地址。</li>
<li>发送方是<strong>路由器</strong>（如R1），要把IP数据报转发到<strong>网3上的一台主机</strong>（如H4）。这时R1在网2用ARP找到与网2连接的<strong>路由器R2的硬件地址</strong>，剩下的工作由R2来完成。</li>
</ul>
<blockquote>
<p>从IP地址到硬件地址的解析是自动进行的，主机的用户并不知道这种地址解析过程</p>
</blockquote>
</li>
<li><p>动态主机配置协议（DHCP）</p>
<p>​ <strong>动态主机配置协议</strong>(Dynamic Host Configuration Protocol, DHCP)常用于给主机<strong>动态分配IP地址</strong>。</p>
<p>​ <strong>工作原理</strong>：应用层协议，使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。</p>
<ul>
<li><p>1）需要IP地址的主机在启动时向DHCP服务器广播发送发现报文，这时该主机成为DHCP客户</p>
</li>
<li><p>2）本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库中查找该计算机的配置信息</p>
</li>
<li><p>3）若找到，则返回找到的信息。若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文</p>
</li>
</ul>
<p>​ DHCP服务器与客户端<strong>交换过程</strong>：</p>
<ul>
<li>1）DHCP客户机<strong>广播</strong>“<strong>DHCP发现</strong>”消息，试图找到网络中的DHCP服务器，以便从DHCP服务器获得一个IP地址。源地址为0.0.0.0，目的地址为255.255.255.255。</li>
<li>2）DHCP服务器收到“DHCP发现”消息后，<strong>广播</strong>“<strong>DHCP提供</strong>”消息，其中包括提供给DHCP客户机的<strong>IP地址</strong>。源地址为<strong>DHCP服务器地址</strong>，目的地址为255.255.255.255。</li>
<li>3）DHCP客户机收到“<strong>DHCP提供</strong>”消息，如果接受该IP地址，那么就广播“<strong>DHCP请求</strong>”消息向DHCP服务器请求提供IP地址。源地址为0.0.0.0，目的地址为255.255.255.255。</li>
<li>4）DHCP服务器<strong>广播</strong>“<strong>DHCP确认</strong>”消息，将IP地址<strong>分配给DHCP客户机</strong>。源地址为DHCP服务器地址，目的地址为255.255.255.255。</li>
</ul>
<p>#mermaid-svg-JQ7ZviGKPnUQkqRC {font-family:”trebuchet ms”,verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-JQ7ZviGKPnUQkqRC .error-icon{fill:#552222;}#mermaid-svg-JQ7ZviGKPnUQkqRC .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-JQ7ZviGKPnUQkqRC .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-JQ7ZviGKPnUQkqRC .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-JQ7ZviGKPnUQkqRC .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-JQ7ZviGKPnUQkqRC .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-JQ7ZviGKPnUQkqRC .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-JQ7ZviGKPnUQkqRC .marker{fill:#333333;stroke:#333333;}#mermaid-svg-JQ7ZviGKPnUQkqRC .marker.cross{stroke:#333333;}#mermaid-svg-JQ7ZviGKPnUQkqRC svg{font-family:”trebuchet ms”,verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-JQ7ZviGKPnUQkqRC .actor{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#mermaid-svg-JQ7ZviGKPnUQkqRC text.actor&gt;tspan{fill:black;stroke:none;}#mermaid-svg-JQ7ZviGKPnUQkqRC .actor-line{stroke:grey;}#mermaid-svg-JQ7ZviGKPnUQkqRC .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333;}#mermaid-svg-JQ7ZviGKPnUQkqRC .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:#333;}#mermaid-svg-JQ7ZviGKPnUQkqRC #arrowhead path{fill:#333;stroke:#333;}#mermaid-svg-JQ7ZviGKPnUQkqRC .sequenceNumber{fill:white;}#mermaid-svg-JQ7ZviGKPnUQkqRC #sequencenumber{fill:#333;}#mermaid-svg-JQ7ZviGKPnUQkqRC #crosshead path{fill:#333;stroke:#333;}#mermaid-svg-JQ7ZviGKPnUQkqRC .messageText{fill:#333;stroke:#333;}#mermaid-svg-JQ7ZviGKPnUQkqRC .labelBox{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#mermaid-svg-JQ7ZviGKPnUQkqRC .labelText,#mermaid-svg-JQ7ZviGKPnUQkqRC .labelText&gt;tspan{fill:black;stroke:none;}#mermaid-svg-JQ7ZviGKPnUQkqRC .loopText,#mermaid-svg-JQ7ZviGKPnUQkqRC .loopText&gt;tspan{fill:black;stroke:none;}#mermaid-svg-JQ7ZviGKPnUQkqRC .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);}#mermaid-svg-JQ7ZviGKPnUQkqRC .note{stroke:#aaaa33;fill:#fff5ad;}#mermaid-svg-JQ7ZviGKPnUQkqRC .noteText,#mermaid-svg-JQ7ZviGKPnUQkqRC .noteText&gt;tspan{fill:black;stroke:none;}#mermaid-svg-JQ7ZviGKPnUQkqRC .activation0{fill:#f4f4f4;stroke:#666;}#mermaid-svg-JQ7ZviGKPnUQkqRC .activation1{fill:#f4f4f4;stroke:#666;}#mermaid-svg-JQ7ZviGKPnUQkqRC .activation2{fill:#f4f4f4;stroke:#666;}#mermaid-svg-JQ7ZviGKPnUQkqRC .actorPopupMenu{position:absolute;}#mermaid-svg-JQ7ZviGKPnUQkqRC .actorPopupMenuPanel{position:absolute;fill:#ECECFF;box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);filter:drop-shadow(3px 5px 2px rgb(0 0 0 &#x2F; 0.4));}#mermaid-svg-JQ7ZviGKPnUQkqRC .actor-man line{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#mermaid-svg-JQ7ZviGKPnUQkqRC .actor-man circle,#mermaid-svg-JQ7ZviGKPnUQkqRC line{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;stroke-width:2px;}#mermaid-svg-JQ7ZviGKPnUQkqRC :root{–mermaid-font-family:”trebuchet ms”,verdana,arial,sans-serif;} 客户端 服务器 DHCP发现 DHCP提供 DHCP请求 DHCP确认 客户端 服务器</p>
<p>​ <strong>DHCP特点</strong>：</p>
<ul>
<li>DHCP允许网络上<strong>配置多台DHCP服务器</strong>，当DHCP客户机发出“DHCP发现”消息时，有可能收到多个应答消息。这时，DHCP<strong>客户机</strong>只会挑选其中的一个，通常挑选最先到达的。</li>
<li>DHCP服务器分配给DHCP客户的<strong>IP地址是临时</strong>的，因此DHCP客户只能在一段有限的时间内使用这个分配到的IP地址。DHCP称这段时间为<strong>租用期</strong>。租用期的数值应由DHCP服务器自己决定，DHCP客户也可在自己发送的报文中提出对租用期的要求。</li>
<li>DHCP的客户端和服务器端需要通过<strong>广播方式</strong>来进行交互，原因是在DHCP执行初期，客户端不知道服务器端的IP地址，而在执行中间，<strong>客户端并未被分配IP地址</strong>，从而导致两者之间的通信必须采用<strong>广播</strong>的方式。采用<strong>UDP</strong>而不采用TCP的原因也很明显：<strong>TCP需要建立连接</strong>，如果连对方的IP地址都不知道，那么更不可能通过双方的套接字建立连接。</li>
<li>DHCP是应用层协议，因为它是通过客户&#x2F;服务器模式工作的，DHCP客户端向DHCP服务器请求服务，而其他层次的协议是没有这两种工作方式的。</li>
</ul>
</li>
<li><p>网际控制报文协议（ICMP）</p>
<p>​ <strong>网际控制报文协议</strong>（Internet Control Message Protocol，ICMP）提高IP数据报交付成功的机会。</p>
<p>​ ICMP是网络层协议。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C262d5255365d1e6e2c26e6f4544487bfpngpic_center.jpg" alt="image-20230818095720773"></p>
<p>​ ICMP分为两类，即<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong>。</p>
<ul>
<li><p><strong>ICMP差错报告报文</strong>：用于目标主机或到目标主机路径上的<strong>路由器向源主机报告差错和异常情况</strong>。</p>
<p>ICMP差错报告报文可分为以下5类：</p>
<ul>
<li><strong>终点不可达</strong>。当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</li>
<li><strong>源点抑制</strong>。当路由器或主机由于<strong>拥塞</strong>而丢弃数据报时，就向源点发送源点抑制报文。</li>
<li><strong>时间超过</strong>。当路由器<strong>收到生存时间（TTL）为零</strong>的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li>
<li><strong>参数问题</strong>。当路由器或目的主机收到的数据报的首部中有的<strong>字段的值不正确</strong>时，就丢弃该数据报，并向源点发送参数问题报文。</li>
<li><strong>改变路由（重定向）</strong>。路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li>
</ul>
<p>ICMP差错报告报文格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C4dce3339e3cbd96eb86eecaaf9faa902pngpic_center.jpg" alt="image-20230818100345654"></p>
<p>​ 把收到的需要进行差错报告的<strong>IP数据报</strong>的<strong>首部</strong>和<strong>数据字段的前8个字节</strong>提取出来，作为ICMP报文的数据字段。再加上相应的ICMP差错报告报文的<strong>前8个字节</strong>，就构成了<strong>ICMP差错报告报文</strong>。</p>
<p>​ 提取收到的数据报的数据字段前8个字节是为了<strong>得到运输层的端口号</strong>（对于TCP和UDP）以及运输<strong>层报文的发送序号</strong>（对于TCP）。</p>
<p>​ 整个ICMP报文作为IP数据报的数据字段发送给源点。</p>
<p>​ 不应发送ICMP差错报告报文的几种情况如下：</p>
<ul>
<li>1）对ICMP差错报告报文不再发送ICMP差错报告报文。</li>
<li>2）对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li>
<li>3）对具有组播地址的数据报都不发送ICMP差错报告报文。</li>
<li>4）对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。</li>
</ul>
</li>
<li><p><strong>ICMP询问报文</strong>：共有以下几类，常用的是前两类。</p>
<ul>
<li><strong>回送请求和回答报文</strong>：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong>。</li>
<li><strong>时间戮请求和回答报文</strong>：请主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。</li>
<li><strong>掩码地址请求和回答报文</strong></li>
<li><strong>路由器询问和通告报文</strong></li>
</ul>
<blockquote>
<p>PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文。工作在应用层。</p>
<p>Traceroute: 跟踪一个分组从源点到终点的路径, 使用了ICMP时间超过差错报告报文; 工作在网络层。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">工作层次</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ARP</td>
<td align="center">网络层</td>
<td align="center">IP到MAC地址的映射</td>
</tr>
<tr>
<td align="center">DHCP</td>
<td align="center">应用层；基于UDP；客户&#x2F;服务器模式</td>
<td align="center">动态分配IP地址</td>
</tr>
<tr>
<td align="center">ICMP</td>
<td align="center">网络层；基于IP</td>
<td align="center">检测网络连通性和故障诊断</td>
</tr>
</tbody></table>
<h4 id="4-4-IPv6"><a href="#4-4-IPv6" class="headerlink" title="4.4 IPv6"></a>4.4 IPv6</h4><h5 id="4-4-1-IPv6的主要特点"><a href="#4-4-1-IPv6的主要特点" class="headerlink" title="4.4.1 IPv6的主要特点"></a>4.4.1 IPv6的主要特点</h5><ol>
<li><p>解决IP地址耗尽问题措施有以下三种：</p>
<ul>
<li>①采用无类别编址CIDR，使IP地址的分配更加合理；</li>
<li>②采用网络地址转换（NAT）方法以节省全球IP地址；</li>
<li>③采用具有更大地址空间的新版本的IPv6。</li>
</ul>
<p>其中前两种方法只是延长了IPv4地址分配完毕的时间，只有第三种方法<strong>从根本上解决了IP地址的耗尽问题</strong>。</p>
</li>
<li><p>IPv6<strong>特点</strong>如下：</p>
<ul>
<li>1）更大的地址空间。IPv6将地址从IPv4的32位增大到了128位。IPv6的字节数（16B）是IPv4字节数（4B）的平方。</li>
<li>2）扩展的地址层次结构。</li>
<li>3）灵活的首部格式。</li>
<li>4）改进的选项。</li>
<li>5）允许协议继续扩充。</li>
<li>6）支持即插即用（即自动配置）。</li>
<li>7）支持资源的预分配。</li>
<li>8）IPν6只有在包的源结点才能分片，是端到端的，传输路径中的路由器不能分片，所以从一般意义上说，IPv6不允许分片（不允许类似IPv4的路由分片）。</li>
<li>9）IPv6首部长度必须是8B的整数倍，而IPv4首部是4B的整数倍。</li>
<li>10）增大了安全性。身份验证和保密功能是PV6的关键特征。</li>
</ul>
</li>
<li><p>IPv6数据报格式</p>
<p>IPv6数据报由两大部分组成，即<strong>基本首部</strong>（base header）和后面的<strong>有效载荷</strong>（payload）。</p>
<p>有效载荷允许有零个或<strong>多个扩展首部</strong>（extension header），再后面是数据部分。但所有的扩展首部并不属于IPv6数据报的首部。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C6a054a8048cc07f90e4cbcf53eead7bfpngpic_center.jpg" alt="image-20230818104258996"></p>
<p>与IPv4的首部区别有：</p>
<ul>
<li>取消了首部长度字段，因为它的首部长度是固定的（40字节）。</li>
<li>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。</li>
<li>取消了总长度字段，改用有效载荷长度字段。</li>
<li>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。</li>
<li>把TTL字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。</li>
<li>取消了协议字段，改用下一个首部字段。</li>
<li>取消了<strong>检验和字段</strong>，这样就加快了路由器处理数据报的速度。我们知道，在数据链路层对检测出有差错的帧就丢弃。在运输层，当使用UDP时，若检测出有差错的用户数据报就丢弃。当使用TCP时，对检测出有差错的报文段就重传，直到正确传送到目的进程为止。因此在网络层的差错检测可以精简掉。</li>
<li>取消了选项字段，而用扩展首部来实现选项功能。</li>
</ul>
<p>把首部字段不必要功能取消后，使得IPv6首部字段减少到8个，首部结构如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C4286117f750f120329f3df28123c9dcepngpic_center.jpg" alt="image-20230818104908071"></p>
<ul>
<li><p>版本：指明了协议版本，字段是6。</p>
</li>
<li><p>通信量类：区分数据报的类别和优先级。</p>
</li>
<li><p>流标号：“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同个流的数据报都具有同样的流标号。</p>
</li>
<li><p>有效载荷长度：指明数据报扩展首部加数据长度，最大值是64K。</p>
</li>
<li><p>下一个首部：有扩展首部时，标识下一个扩展首部；没有扩展首部时，指出数据应交付的上层协议。</p>
</li>
<li><p>跳数限制：相当于IPv4的TTL，最大为255。</p>
</li>
</ul>
<p><strong>扩展首部功能</strong>：IPv6把原来IPv4首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理，而数据报途中经过的<strong>路由器都不处理这些扩展首部</strong>（只有一个首部例外，即逐跳选项扩展首部），这样就大大<strong>提高了路由器的处理效率</strong>。</p>
<blockquote>
<p>每个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的<strong>第一个字段</strong>都是<strong>8位的“下一个首部”字段</strong>。此字段的值指出了在该扩展首部后面的字段是什么。当使用多个扩展首部时，应按以上的先后顺序出现。<strong>高层首部</strong>总是放在最后面。</p>
</blockquote>
</li>
</ol>
<h5 id="4-4-2-IPv6地址"><a href="#4-4-2-IPv6地址" class="headerlink" title="4.4.2 IPv6地址"></a>4.4.2 IPv6地址</h5><ol>
<li><p>IPv6数据报的目的地址可以是以下三种基本类型地址之一：</p>
<ul>
<li>单播。单播就是传统的点对点通信。</li>
<li>多播。多播是一点对多点的通信，分组被交付到一组计算机的每台计算机。</li>
<li>任播。这是Pν6增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机。</li>
</ul>
</li>
<li><p>IPv6地址表示</p>
<p>​ 在IPV6标准中指定了一种比较紧凑的表示法，即把地址中的<strong>每4位用一个十六进制数</strong>表示，并用<strong>冒号分隔每16位</strong>，如4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170。</p>
<p>​ 当16位域的<strong>开头有一些0</strong>时，可以采用一种缩写表示法，但在域中必须至少有一个数字。例如，可以把地址4BF5:0000:0000:0000:BA5F:<strong>039A</strong>:<strong>000A</strong>:2176缩写为4BF5:0:0:0:BA5F:<strong>39A</strong>:<strong>A</strong>:2176。</p>
<p>​ 当有<strong>相继的0值域</strong>时，还可以进一步缩写。这些域可以用双冒号缩写（::）。双冒号表示法在一个地址中仅能出现一次，因为0值域的个数没有编码，需要从指定的总的域的个数来推算。前述地址可被更紧凑地书写成4BF5::BA5F:39A:A:2176。</p>
</li>
<li><p>IPv6分级</p>
<p>IPv6扩展了IPv4地址的分级概念，为了使路由器能够更快地查找路由。它使用以下3个等级：</p>
<ul>
<li>第一级（顶级）指明全球都知道的公共拓扑</li>
<li>第二级（场点级）指明单个场点</li>
<li>第三级指明单个网络接口</li>
</ul>
</li>
<li><p>IPv4向IPv6过渡</p>
<p>​ 从IPv4向IPv6过渡只能采用逐步演进的办法，同时还必须使新安装的IPv6系统能够向后兼容。IPv6系统必须能够接收和转发IPv4分组，并且能够为IPv4分组选择路由。</p>
<p>​ 过渡方法有以下两种：</p>
<ul>
<li><p><strong>双栈协议</strong>：双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。</p>
<p>如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。</p>
<p>如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</p>
</li>
<li><p><strong>隧道技术</strong>：</p>
<p>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据顿或包。隧道协议<strong>将其它协议的数据顿或包重新封装</strong>然后<strong>通过隧道发送</strong>。</p>
</li>
</ul>
</li>
</ol>
<h4 id="4-5-IP组播"><a href="#4-5-IP组播" class="headerlink" title="4.5 IP组播"></a>4.5 IP组播</h4><h5 id="4-5-1-组播的概念"><a href="#4-5-1-组播的概念" class="headerlink" title="4.5.1 组播的概念"></a>4.5.1 组播的概念</h5><p>​ 为了能够支持像视频点播和视频会议这样的多媒体应用，网络必须实施某种有效的组播机制。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C9c328a48a38b01594d012059a5c61585pngpic_center.jpg" alt="image-20230818155304812"></p>
<p>​ <strong>组播</strong>：是让源计算机一次发送的<strong>单个分组</strong>可以抵达<strong>用一个组地址标识</strong>的<strong>若干目标主机</strong>，并被它们正确接收。</p>
<p>​ 组播基于UDP协议。当主机想利用组播将单个数据发送给一组主机，源主机把数据发给一个组播地址，组播地址可以标识一组地址。网络把这个数据的副本投递给该组中的每台主机。主机可以同时属于多个组。</p>
<p>​ 在IPv4中，每个组播组都有一个D类地址，要给该组发送的计算机使用这个地址作为目标地址。</p>
<p>​ 主机使用**IGMP（因特网组管理协议）**加入组播组。</p>
<p>​ 主机组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发。因此，对发送者而言，数据只需发送一次就可发送到所有接收者，大大减轻了网络的负载和发送者的负担。组播需要路由器的支持才能实现，能够运行组播协议的路由器称为<strong>组播路由器</strong>。</p>
<h5 id="4-5-2-IP组播地址"><a href="#4-5-2-IP组播地址" class="headerlink" title="4.5.2 IP组播地址"></a>4.5.2 IP组播地址</h5><p>​ IP组播使用D类地址格式。D类地址的前四位是1110，因此D类地址范围是224.0.0.0~239.255.255.255。每个D类IP地址标志一个组播组。</p>
<ul>
<li><p>特点：</p>
<p>1）组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP。</p>
<p>2）组播地址只能用于目的地址，不能用于源地址</p>
<p>3）对组播数据报不产生ICMP差错报文。若在PING命令后面键入组播地址，将永远不会收到响应</p>
<p>4）并非所有的D类地址都可作为组播地址</p>
</li>
<li><p>IP组播可以分为两种：</p>
<ul>
<li>一种只在本局域网上进行硬件组播</li>
<li>另一种则在因特网的范围内进行组播</li>
</ul>
<p>在因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员。</p>
</li>
<li><p>硬件组播</p>
<p>​ 组播IP地址也需要相应的<strong>组播MAC地址</strong>在本地网络中实际传送帧。IANA拥有的以太网组播MAC地址的范围是<strong>从01-00-5E-00-00-00到01-00-5E-7F-FF-FF</strong>。不难看出，在每个地址中，只有<strong>23位</strong>可用作组播。这只能和D类IP地址中的23位有一一对应关系。</p>
<p>​ D类IP地址可供分配的有28位，可见在这28位中，前5位不能用来构成以太网的硬件地址，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cc0dd105427a904577095e6566691ee79pngpic_center.jpg" alt="123"></p>
<p>​ 收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p>
</li>
</ul>
<h5 id="4-5-3-IGMP与组播路由算法"><a href="#4-5-3-IGMP与组播路由算法" class="headerlink" title="4.5.3 IGMP与组播路由算法"></a>4.5.3 IGMP与组播路由算法</h5><ol>
<li><p><strong>IGMP网际组管理协议</strong> 网络层协议 基于IP</p>
<ul>
<li><p>目的：IGMP协议让<strong>组播路由器</strong>知道<strong>本局域网上是否有主机</strong>（的进程）参加或退出了某个组播组。</p>
</li>
<li><p>工作阶段：</p>
<ul>
<li><p>1、某主机要加入组播组，向组播地址发送IGMP报文，声明自己要加入组播</p>
<p>本地组播路由器收到报文，转发给因特网其他组播路由器</p>
</li>
<li><p>2、本地组播路由器<strong>周期性探询本地局域网上的主机</strong>，以便知道这些主机是否还是组播组的成员。</p>
<blockquote>
<p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p>
</blockquote>
</li>
</ul>
<p>组播路由器知道的成员关系只是<strong>所连接的局域网</strong>中有无组播组的成员。</p>
</li>
</ul>
</li>
<li><p><strong>组播路由选择协议</strong></p>
<ul>
<li><p>目的：组播路由选择协议目的是<strong>找出以源主机为根节点的组播转发树</strong>。</p>
</li>
<li><p><strong>组播转发树</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cbdd21c91eaf57c5c506867e5c5ab114fpng.jpg" alt="image-20230818162757713"></p>
<ul>
<li><p>组播路由协议目的是找出以源主机为根节点的组播转发树。</p>
</li>
<li><p>构造树可以避免在路由器之间兜圈子。</p>
</li>
<li><p>在组播转发树上的路由器不会收到重复的组播数据报</p>
</li>
<li><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</p>
</li>
</ul>
</li>
<li><p>算法：</p>
<ul>
<li>基于链路状态的路由选择</li>
<li>基于距离-向量的路由选择</li>
<li>协议无关的组播（PIM）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-6-移动IP"><a href="#4-6-移动IP" class="headerlink" title="4.6 移动IP"></a>4.6 移动IP</h4><h5 id="4-6-1-移动IP的概念"><a href="#4-6-1-移动IP的概念" class="headerlink" title="4.6.1 移动IP的概念"></a>4.6.1 移动IP的概念</h5><ol>
<li><p>定义</p>
<p>​ <strong>移动IP技术</strong>是指移动站以<strong>固定的网络IP</strong>地址实现跨越<strong>不同网段</strong>的漫游功能，并保证基于<strong>网络IP的网络权限</strong>在漫游过程中不发生任何改变。移动IP的目标是把<strong>分组自动地投递给移动站</strong>。</p>
</li>
<li><p>移动IP定义了<strong>三种功能实体</strong>：移动节点、本地代理（也称归属代理）和外地代理。</p>
<ul>
<li><strong>移动节点</strong>：具有永久IP地址的移动站。</li>
<li><strong>归属代理（本地代理）</strong>：通常就是连接在归属网络（原始连接到的网络）上的路由器。</li>
<li><strong>永久地址（归属地址&#x2F;主地址）</strong>：移动站点在归属网络中的原始地址。</li>
<li><strong>外部代理（外地代理）</strong>：通常就是连接在被访网络（移动到另一地点所接入的网络）上的路由器。</li>
<li><strong>转交地址（辅地址）</strong>：可以是外部代理的地址或动态配置的一个地址。</li>
</ul>
</li>
</ol>
<h5 id="4-6-2-移动IP通信过程"><a href="#4-6-2-移动IP通信过程" class="headerlink" title="4.6.2 移动IP通信过程"></a>4.6.2 移动IP通信过程</h5><ol>
<li><p>移动IP相关概念的应用</p>
<p>​ 在移动IP中，每个移动站都有一个<strong>原始地址</strong>，即<strong>永久地址（或归属地址）</strong>，<strong>移动站原始连接的网络</strong>称为<strong>归属网络</strong>。永久地址和归属网络的关联是不变的。<strong>归属代理</strong>通常是<strong>连接到归属网络上的路由器</strong>，然而它实现的代理功能是在应用层完成的。</p>
<p>​ 当移动站移动到另一地点，所接入的<strong>外地网络</strong>也称<strong>被访网络</strong>。被访网络中使用的代理称为<strong>外地代理</strong>，它通常是<strong>连接在被访网络上的路由器</strong>。</p>
<p>​ 外地代理有两个重要功能：①要为移动站创建一个<strong>临时地址</strong>，称为<strong>转交地址</strong>。转交地址的网络号显然和被访网络一致。②及时把移动站的<strong>转交地址</strong>告诉其<strong>归属代理</strong>。</p>
<blockquote>
<p>​ 用一个通俗的例子来描述移动IP的通信原理。例如，在以前科技不那么发达的年代，本科毕业时都将走向各自的工作岗位。由于事先并不知道自己未来的准确通讯地址，那么怎样继续和同学们保持联系呢？实际上也很简单。彼此留下各自的家庭地址（即永久地址）。毕业后若要和某同学联系，只要写信寄到该同学的永久地址，再请其家长把信件转交即可。</p>
</blockquote>
</li>
<li><p>移动IP通信过程</p>
<ul>
<li>A刚进入外部网络：<ul>
<li>1.获得<strong>外部代理</strong>的<strong>转交地址</strong>（外部代理广播报文）。</li>
<li>2.移动节点通过<strong>外部代理</strong>发送<strong>注册报文</strong>给<strong>归属代理</strong>（包含永久地址&amp;转交地址）。</li>
<li>3.<strong>归属代理</strong>接收请求，并将移动节点的<strong>永久地址和转交地址绑定</strong>（以后到达该归属代理的数据报且要发往移动节点的数据报将被封装并以<strong>隧道方式</strong>发给<strong>转交地址</strong>），并返回一注册响应报文。</li>
<li>4.<strong>外部代理</strong>接收注册响应，并转发给移动节点。</li>
</ul>
</li>
<li>A移动到了下一个网络：<ul>
<li>1.在<strong>新外部代理</strong>登记注册一个转交地址。</li>
<li>2.新外部代理给<strong>本地代理</strong>发送<strong>新的转交地址</strong>（覆盖旧的）</li>
<li>3.通信</li>
</ul>
</li>
<li>A回到了归属网络：<ul>
<li>1.A向本地代理<strong>注销转交地址</strong>。</li>
<li>2.按原始TCP&#x2F;IP方式通信。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-7-网络层设备"><a href="#4-7-网络层设备" class="headerlink" title="4.7 网络层设备"></a>4.7 网络层设备</h4><h5 id="4-7-1-冲突域和广播域"><a href="#4-7-1-冲突域和广播域" class="headerlink" title="4.7.1 冲突域和广播域"></a>4.7.1 冲突域和广播域</h5><ol>
<li><p>冲突域</p>
<p><strong>冲突域</strong>是指连接到<strong>同一物理介质上的所有结点的集合</strong>，这些结点之间存在<strong>介质争用</strong>的现象。</p>
<blockquote>
<p>在OSI参考模型中，冲突域被视为第1层概念，像集线器、中继器等简单无脑复制转发信号的第1层设备所连接的结点都属于同一个冲突域，也就是说它们不能划分冲突域。而第2层（网桥、交换机）、第3层（路由器）设备都可以划分冲突域。</p>
</blockquote>
</li>
<li><p>广播域</p>
<p><strong>广播域</strong>是指接收同样广播消息的结点集合。也就是说，在该集合中的任何一个结点发送一个广播帧，其他能收到这个帧的结点都被认为是该广播域的一部分。</p>
<blockquote>
<p>在OSI参考模型中，广播域被视为第2层概念，像第1层（集线器等）、第2层（交换机等）设备所连接的结点都属于同一个广播域。而路由器，作为第3层设备，则可以划分广播域，即可以连接不同的广播域。</p>
</blockquote>
<p>通常所说的局域网（LAN）特指使用路由器分割的网络，也就是广播域。</p>
</li>
</ol>
<h5 id="4-7-2-路由器的组成和功能"><a href="#4-7-2-路由器的组成和功能" class="headerlink" title="4.7.2 路由器的组成和功能"></a>4.7.2 路由器的组成和功能</h5><ol>
<li><p>定义</p>
<p>​ 路由器是一种具有<strong>多个输入输出端口的专用计算机</strong>，其任务是<strong>连接不同的网络</strong>（连接异构网络）并完成路由转发。在多个逻辑网络（即多个广播域）互连时必须使用路由器。</p>
</li>
<li><p>路由器转发</p>
<ul>
<li>当源主机要向目标主机发送数据报时，路由器先检查源主机与目标主机是否连接在同一个网络上。</li>
<li>如果源主机和目标主机在同一个网络上，那么直接交付而无须通过路由器。</li>
<li>如果源主机和目标主机不在同一个网络上，那么路由器按照转发表（路由表）指出的路由将数据报转发给下一个路由器，这称为间接交付。</li>
</ul>
</li>
<li><p>路由器结构</p>
<p>整个的路由器结构可划分为两大部分：路由选择部分和分组转发部分。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cdc0c65194789df4a753dc460680e41dcpngpic_center.jpg" alt="image-20230818171015512"></p>
<ul>
<li><p>路由选择：根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表</p>
</li>
<li><p>交换结构：根据转发表（路由表得来）对分组进行转发</p>
</li>
<li><p>分组转发：若收到RIP&#x2F;OSPF分组等，则把分组送往路由选择处理机；若收到数据分组，则查找转发表并输出</p>
</li>
<li><p>输入端口：输入端口中的查找和转发功能在路由器的交换功能中是最重要的。当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C3fe98784ad36833dd95c9aceaa3bf0a4pngpic_center.jpg" alt="image-20230818171141751"></p>
</li>
<li><p>输出端口：若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C1338123e3e2050f3e88a76d7f0e52532pngpic_center.jpg" alt="image-20230818171409238"></p>
<blockquote>
<p>路由器中的输入或输出队列产生溢出是造成<strong>分组丢失</strong>的重要原因。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h5 id="4-7-3-路由表与路由转发"><a href="#4-7-3-路由表与路由转发" class="headerlink" title="4.7.3 路由表与路由转发"></a>4.7.3 路由表与路由转发</h5><p>​ 路由表根据路由选择算法得出的，主要用途是路由选择，总用软件来实现。</p>
<p>​ 标准的路由表有4个项目：目的网络IP地址、子网掩码、下一跳IP地址、接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C157bc66885273b6a40917fd321b0a322pngpic_center.jpg" alt="image-20230818172055422"></p>
<p>​ 上图为一个简单的网络拓扑，R1的路由表如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C3a98199910d2ae806e96b2269379514bpngpic_center.jpg" alt="image-20230818172538393"></p>
<p>​ 转发表由路由表得来，可以用软件实现，也可以用特殊的硬件来实现。转发表必须包含完成转发功能所必需的信息，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息的映射。</p>
<p>​ 为了减少转发表的重复项目，可以使用一个默认路由代替所有具有相同“下一跳” 的项目，并将默认路由设置得比其他项目的优先级低，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C9b0f0c49f26df79d25736f12930ec118pngpic_center.jpg" alt="image-20230818173347615"></p>
<ul>
<li><strong>转发和路由选择的区别</strong>：<ul>
<li>“转发”是路由器根据转发表把收到的P数据报从合适的端口转发出去，它仅涉及一个路由器。</li>
<li>“路由选择”则涉及很多路由器，路由表是许多路由器协同工作的结果。这些路由器按照复杂的路由算法，根据从各相邻路由器得到的网络拓扑的变化情况，动态改变所选择的路由，并由此构造出整个路由表。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，但要注意路由表不等于转发表。分组的实际转发是靠直接<strong>查找转发表</strong>，而不是直接查找路由表。</p>
</blockquote>
<h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5 传输层"></a>5 传输层</h3><h4 id="5-1-传输层提供的服务"><a href="#5-1-传输层提供的服务" class="headerlink" title="5.1 传输层提供的服务"></a>5.1 传输层提供的服务</h4><h5 id="5-1-1-传输层的功能"><a href="#5-1-1-传输层的功能" class="headerlink" title="5.1.1 传输层的功能"></a>5.1.1 传输层的功能</h5><ol>
<li><p>端到端通信</p>
<p>​ 传输层提供<strong>进程和进程（端到端）之间</strong>的逻辑通信。与网络层的区别是，网络层提供的是主机之间的逻辑通信。应用进程之间的通信又称端到端的逻辑通信。</p>
<p>​ 这里“逻辑通信”的意思是：传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间并没有一条水平方向的物理连接。</p>
</li>
<li><p>复用和分用</p>
<ul>
<li><p><strong>复用</strong>是指发送方不同的应用进程都可以使用同一个传输层协议传送数据</p>
</li>
<li><p><strong>分用</strong>是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程</p>
</li>
</ul>
<blockquote>
<p>网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去</p>
<p>网络层的分用是指接收方的网络层在剥去首部后把数据支付给相应的协议</p>
</blockquote>
</li>
<li><p>差错检测</p>
<p>传输层检验首部与数据部分；网路层只检验首部。</p>
</li>
<li><p>提供两种不同的传输协议</p>
<ul>
<li>面向连接的传输控制协议TCP：可靠，面向连接，时延大，适用于大文件</li>
<li>无连接的用户数据报协议UDP：不可靠，无连接，时延小，适用于小文件。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C9f0ca8a07c9dea37ad0776f8bc828928pngpic_center.jpg" alt="image-20230821100425303"></p>
<h5 id="5-1-2-传输层的寻址与端口"><a href="#5-1-2-传输层的寻址与端口" class="headerlink" title="5.1.2 传输层的寻址与端口"></a>5.1.2 传输层的寻址与端口</h5><ol>
<li><p>端口的作用</p>
<p>​ <strong>端口</strong>能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</p>
<p>​ 端口是<strong>传输层服务访问点（TSAP）</strong>，它在传输层的作用类似于<strong>IP地址</strong>在网络层的作用或<strong>MAC地址</strong>在数据链路层的作用，只不过IP地址和MAC地址标识的是主机，而<strong>端口标识的是主机中的应用进程</strong>。</p>
<p>​ 数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口。</p>
<p>​ 在协议栈层间的<strong>抽象的协议端口</strong>是<strong>软件端口</strong>，它与路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。</p>
</li>
<li><p>端口号</p>
<p>应用进程通过端口号进行标识，<strong>端口号长度为16bit</strong>，能够表示65536（216）个不同的端口号。</p>
<p>端口号只具有<strong>本地意义</strong>，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可将端口分为两类：</p>
<ul>
<li><p><strong>服务器端使用的端口号</strong>：它又分为两类，最重要的一类是<strong>熟知端口号</strong>，数值为<strong>0~1023</strong>，IANA（互联网地址指派机构）把这些端口号指派给了TCP&#x2F;IP最重要的一些应用程序，让所有的用户都知道。</p>
<table>
<thead>
<tr>
<th align="center">应用程序</th>
<th align="center">FTP</th>
<th align="center">TELNET</th>
<th align="center">SMTP</th>
<th align="center">DNS</th>
<th align="center">TFTP</th>
<th align="center">HTTP</th>
<th align="center">SNMP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">熟知端口号</td>
<td align="center">21</td>
<td align="center">23</td>
<td align="center">25</td>
<td align="center">53</td>
<td align="center">69</td>
<td align="center">80</td>
<td align="center">161</td>
</tr>
</tbody></table>
<p>另一类称为<strong>登记端口号</strong>，数值为<strong>1024~49151</strong>。它是供没有熟知端口号的应用程序使用的，使用这类端口号必须在LANA登记，以防止重复。</p>
</li>
<li><p><strong>客户端使用的端口号</strong>：数值为<strong>49152~65535</strong>。由于这类端口号<strong>仅在客户进程运行时</strong>才动态地选择，因此又称<strong>短暂端口号</strong>（也称临时端口）。通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程以后使用。</p>
</li>
</ul>
</li>
<li><p>套接字</p>
<p>​ 在网络中通过<strong>IP地址</strong>来标识和区别<strong>不同的主机</strong>，通过<strong>端口号</strong>来标识和区分一台主机中的<strong>不同应用进程</strong>，端口号拼接到IP地址即构成<strong>套接字Socket</strong>。套接字，实际上是一个<strong>通信端点</strong>，即<br>套接字 S o c k e t &#x3D; （ I P 地址：端口号） 套接字Socket&#x3D;（IP地址：端口号） 套接字Socket=（IP地址：端口号）<br>它<strong>唯一地标识网络中的一台主机和其上的一个应用（进程）</strong>。</p>
<p>在网络通信中，主机A发给主机B的报文段包含<strong>目的端口号和源端口号</strong>，源端口号是“返回地址”的一部分，即当B需要发回一个报文段给A时，B到A的报文段中的目的端口号便是A到B的报文段中的源端口号（完全的返回地址是A的P地址和源端口号）。</p>
</li>
</ol>
<blockquote>
<p><strong>面向连接服务</strong>：在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接。</p>
<p><strong>无连接服务</strong>：指两个实体之间的通信不需要先建立好连接，需要通信时，直接将信息发送到“网络”中，让该信息的传递在网上尽力而为地往目的地传送。</p>
</blockquote>
<h4 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h4><h5 id="5-2-1-UDP数据报"><a href="#5-2-1-UDP数据报" class="headerlink" title="5.2.1 UDP数据报"></a>5.2.1 UDP数据报</h5><ol>
<li><p>UDP概述</p>
<p>UDP仅在IP的数据报服务之上增加了两个最基本的服务：<strong>复用和分用以及差错检测</strong>。</p>
<p>UDP具有如下特点：</p>
<ul>
<li>UDP是无连接的，减少开销和发送数据之前的时延。</li>
<li>UDP使用最大努力交付，即不保证可靠交付。</li>
<li>UDP是面向报文的，适合一次性传输少量数据的网络应用，</li>
<li>UDP无拥塞控制，适合很多实时应用。</li>
<li>分组首部开销小。TCP有20B的首部开销，而UDP仅有8B的开销。</li>
<li>UDP支持一对一、一对多、多对一和多对多的交互通信。</li>
</ul>
</li>
<li><p>UDP的首部格式</p>
<p>UDP数据报包含两部分：UDP首部和用户数据。UDP首部和用户数据。UDP首部有8B，由4个字段组成，每个字段的长度都是2B。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cdb516fc1d5a162016d5ed4c39e8680bbpngpic_center.jpg" alt="image-20230821105819937"></p>
<ul>
<li>**源端口：**源端口号。在需要对方回信时选用，不需要时可用全0。</li>
<li>**目的端口：**目的端口号。这在终点交付报文时必须使用到。</li>
<li>**长度：**单位字节，UDP数据报的长度（包括首部和数据），其最小值是8（仅有首部）。</li>
<li>**校验和：**检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0。</li>
</ul>
<p>​ 当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cebb4c9b9539fe19d7eb02260ae618bb4pngpic_center.jpg" alt="image-20230821104949141"></p>
<p>​ 如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于端口号的应用进程），那么就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方。</p>
</li>
</ol>
<h5 id="5-2-2-UDP校验"><a href="#5-2-2-UDP校验" class="headerlink" title="5.2.2 UDP校验"></a>5.2.2 UDP校验</h5><p>​ 在计算校验和时，要在UDP数据报之前增加<strong>12B的伪首部</strong>，伪首部并不是UDP的真正首部。只是在计算校验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报来计算的。伪首部既不向下传送又不向上递交，而只是为了计算校验和。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C4387f65214f07823d921460825f2b1b9pngpic_center.jpg" alt="image-20230821105350391"></p>
<p>​ UDP校验和的计算方法和IP数据报首部校验和的计算方法相似。但不同的是，IP数据报的校验和<strong>只检验IP数据报的首部</strong>，但UDP的校验和则<strong>检查首部和数据部分</strong>。</p>
<p><strong>检验过程</strong>：</p>
<ul>
<li>发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16位的字串接起来。</li>
<li>若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾填入一个全零字节（但此字节不发送）。</li>
<li>然后按二进制反码计算出这些16位字的和，将此和的二进制反码写入校验和字段，并发送。</li>
<li>接收方把收到的UDP数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节）后，按二进制反码求这些16位字的和。</li>
<li>当无差错时其结果应为全1，否则就表明有差错出现，接收方就应该丢弃这个UDP数据报。</li>
</ul>
<blockquote>
<p>计算UDP检验和的例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C51e8819b967b927cdf0f7a4658820b25pngpic_center.jpg" alt="image-20230821110108297"></p>
<p>二进制反码运算求和：将所有的字相加，如果相加过程中最高位产生了进位，就将进位加到最低位上，这叫做回卷。</p>
</blockquote>
<h4 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h4><h5 id="5-3-1-TCP协议的特点"><a href="#5-3-1-TCP协议的特点" class="headerlink" title="5.3.1 TCP协议的特点"></a>5.3.1 TCP协议的特点</h5><p>​ TCP是在不可靠的IP层之上实现的<strong>可靠的数据传输协议</strong>，它主要解决传输的<strong>可靠、有序、无丢失和不重复</strong>问题。</p>
<ul>
<li><p>主要特点如下：</p>
<p>1）TCP是<strong>面向连接</strong>（虚连接）的传输层协议</p>
<p>2）每一条TCP连接只能有<strong>两个端点</strong>，每一条TCP连接只能是<strong>点对点</strong>的</p>
<p>3）TCP 提供<strong>可靠交付</strong>的服务，保证传送的数据无差错、不丢失、不重复且有序</p>
<p>4）TCP提供<strong>全双工通信</strong>，两端都有发送缓存和接受缓存。</p>
<p><strong>发送缓存</strong>用来暂时存放以下数据：①发送应用程序传送给发送方TCP准备发送的数据；②TCP已发送但尚未收到确认的数据。</p>
<p><strong>接收缓存</strong>用来暂时存放以下数据：①按序到达但尚未被接收应用程序读取的数据；②不按序到达的数据。</p>
<p>5）TCP是<strong>面向字节流</strong>的。虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
</li>
</ul>
<h5 id="5-3-2-TCP报文段"><a href="#5-3-2-TCP报文段" class="headerlink" title="5.3.2 TCP报文段"></a>5.3.2 TCP报文段</h5><p>​ TCP传送的数据单元称为<strong>报文段</strong>。TCP报文段既可以用来<strong>运载数据</strong>，又可以用来<strong>建立连接</strong>、<strong>释放连接</strong>和<strong>应答</strong>。</p>
<p>​ 一个TCP报文段分为<strong>首部和数据</strong>两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中，其首部的前20B是固定的。TCP首部最短为20B，后面有4N字节是根据需要而增加的选项，长度为4B的整数倍。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cecfa13b645b96b0c084ad9f711f455d6pngpic_center.jpg" alt="image-20230821112736537"></p>
<ul>
<li><p>源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。</p>
</li>
<li><p>序号：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p>
</li>
<li><p>确认号：<strong>期望</strong>收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。</p>
</li>
<li><p>数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即1个数值是4B。</p>
</li>
<li><p>保留。占6位，保留为今后使用，但目前应置为0。</p>
</li>
<li><p>控制位：</p>
<ul>
<li><strong>紧急位URG</strong>：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应<strong>尽快传送</strong>，<strong>不用在缓存里排队</strong>，配合紧急指针字段使用。</li>
<li><strong>确认位ACK</strong>：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li>
<li>推送位PSH：PSH&#x3D;1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li>
<li>复位RST：RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li>
<li><strong>同步位SYN</strong>：SYN&#x3D;1时，表明是一个连接请求&#x2F;连接接受报文。</li>
<li><strong>终止位FIN</strong>：FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接</li>
</ul>
</li>
<li><p>窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。</p>
<blockquote>
<p>例如，设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的一方还有接收1000字节数据（字节序号为701~1700）的接收缓存空间。</p>
</blockquote>
</li>
<li><p>检验和：检验首部+数据，检验时要加上12B伪首部，第四个字段为6。</p>
</li>
<li><p>紧急指针：URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数（紧急数据在报文段数据的最前面）。</p>
</li>
<li><p>选项：长度可变。最大报文段长度MSS、窗口扩大、时间戳、选择确认。</p>
</li>
<li><p>填充：这是为了使整个首部长度是4B的整数倍。</p>
</li>
</ul>
<h5 id="5-3-3-TCP连接管理"><a href="#5-3-3-TCP连接管理" class="headerlink" title="5.3.3 TCP连接管理"></a>5.3.3 TCP连接管理</h5><p>​ TCP是面向连接的协议，因此每个TCP连接都有三个阶段：连接建立、数据传送和连接释放。TCP连接的管理就是使运输连接的建立和释放都能正常进行。</p>
<ol>
<li><p>TCP连接的建立</p>
<p>在TCP连接建立的过程中，要解决以下三个问题：</p>
<ul>
<li>1）要使每一方能够确知对方的存在。</li>
<li>2）要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等）。</li>
<li>3）能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ul>
<p>TCP连接的建立采用<strong>客户&#x2F;服务器模式</strong>。主动发起连接建立的应用进程称为客户（Client），而被动等待连接建立的应用进程称为服务器（Server）。</p>
<p>TCP连接的端口即为套接字(Socket)或插口，每条TCP连接唯一地被通信的两个端点（即两个套接字）确定。</p>
<p><strong>连接建立过程经历3个步骤，称为三次握手。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cd40e6fdf500ff1ed3f04649fb6c07f4dpngpic_center.jpg" alt="image-20230821134234758"></p>
<p>连接建立前，A、B创建传输控制模块TCB，服务器进程处于LISTEN（收听）状态，等待客户的连接请求。</p>
<ul>
<li><p>1）客户机先向服务器发送一个<strong>连接请求报文段</strong>。它不含应用层数据，其首部中的<strong>SYN标志位&#x3D;1</strong>，另外，客户机要随机选择一个<strong>起始序号seq&#x3D;x</strong>。TCP客户进程进入<strong>SYN-SENT（同步已发送）状态</strong>。</p>
</li>
<li><p>2）服务器收到连接请求报文段后，如同意就向客户机发<strong>确认</strong>，并为该连接<strong>分配缓存和变量</strong>。</p>
<p>其中，<strong>SYN和ACK&#x3D;1</strong>，确认号字段的值<strong>ack&#x3D;x+1</strong>，并且服务器随机产生起始序号<strong>seq&#x3D;y</strong>，确认报文段同样不包含应用层数据。TCP服务器进程进入<strong>SYN-RCVD（同步收到）状态</strong>。</p>
</li>
<li><p>3）当客户机收到确认报文段后，还要向服务器给出<strong>确认</strong>，并且也要给该连接分配缓存和变量。</p>
<p>其中<strong>ACK标志位&#x3D;1</strong>，序号字段<strong>seq&#x3D;x+1</strong>，确认号字段<strong>ack&#x3D;y+1</strong>，该报文段<strong>可以携带数据</strong>，如果<strong>不携带数据则不消耗序号</strong>。TCP客户进程进入<strong>ESTABLISHED（已建立连接）状态</strong>。</p>
</li>
</ul>
<blockquote>
<p>要A第三次确认，是为了防止己失效的连接请求报文段突然又传送到了B，因而产生错误。</p>
<p>防止第一次发送的连接请求报文段滞后到达，A在接收到B的确认就开始传送数据，而B确以为建立了新的连接而无法接收，导致数据丢失。</p>
</blockquote>
<p>服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到<strong>SYN洪泛攻击</strong>。</p>
<blockquote>
<p>SYN洪泛攻击的原理和过程如下：</p>
<ul>
<li>攻击者向服务器发送大量的SYN数据包，请求建立连接，但是故意伪造或随机生成源IP地址，使服务器无法回复。</li>
<li>服务器收到SYN数据包后，回复SYN-ACK数据包，并为每个连接分配一个缓冲区，等待客户端的ACK数据包，进入SYN-RCVD状态。</li>
<li>由于源IP地址是伪造或随机的，服务器无法收到客户端的ACK数据包，导致缓冲区被占用，无法处理其他的连接请求。</li>
<li>当缓冲区满了后，服务器就无法接受新的连接请求，从而拒绝服务。</li>
</ul>
<p>解决办法：设置SYN cookie，即在回复SYN-ACK数据包时，不分配缓冲区，而是将一些信息编码在序列号中，等到收到ACK数据包时再解码恢复。</p>
</blockquote>
</li>
<li><p>TCP连接的释放</p>
<p>参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。TCP连接释放的过程通常称为四次握手。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cec03c95e326fc1c674b70184c7e2d8d6pngpic_center.jpg" alt="image-20230821141106766"></p>
<ul>
<li><p>1）客户端发送<strong>连接释放报文段</strong>，停止发送数据，主动关闭TCP连接。<strong>FIN&#x3D;1</strong>，<strong>seq&#x3D;u</strong>，它等于前面已传送过的数据的最后一个字节的序号加1。TCP客户进程进入<strong>FIN-WAIT-1（终止等待1）状态</strong>。</p>
</li>
<li><p>2）服务器端回送一个<strong>确认报文段</strong>，<strong>ACK&#x3D;1</strong>，<strong>seq&#x3D;v</strong>，<strong>ack&#x3D;u+1</strong>，客户到服务器这个方向的连接就释放了，TCP连接处于<strong>半关闭状态</strong>。服务器进入<strong>CLOSE-WAIT（关闭等待）状态</strong>。客户收到后进入<strong>FIN-WAIT-2（终止等待2）状态</strong>。</p>
<blockquote>
<p>但服务器若发送数据，客户机仍要接收，即从<strong>服务器到客户机这个方向的连接并未关闭</strong>。</p>
</blockquote>
</li>
<li><p>3）服务器端发完数据，就发出<strong>连接释放报文段</strong>，主动关闭TCP连接。<strong>FIN&#x3D;1</strong>，<strong>ACK&#x3D;1</strong>，<strong>seq&#x3D;w</strong>，<strong>ack&#x3D;u+1</strong>。服务器进入<strong>LAST-ACK（最后确认）状态</strong>。</p>
</li>
<li><p>4）客户端回送一个<strong>确认报文段</strong>，<strong>ACK&#x3D;1</strong>, <strong>seq&#x3D;u+1</strong>, <strong>ack&#x3D;w+1</strong>，客户进入进入到<strong>TIME-WAIT（时间等待）状态</strong>。再等到时间等待计时器设置的<strong>2MSL（最长报文段寿命）后</strong>，连接彻底关闭。客户机和服务器进入<strong>CLOSED（连接关闭）状态</strong>。</p>
<blockquote>
<p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？</p>
<ul>
<li>第一，为了保证A发送的最后一个ACK报文段能够到达B。</li>
<li>第二，防止“已失效的连接请求报文段”出现在本连接中。</li>
</ul>
</blockquote>
</li>
</ul>
<p>除时间等待计时器外，TCP还设有一个<strong>保活计时器</strong>（keepalive timer）。</p>
<blockquote>
<p>就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p>
</blockquote>
</li>
</ol>
<h5 id="5-3-4-TCP可靠传输"><a href="#5-3-4-TCP可靠传输" class="headerlink" title="5.3.4 TCP可靠传输"></a>5.3.4 TCP可靠传输</h5><p>​ TCP的任务是在IP层不可靠的、尽力而为服务的基础上建立一种可靠数据传输服务。TCP使用了校验、序号、确认和重传等机制来达到这一目的。</p>
<p>​ <strong>可靠</strong>，指的是保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</p>
<ol>
<li><p>序号</p>
<p>​ TCP连接中传送的数据流中的<strong>每一个字节都编上一个序号</strong>。<strong>序号字段的值</strong>则指的是本报文段所发送的数据的<strong>第一个字节的序号</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C1f4bb458535ca3218346becbe9ff3653pngpic_center.jpg" alt="image-20230821144431181"></p>
<p>​ TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。如图所示，假设A和B之间建立了一条TCP连接，A的发送缓存区中共有10B，序号从0开始标号，第一个报文包含第0~2个字节，则该TCP报文段的序号是0，第二个报文段的序号是3。</p>
</li>
<li><p>确认</p>
<p>TCP首部的<strong>确认号</strong>是<strong>期望收到</strong>对方的下一个报文段的数据的<strong>第一个字节的序号</strong>。</p>
<p>TCP默认使用<strong>累计确认</strong>，即TCP只确认数据流中<strong>至第一个丢失字节为止的字节</strong>。</p>
</li>
<li><p>重传</p>
<p>有两种事件会导致TCP对报文段进行重传：超时和冗余ACK。</p>
<ul>
<li><p><strong>超时重传</strong></p>
<p>TCP每发送一个报文段，就对这个<strong>报文段设置一次计时器</strong>。只要计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。</p>
<p>TCP采用自适应算法，动态改变重传时间RTTs（加权平均往返时间）</p>
</li>
<li><p><strong>冗余ACK（冗余确认）</strong></p>
<p>TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。</p>
<p>当发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报丈段之后的报文段已经丢失。</p>
<blockquote>
<p><strong>快速重传</strong>的例子：</p>
<p>发送方已发送1，2，3，4，5报文段</p>
<ul>
<li>接收方收到1，返回给1的确认（确认号为2的第一个字节）</li>
<li>接收方收到3，仍返回给1的确认（确认号为2的第一个字节）</li>
<li>接收方收到4，仍返回给1的确认（确认号为2的第一个字节）</li>
<li>接收方收到5，仍返回给1的确认（确认号为2的第一个字节）</li>
<li>发送方收到3个对于报文段1的冗余ACK，认为2报文段丢失，重传2号报文段。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ol>
<h5 id="5-3-5-TCP流量控制"><a href="#5-3-5-TCP流量控制" class="headerlink" title="5.3.5 TCP流量控制"></a>5.3.5 TCP流量控制</h5><p>​ TCP提供<strong>流量控制</strong>服务来消除<strong>发送方（发送速率太快）使接收方缓存区溢出</strong>的可能性。TCP提供一种<strong>基于滑动窗口协议</strong>的流量控制机制。</p>
<p><strong>滑动窗口</strong>：</p>
<ul>
<li><strong>接收窗口rwnd</strong>：接收端维护，接收端当前的<strong>接收缓存大小</strong>。</li>
<li><strong>拥塞窗口cwnd</strong>：发送端维护，发送端根据当前网络的<strong>拥塞程度</strong>而确定的<strong>窗口值</strong>。</li>
<li><strong>发送窗口</strong>：由发送端维护，发送端在接收到下一个确认前能够发送的最大字节数。</li>
<li>发送窗口&#x3D;min（接收窗口，拥塞窗口）</li>
</ul>
<p>​ 在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），</p>
<p>发送方的<strong>发送窗口</strong>取接收窗口rwnd和拥塞窗口cwnd的最小值。TCP的窗口单位是<strong>字节</strong>，不是报文段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C7054557403a9299ae55bd0075bc0bdc7pngpic_center.jpg" alt="image-20230821150436320"></p>
<p>​ 如上图所示，设A向B发送数据。在连接建立时，B的接收窗口rwnd&#x3D;400。接收方主机B进行了三次流量控制，这三个报文段都设置了ACK&#x3D;1，只有在ACK&#x3D;1时确认号字段才有意义。第一次把窗口减小到rwnd&#x3D;300，第二次又减到rwnd&#x3D;100，最后减到rwnd&#x3D;0，即不允许发送方再发送数据。这使得发送方暂停发送的状态将持续到B重新发出一个新的窗口值为止。</p>
<p>​ 传输层和数据链路层的<strong>流量控制的区别</strong>是：</p>
<ul>
<li>传输层定义端到端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制。</li>
<li>数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化。</li>
</ul>
<h5 id="5-3-6-TCP拥塞控制"><a href="#5-3-6-TCP拥塞控制" class="headerlink" title="5.3.6 TCP拥塞控制"></a>5.3.6 TCP拥塞控制</h5><p>​ 拥塞控制是指<strong>防止过多的数据注入网络</strong>，保证网络中的路由器或链路不致过载，是全局性过程。出现拥塞时，端点并不了解拥塞发生的细节，对通信连接的端点来说，<strong>拥塞往往表现为通信时延的增加</strong>。<br>发送窗口的上限值 &#x3D; m i n [ r w n d ， c w n d ] 发送窗口的上限值&#x3D;min[rwnd，cwnd] 发送窗口的上限值=min[rwnd，cwnd]<br>​ 因特网建议标准定义了进行拥塞控制的4种算法：慢开始、拥塞避免、快重传和快恢复。</p>
<ol>
<li><p>慢开始和拥塞避免</p>
<ul>
<li><p><strong>慢开始</strong>：</p>
<p>1）先令拥塞窗口cwnd&#x3D;1（即一个<strong>最大报文段长度MSS</strong>）。</p>
<p>2）在<strong>每收到一个对新的报文段的确认</strong>后，将cwnd加1，即增大一个MSS（<strong>拥塞窗口加倍</strong>）。</p>
<blockquote>
<p>为了便于理解，图中的窗口单位不使用字节而使用报文段的个数</p>
</blockquote>
</li>
<li><p><strong>拥塞避免</strong>：</p>
<p>1）发送端的<strong>拥塞窗口cwnd</strong>每经过一个往返时延RTT就<strong>增加一个MSS</strong>的大小，而不是加倍，使cwnd按<strong>线性规律缓慢增长</strong>（即加法增大）</p>
<p>2）当出现一次超时（网络拥塞）时，则令<strong>慢开始门限ssthresh</strong>等于<strong>当前cwnd的一半</strong>（即乘法减小）</p>
<p>根据cwnd的大小执行不同的算法，可归纳如下：</p>
<ul>
<li>当cwnd&lt;ssthresh时，使用慢开始算法。</li>
<li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当cwnd&#x3D;ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法（通常做法）。</li>
</ul>
</li>
<li><p>网络拥塞处理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Ce9fdee77678feed0238882bf927eefedpngpic_center.jpg" alt="image-20230821160349885"></p>
<p>① 执行慢开始算法，拥塞窗口cwnd置为1，每收到一个ACK，cwnd加1，即每个轮次拥塞窗口翻倍。</p>
<p>② 达到ssthresh初始值16，执行拥塞避免算法，每个轮次拥塞窗口加1。</p>
<p>③ 在cwnd达到24时，出现超时，发送方判断网络拥塞；调整门限ssthresh为12，cwnd置1，重新慢开始。当拥塞窗口到达12时，开始执行拥塞避免。</p>
<p>​ 当网络出现拥塞时，无论在什么阶段，只要发送方检测到超时事件的发生（没有按时收到确认。重传计时器超时），就要把慢开始门限ssthresh设置为出现拥塞时的发送方cwnd值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p>
</li>
</ul>
</li>
<li><p>快重传和快恢复</p>
<p>​ 快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p>
<ul>
<li><p><strong>快重传</strong>：收到3个重复的确认执行快重传算法。</p>
</li>
<li><p><strong>快恢复</strong>：</p>
<p>当发送端<strong>收到连续三个冗余ACK</strong>时，就执行“乘法减小”算法，把<strong>慢开始门限ssthresh设置为出现拥塞时发送方cwnd的一半</strong>。与慢开始（将拥塞窗口cwnd设置为1）不同之处是它<strong>把cwnd的值设置为慢开始门限ssthresh改变后的数值</strong>，然后开始执行<strong>拥塞避免算法</strong>（加法增大），使拥塞窗口缓慢地线性增大。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cf175294c1abb7b73bc2429d1e63a0b6cpngpic_center.jpg" alt="image-20230821160740544"></p>
</li>
</ul>
<p>在流量控制中，发送方发送数据的量由<strong>接收方</strong>决定，而在拥塞控制中，则由发送方自己通过<strong>检测网络状况来决定</strong>。实际上，慢开始、拥塞避免、快重传和快恢复几种算法是<strong>同时应用在拥塞控制机制</strong>中。</p>
<p>四种算法使用的<strong>总结</strong>：</p>
<ul>
<li><p>在TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法；</p>
</li>
<li><p>当发送方接收到冗余ACK时，采用快重传和快恢复算法。</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6 应用层"></a>6 应用层</h3><h4 id="6-1-网络应用模型"><a href="#6-1-网络应用模型" class="headerlink" title="6.1 网络应用模型"></a>6.1 网络应用模型</h4><h5 id="6-1-1-客户-服务器模型"><a href="#6-1-1-客户-服务器模型" class="headerlink" title="6.1.1 客户&#x2F;服务器模型"></a>6.1.1 客户&#x2F;服务器模型</h5><p>​ 在客户&#x2F;服务器（Client&#x2F;Server，C&#x2F;S）模型中，有一个总是打开的主机称为<strong>服务器</strong>，它服务于许多来自其他称为客户机的主机请求。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C5baf8e62b5545ef861743af00c24f047pngpic_center.jpg" alt="image-20230821165048681"></p>
<ol>
<li><p><strong>服务器</strong>：提供计算服务的设备</p>
<p>特点：①永久提供服务；②永久性访问地址&#x2F;域名</p>
</li>
<li><p><strong>客户机</strong>：请求计算服务的主机。</p>
<p>特点：</p>
<ul>
<li><p>1）与服务器通信，使用<strong>服务器提供的服务</strong></p>
</li>
<li><p>2）间歇性接入网络</p>
</li>
<li><p>3）可能使用动态IP地址</p>
</li>
<li><p>4）不与其他客户机直接通信</p>
</li>
</ul>
</li>
<li><p><strong>工作流程</strong>：</p>
<ul>
<li>服务器处于接收请求的状态。</li>
<li>客户机发出服务请求，并等待接收结果。</li>
<li>服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。</li>
</ul>
</li>
<li><p>客户&#x2F;服务器模型的<strong>主要特点</strong></p>
<ul>
<li><p>1）<strong>网络中各计算机的地位不平等</strong>，服务器可以通过对用户权限的限制来达到管理客户机的目的，使它们不能随意存储&#x2F;删除数据，或进行其他受限的网络活动。</p>
<p>整个网络的管理工作由少数服务器担当，因此网络的管理非常<strong>集中和方便</strong>。</p>
</li>
<li><p>2）<strong>客户机相互之间不直接通信</strong>。例如，在Wb应用中两个浏览器并不直接通信。</p>
</li>
<li><p>3）<strong>可扩展性不佳</strong>。受服务器硬件和网络带宽的限制，服务器支持的客户机数有限。</p>
</li>
</ul>
</li>
<li><p>应用：Web、文件传输协议（FTP）、远程登录和电子邮件等。</p>
</li>
</ol>
<h5 id="6-1-2-P2P模型"><a href="#6-1-2-P2P模型" class="headerlink" title="6.1.2 P2P模型"></a>6.1.2 P2P模型</h5><p>​ 在P2P模型中，各计算机没有固定的客户和服务器划分。相反，任意一对计算机一一称为<strong>对等方（Peer）</strong>，<strong>直接相互通信</strong>。每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C599c16df26bba989aea84dfd4b3f7cf7pngpic_center.jpg" alt="image-20230821165041498"></p>
<ol>
<li><p>P2P模型的<strong>特点</strong>：</p>
<ul>
<li>不存在永远在线的服务器，每个主机既可以提供服务，也可以请求服务</li>
<li>任意端系统&#x2F;节点之间可以直接通讯，多个客户机之间可以直接共享文档</li>
<li>节点间歇性接入网络，节点可能改变IP地址</li>
<li>多个客户机之间可以直接共享文档</li>
<li>可扩展性好</li>
<li>网络健壮性强</li>
</ul>
</li>
<li><p>P2P模型缺点：</p>
<p>在获取服务的同时，还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。</p>
</li>
<li><p>应用：PPlive、Bittorrent和电驴等。</p>
</li>
</ol>
<h4 id="6-2-域名系统（DNS）"><a href="#6-2-域名系统（DNS）" class="headerlink" title="6.2 域名系统（DNS）"></a>6.2 域名系统（DNS）</h4><p>​ <strong>域名系统</strong>（Domain Name System，DNS）是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名（<a target="_blank" rel="noopener" href="http://www.baidu.com)转换为便于机器处理的ip地址./">www.baidu.com）转换为便于机器处理的IP地址。</a></p>
<p>​ DNS系统采用客户&#x2F;服务器模型，其协议运行在UDP之上，使用53号端口。</p>
<p>​ DNS分为3部分：层次域名空间、域名服务器和解析器。</p>
<h5 id="6-2-1-层次域名空间"><a href="#6-2-1-层次域名空间" class="headerlink" title="6.2.1 层次域名空间"></a>6.2.1 层次域名空间</h5><p>​ 因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即<strong>域名（Domain Name）</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C0e842f6d508662490edb16b6af42e260pngpic_center.jpg" alt="image-20230821165138228"></p>
<p>​ “域”（domain）是名字空间中一个可被管理的划分。域还可以划分为子域，而子域还可继续划分为子域的子域，这样就形成了顶级域、二级域、三级域，等等。</p>
<p>​ 从语法上讲，每一个域名都由<strong>标号（label）序列</strong>组成，而各标号之间<strong>用点隔开</strong>。</p>
<ol>
<li><p>标号</p>
<ul>
<li><p>1）标号中的英文不区分大小写</p>
</li>
<li><p>2）标号中除连字符”-“外不能使用其他的标点符号</p>
</li>
<li><p>3）每一个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符</p>
</li>
<li><p>4）级别最低的域名写在最左边，而级别最高的顶级域名写在最右边</p>
</li>
</ul>
</li>
<li><p>域名树</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C147b52e188123aefff85fe95b6edd70epngpic_center.jpg" alt="image-20230821170927617"></p>
<ul>
<li><p>根：域名树最上面的是根，但没有对应的名字。它用一个点（.）表示，也称为根域或根区。</p>
</li>
<li><p>顶级域名（Top Level Domain，TLD）分为如下三大类：</p>
<ul>
<li><p>国家顶级域名：cn，us，uk</p>
</li>
<li><p>通用顶级域名：com，net，org，gov，int，aero，museum，travel</p>
</li>
<li><p>基础结构域名&#x2F;反向域名：arpa</p>
</li>
</ul>
</li>
<li><p>二级域名：</p>
<ul>
<li><p>类别域名：ac，com，edu，gov，mil，net，org</p>
</li>
<li><p>行政区域名：用于我国各省、自治区、直辖市bj，js</p>
</li>
<li><p>自己注册的域名：cctv，google</p>
</li>
</ul>
<p>凡是在顶级域名com下注册的单位都获得了一个二级域名</p>
</li>
<li><p>三级域名：www、mail</p>
</li>
</ul>
<p>域名树的树叶就是单台计算机的名字，它不能再继续往下划分子域了。</p>
</li>
</ol>
<h5 id="6-2-2-域名服务器"><a href="#6-2-2-域名服务器" class="headerlink" title="6.2.2 域名服务器"></a>6.2.2 域名服务器</h5><p>​ 因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户&#x2F;服务器模型。</p>
<p>​ 域名到IP地址的解析是由运行在<strong>域名服务器</strong>上的程序完成的，一个服务器所负责管辖的（或有权限的）范围称为区。每个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。</p>
<p>​ 每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须<strong>具有连向其他域名服务器的信息</strong>。当自己不能进行域名到IP地址的转换时，能够<strong>知道到什么地方去找其他域名服务器</strong>。</p>
<p>​ DNS使用了大量的域名服务器，它们以层次方式组织。没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS上。DNS层次结构如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C9afb1b9e7ce0761ed5264156e9b55536pngpic_center.jpg" alt="image-20230821172724959"></p>
<ol>
<li><p><strong>根域名服务器</strong></p>
<p>​ <strong>根域名服务器是最高层次的域名服务器</strong>，所有的根域名服务器都知道所有的顶级域名服务器的IP地址。</p>
<p>​ 任何本地域名服务器，若无法解析一个域名，就<strong>先求助于根域名服务器</strong>。通常不直接把待查询的域名直接转换成IP地址，而是告诉本地域名服务器<strong>下一步应找哪个顶级域名服务器</strong>进行查询</p>
</li>
<li><p><strong>顶级域名服务器</strong></p>
<p>​ 责管理在该顶级域名服务器注册的<strong>所有二级域名</strong>。</p>
<p>​ 收到DNS查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的IP地址）</p>
</li>
<li><p><strong>授权域名服务器</strong>（权限域名服务器）</p>
<p>​ 负责一个区的域名服务器。每台主机都必须在授权域名服务器处登记，授权域名服务器总是能够将其管辖的<strong>主机名转换为该主机的地址</strong>。</p>
</li>
<li><p><strong>本地域名服务器</strong></p>
<p>当一个主机发出DNS查询请求时，这个查询请求报文就发给<strong>本地域名服务器</strong>。</p>
<p>每一个因特网服务提供者ISP（一个大学，甚至一个大学里的系）都可以拥有一个本地域名服务器。</p>
</li>
</ol>
<h5 id="6-2-3-域名解析过程"><a href="#6-2-3-域名解析过程" class="headerlink" title="6.2.3 域名解析过程"></a>6.2.3 域名解析过程</h5><ol>
<li><p>定义</p>
<p><strong>正向解析</strong>：是指把域名映射成为IP地址的过程；</p>
<p><strong>反向解析</strong>：是指把IP地址映射成为域名的过程。</p>
</li>
<li><p>递归查询</p>
<p>​ 本地域名服务器只需向根域名服务器查询一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的[步骤③~⑥]。在步骤⑦中，本地域名服务器从根域名服务器得到了所需的IP地址，最后在步骤⑧中，本地域名服务器把查询结果告诉发起查询的主机。</p>
<p>​ 由于该方法给根域名服务造成的<strong>负载过大</strong>，所以在实际中几乎不使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C358527ea4b371b062e61494e54f96d91pngpic_center.jpg" alt="image-20230821173039730"></p>
</li>
<li><p>递归与迭代相结合的查询</p>
<p>主机向本地域名服务器的查询采用的是递归查询；本地域名服务器向根域名服务器的查询采用迭代查询。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Ce01fe5b1f05728bd52c8cdb9c6073ae1pngpic_center.jpg" alt="image-20230821173051789"></p>
<p>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程（共使用8个UDP报文）：</p>
<ul>
<li><p>①客户机向其本地域名服务器发出DNS请求报文</p>
</li>
<li><p>②本地域名服务器收到请求后，查询本地缓存，假设没有该记录，则以DNS客户的身份向根域名服务器发出解析请求，</p>
</li>
<li><p>③根域名服务器收到请求后，判断该域名属于.com域，将对应的顶级域名服务器dns.com的IP地址返回给本地域名服务器</p>
</li>
<li><p>④本地域名服务器向顶级域名服务器dns.com发出解析请求报文</p>
</li>
<li><p>⑤顶级域名服务器dns.com收到请求后，判断该域名属于abc.com域，将对应的授权域名服务器dns.abc.com的IP地址返回给本地域名服务器6本地域名服务器向授权域名服务器dns.abc.com发起解析请求报文。</p>
</li>
<li><p>⑦授权域名服务器 dns.abc.com收到请求后，将查询结果返回给本地域名服务器。</p>
</li>
<li><p>⑧本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。</p>
</li>
</ul>
<p>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>。</p>
<p>查询过的DNS信息可以暂时缓存到高速缓存，再次查询相同域名可直接提供IP地址。</p>
</li>
</ol>
<h4 id="6-3-文件传输协议（FTP）"><a href="#6-3-文件传输协议（FTP）" class="headerlink" title="6.3 文件传输协议（FTP）"></a>6.3 文件传输协议（FTP）</h4><h5 id="6-3-1-FTP的工作原理"><a href="#6-3-1-FTP的工作原理" class="headerlink" title="6.3.1 FTP的工作原理"></a>6.3.1 FTP的工作原理</h5><p>​ <strong>文件传输协议</strong>（File Transfer Protocol，FTP）是因特网上使用得最广泛的文件传输协议。基于TCP，可靠传输。基于&#x3D;&#x3D;客户&#x2F;服务器（C&#x2F;S）&#x3D;&#x3D;的协议。</p>
<p>​ 用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照FTP协议提供服务，进行文件传送的计算机就是<strong>FTP服务器</strong>。连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是<strong>FTP客户端</strong>。</p>
<p>​ FTP<strong>提供交互式的访问</strong>，允许<strong>客户指明文件的类型与格式</strong>，并允许<strong>文件具有存取权限</strong>。它屏蔽了各计算机系统的细节，因而<strong>适合于在异构网络中的任意计算机之间传送文件</strong>。</p>
<ol>
<li><p>功能</p>
<ul>
<li><p>①提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。</p>
</li>
<li><p>②以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力。</p>
</li>
<li><p>③以匿名FTP的方式提供公用文件共享的能力。</p>
</li>
</ul>
</li>
<li><p>FTP的<strong>服务器进程</strong>由两大部分组成：</p>
<ul>
<li>一个主进程，负责接收新的请求</li>
<li>另外有若干从属进程，负责处理单个请求。</li>
</ul>
</li>
<li><p><strong>工作步骤</strong>：</p>
<ul>
<li>①打开熟知端口21（控制端口），使客户进程能够连接上。</li>
<li>②等待客户进程发连接请求。</li>
<li>③启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止。</li>
<li>④回到等待状态，继续接收其他客户进程的请求。</li>
</ul>
</li>
</ol>
<h5 id="6-3-2-控制连接与数据连接"><a href="#6-3-2-控制连接与数据连接" class="headerlink" title="6.3.2 控制连接与数据连接"></a>6.3.2 控制连接与数据连接</h5><p>​ FTP在工作时使用两个并行的TCP连接：一个是<strong>控制连接</strong>（服务器端口号21），一个是<strong>数据连接</strong>（服务器端口号20）。使用两个不同的端口号可以使协议更容易实现。控制连接始终保持；数据连接保持一会。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C51ca2377ef9667868d85f912e5e692a8pngpic_center.jpg" alt="image-20230821174653664"></p>
<ol>
<li><p>控制连接</p>
<p>​ <strong>服务器监听</strong>在21号端口，等待客户连接用来传输控制信息（如连接请求、传送请求）。控制信息都是以7位ASCII 格式传送的。</p>
<p>​ FTP客户发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。</p>
<p>​ 在整个会话期间<strong>一直保持打开状态</strong>。</p>
</li>
<li><p>数据连接</p>
<p>​ 服务器端的控制进程在接收到FTP客户发送来的<strong>文件传输请求</strong>后就<strong>创建“数据传送进程”和“数据连接”</strong>。</p>
<p>​ 用来连接客户端和服务器端的数据传送进程，数据传送进程完成文件的传送，在<strong>传送完毕后关闭</strong>“数据传送连接”结束运行。</p>
<p>​ 数据连接有两种传输模式：主动模式PORT和被动模式PASV。</p>
<ul>
<li><p>主动模式PORT</p>
<p>​ 客户端连接到<strong>服务器的21端口</strong>，登录成功后要读取数据时，客户端随机开放一个端口，并发送命令告知服务器，服务器收到PORT命令和端口号后，通过20端口和客户端开放的端口连接，发送数据。</p>
</li>
<li><p>被动模式PASV</p>
<p>​ 客户瑞要读取数据时，发送PASV命令到服务器，服务器在本地随机开放一个端口，并告知客户端，客户端再连接到服务器开放的端口进行数据传输。</p>
</li>
</ul>
<p>主动模式传送数据是**“服务器”连接到“客户端”的端口**；被动模式传送数据是**“客户端”连接到“服务器”的端口**。</p>
</li>
<li><p>FTP传输模式</p>
<ul>
<li><p>文本模式：ASCII模式，以文本序列传输数据；</p>
</li>
<li><p>二进制模式：Binary模式，以二进制序列传输数据</p>
</li>
</ul>
</li>
<li><p>性质</p>
<ul>
<li>提供交互式的访问</li>
<li>允许客户指明文件的类型与格式</li>
<li>允许文件具有存取权限</li>
<li>屏蔽了各计算机系统的细节，适合在异构网络中任意计算机之间传送文件</li>
</ul>
</li>
</ol>
<h4 id="6-4-电子邮件"><a href="#6-4-电子邮件" class="headerlink" title="6.4 电子邮件"></a>6.4 电子邮件</h4><h5 id="6-4-1-电子邮件系统的组成结构"><a href="#6-4-1-电子邮件系统的组成结构" class="headerlink" title="6.4.1 电子邮件系统的组成结构"></a>6.4.1 电子邮件系统的组成结构</h5><p>​ 电子邮件是一种<strong>异步通信方式</strong>，通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C32cc0c4802577c5a9fa4ebb36eb9e340pngpic_center.jpg" alt="image-20230821175308944"></p>
<ol>
<li><p>组成构件</p>
<ul>
<li><strong>用户代理（UA）</strong>：用户与电子邮件系统的接口。用户代理向用户提供一个很友好的接口来发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的功能。通常情况下，用户代理就是一个运行在PC上的程序（电子邮件客户端软件），常见的有Outlook和Foxmail等。</li>
<li><strong>邮件服务器</strong>：它的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付被拒绝、丢失等）。邮件服务器采用客户服务器方式工作，但它必须能够同时充当客户和服务器。</li>
<li><strong>邮件发送协议和读取协议</strong>：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP；邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3。</li>
</ul>
</li>
<li><p>收发过程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C1fd5cf2f3bc8f44ceeab9403a4276900pngpic_center.jpg" alt="image-20230822090846018"></p>
<ul>
<li>①发信人调用<strong>用户代理</strong>来撰写和编辑要发送的邮件。用户代理用<strong>SMTP</strong>把邮件传送给<strong>发送端邮件服务器</strong>。</li>
<li>②<strong>发送端邮件服务器</strong>将邮件放入<strong>邮件缓存队列</strong>中，等待发送。</li>
<li>③运行在<strong>发送端邮件服务器</strong>的<strong>SMTP客户进程</strong>，发现邮件缓存中有待发送的邮件，就向运行在<strong>接收端邮件服务器</strong>的<strong>SMTP服务器进程</strong>发起建立<strong>TCP连接</strong>。</li>
<li>④<strong>TCP连接建立</strong>后，<strong>SMTP客户进程</strong>开始向<strong>远程SMTP服务器进程</strong>发送邮件。当所有待发送邮件发完后，SMTP就<strong>关闭所建立的TCP连接</strong>。</li>
<li>⑤运行在<strong>接收端邮件服务器</strong>中的<strong>SMTP服务器</strong>进程收到邮件后，将邮件放入收信人的<strong>用户邮箱</strong>，等待收信人在方便时进行读取。</li>
<li>⑥收信人打算<strong>收信</strong>时，调用用户代理，使用<strong>POP3（或IMAP）协议</strong>将自己的邮件<strong>从接收端邮件服务器的用户邮箱中取回</strong>（如果邮箱中有来信的话）。</li>
</ul>
</li>
</ol>
<h5 id="6-4-2-SMTP和POP3"><a href="#6-4-2-SMTP和POP3" class="headerlink" title="6.4.2 SMTP和POP3"></a>6.4.2 SMTP和POP3</h5><ol>
<li><p><strong>SMTP（简单邮件传输协议）</strong></p>
<p>简单邮件传输协议（SMTP）是一种提供可靠且有效的电子<strong>邮件传输协议</strong>，它控制两个相互通信的SMTP进程交换信息。</p>
<p>采用客户&#x2F;服务器方式，发送方为客户，接收方为服务器；TCP连接，端口号为25。</p>
<p>负责发送邮件的SMTP进程就是<strong>SMTP客户</strong>，负责接收邮件的进程就是<strong>SMTP服务器</strong>。</p>
<p>SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明）</p>
<p>SMTP分为以下<strong>三个阶段</strong>：</p>
<ul>
<li><p>建立连接</p>
<ul>
<li><p>发件人邮件发送到<strong>发送方邮箱服务器</strong>的缓存中，<strong>SMTP客户</strong>定时扫描邮件缓存。</p>
</li>
<li><p>扫描发现有邮件，使用<strong>SMTP熟知端口号（25）</strong>与<strong>接收方邮件服务器</strong>的<strong>SMTP服务器</strong>建立<strong>TCP连接</strong>。</p>
</li>
<li><p>建立连接后，接收方<strong>SMTP服务器</strong>发出”220 Service ready（服务就绪）”。</p>
</li>
<li><p>SMTP客户向SMTP服务器发送”HELO命令”，附上发送方的主机名。</p>
</li>
<li><p>SMTP服务器若有能力接收邮件，回答”250 OK”；否则，回答”421 Service not available”</p>
</li>
</ul>
<p><strong>SMTP不使用中间的邮件服务器</strong>。TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立。</p>
</li>
<li><p>邮件传输</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">发送方：MAIL FROM:&lt;send@<span class="number">123.</span>com&gt;   <span class="comment">//使用MAIL命令，附上发件人地址，开始邮件的传送</span></span><br><span class="line">接收方：<span class="number">250</span> OK/<span class="number">451</span>(<span class="number">452</span>、<span class="number">200</span>)       <span class="comment">//SMTP服务器回复，是否已经准备好接收邮件（是/否）</span></span><br><span class="line">发送方：RCPT TO：&lt;receive@<span class="number">456.</span>com&gt; <span class="comment">//SMTP客户端回复一个或多个RCPT命令，确认用户是否接收</span></span><br><span class="line">接收方：<span class="number">250</span> OK/<span class="number">550</span> No such user here <span class="comment">//SMTP服务器确认是否接收</span></span><br><span class="line">发送方：DATA						<span class="comment">//SMTP客户表示要开始传输邮件内容</span></span><br><span class="line">接收方：<span class="number">354</span> start mail input;end with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; <span class="comment">//SMTP服务器同意传输并用&lt;CRLF&gt;.&lt;CRLF&gt;回车换行表示邮件内容的结束。</span></span><br><span class="line">发送方：date...						<span class="comment">//开始传输邮件内容</span></span><br><span class="line">接收方：<span class="number">250</span> OK						<span class="comment">//接收结束</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>连接释放</p>
<p>邮件发完，SMTP客户发送<strong>QUIT命令</strong>，SMTP服务器<strong>返回“221”</strong>，表示同意释放TCP连接。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>SMTP不能传送可执行文件或者其他二进制对象。</li>
<li>SMTP<strong>仅限于传送7位ASCII码</strong>，不能传送其他非英语国家的文字。</li>
<li>SMTP服务器会<strong>拒绝超过一定长度的邮件</strong>。</li>
</ul>
</li>
<li><p><strong>POP3（邮局协议）</strong></p>
<p>​ <strong>邮局协议</strong>（Post Office Protocol，POP）是一个非常简单但功能有限的<strong>邮件读取协议</strong>。</p>
<p>​ POP3采用的是**“拉”（Pull）<strong>的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，</strong>“拉”取用户邮箱中的邮件**。</p>
<p>​ 使用客户&#x2F;服务器，TCP连接，端口110。</p>
<p>工作方式：</p>
<ul>
<li><strong>下载并保留</strong>：用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件。</li>
<li><strong>下载并删除</strong>：邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取。</li>
</ul>
</li>
<li><p><strong>IMAP（因特网报文存取协议）</strong></p>
<p>​ IMAP协议比POP协议复杂。是一种复杂的<strong>邮件读取协议</strong>。</p>
<p>​ 客户&#x2F;服务器，TCP连接，端口号993</p>
<p>​ IMAP为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件等联机命令，为此IMAP服务器<strong>维护了会话用户的状态信息</strong>。</p>
<p>​ IMAP的另一特性是<strong>允许用户代理只获取报文的某些部分</strong>。当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到<strong>邮箱的首部</strong>，若用户需要打开某个邮件，该邮件才<strong>上传到用户的计算机</strong>上。</p>
<p>​ IMAP允许用户在多个客户端上管理同一个邮箱；IMAP可以访问服务器上的所有文件夹；IMAP可以实现邮件的部分下载，即只下载邮件的标题或正文。</p>
</li>
</ol>
<h5 id="6-4-3-电子邮件格式与MIME"><a href="#6-4-3-电子邮件格式与MIME" class="headerlink" title="6.4.3 电子邮件格式与MIME"></a>6.4.3 电子邮件格式与MIME</h5><ol>
<li><p>电子邮件格式</p>
<p>电子邮件分为<strong>信封</strong>和<strong>内容</strong>两大部分，邮件内容又分为<strong>首部</strong>和<strong>主体</strong>两部分。</p>
<p>RFC822 规定了邮件首部格式，而邮件的主体内容用户自由撰写。邮件系统自动将邮件信息提取到信封上。</p>
<p>邮件内容<strong>首部</strong>包含一些<strong>首部行</strong>，每个首部行由 关键字 : 值 关键字:值 关键字:值 组成。主要关键字有 To 和 Subject 。</p>
<ul>
<li><p><strong>To</strong>：是必需的关键字，后面填入一个或多个收件人的电子邮件地址。地址规定 收件人邮箱名 @ 主机域名 收件人邮箱名@主机域名 收件人邮箱名@主机域名，如 a b c @ 123. c o m <a href="mailto:&#x61;&#98;&#x63;&#64;&#x31;&#x32;&#51;&#46;&#99;&#x6f;&#109;">&#x61;&#98;&#x63;&#64;&#x31;&#x32;&#51;&#46;&#99;&#x6f;&#109;</a> <a href="mailto:&#x61;&#98;&#99;&#x40;&#x31;&#50;&#51;&#46;&#99;&#111;&#109;">&#x61;&#98;&#99;&#x40;&#x31;&#50;&#51;&#46;&#99;&#111;&#109;</a>，abc在123.com必须是唯一的。</p>
</li>
<li><p><strong>Subject</strong>：是可选关键字，邮件的主题。它反映了邮件的主要内容。</p>
</li>
<li><p><strong>From</strong>：必需关键字，由邮箱系统自动填入。</p>
</li>
</ul>
<p>主体与首部由一个空行进行分割。典型邮件格式如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5Cd52bc6e80ed1de2e3f3ef20a1453e699pngpic_center.jpg" alt="image-20230822092622377"></p>
</li>
<li><p><strong>多用途网际邮件扩充（MIME）</strong></p>
<p>​ 由于SMTP只能传送ASCII码邮件，为了传送其他国家文字字符，提出了多用途网际邮件扩充（MIME）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C8b93a2ac363b2e9ff5e41cd03e664180pngpic_center.jpg" alt="image-20230822093032337"></p>
<p>​ MIME并未改动SMTP或取代它。MIME的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了<strong>传送非ASCII码的编码规则</strong>。主要包括以下三部分：</p>
<ul>
<li><strong>5个新的邮件首部字段</strong>，包括MIME版本、内容描述、内容标识、传送编码和内容类型。</li>
<li>定义了<strong>许多邮件内容的格</strong>式，对多媒体电子邮件的表示方法进行了标准化。</li>
<li>定义了<strong>传送编码</strong>，可对任何内容格式进行转换，而不会被邮件系统改变。</li>
</ul>
</li>
</ol>
<h4 id="6-5-万维网（WWW）"><a href="#6-5-万维网（WWW）" class="headerlink" title="6.5 万维网（WWW）"></a>6.5 万维网（WWW）</h4><h5 id="6-5-1-WWW的概念与组成结构"><a href="#6-5-1-WWW的概念与组成结构" class="headerlink" title="6.5.1 WWW的概念与组成结构"></a>6.5.1 WWW的概念与组成结构</h5><p>​ 万维网（World Wide Web，WWW）是一个分布式、联机式的信息存储空间，在这个空间中：一样有用的事物称为一样“<strong>资源</strong>”，并由一个全域**“统一资源定位符”（URL）<strong>标识。这些资源通过</strong>超文本传输协议（HTTP）**传送给使用者，而后者通过单击链接来获取资源。</p>
<ul>
<li><p>万维网的内核部分是由三个标准构成的：</p>
<ul>
<li><strong>统一资源定位符（URL）</strong>：负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符URL。</li>
<li><strong>超文本传输协议（HTTP）</strong>：一个应用层协议，它使用TCP连接进行可靠的传输，HTTP是万维网客户程序和服务器程序之间交互所必须严格遵守的协议。</li>
<li><strong>超文本标记语言（HTML）</strong>：一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息（包括文字、声音、图像、视频等）、格式进行描述。</li>
</ul>
</li>
<li><p><strong>URL</strong>是对从因特网上得到的资源的位置和访问方法的一种简洁表示。一般形式如下：<br>&lt; 协议 &gt; : &#x2F; &#x2F; &lt; 主机 &gt; ： &lt; 端口 &gt; &#x2F; &lt; 路径 &gt; &lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt; &lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt;</p>
<ul>
<li>&lt;协议&gt;指用什么协议来获取万维网文档，常见的协议有http、ftp等</li>
<li>&lt;主机&gt;是存放资源的主机在因特网中的域名或IP地址</li>
<li>&lt;端口&gt;和&lt;路径&gt;有时可省略。<strong>在URL中不区分大小写。</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C23aaac87223e240ec00a096425f1dbfapngpic_center.jpg" alt="image-20230822104251564"></p>
<p>这里省略了默认的端口号80。</p>
</li>
<li><p>万维网以客户&#x2F;服务器方式工作。<strong>浏览器</strong>是在用户主机上的<strong>万维网客户程序</strong>，而<strong>万维网文档所驻留的主机</strong>则运行<strong>服务器程序</strong>，这台主机称为<strong>万维网服务器</strong>。工作流程如下：</p>
<ul>
<li>1）<strong>Web用户</strong>使用浏览器（指定URL）与Web服务器建立连接，并发送浏览请求。</li>
<li>2）<strong>Web服务器</strong>把URL转换为文件路径，并返回信息给Web浏览器。</li>
<li>3）通信完成，关闭连接。</li>
</ul>
</li>
</ul>
<h5 id="6-5-2-超文本传输协议（HTTP）"><a href="#6-5-2-超文本传输协议（HTTP）" class="headerlink" title="6.5.2 超文本传输协议（HTTP）"></a>6.5.2 超文本传输协议（HTTP）</h5><p>​ HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p>
<p>​ 基于客户&#x2F;服务器模式，基于TCP传输，默认80端口号。</p>
<ol>
<li><p>HTTP的操作过程</p>
<p>​ 浏览器要访问WWW服务器时，首先要完成对WWW服务器的域名解析。一旦获得了服务器的P地址，浏览器就通过TCP向服务器发送连接建立请求。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C37cf43b29ac59927788eb95ccaafbe98pngpic_center.jpg" alt="image-20230822110033961"></p>
<ul>
<li>1）浏览器分析链接指向页面的<strong>URL</strong>（<a target="_blank" rel="noopener" href="http://www.tsinghua.edu.cn/chn/index.htm%EF%BC%89%E3%80%82">http://www.tsinghua.edu.cn/chn/index.htm）。</a></li>
<li>2）<strong>浏览器向DNS请求解析</strong><a target="_blank" rel="noopener" href="http://www.tsinghua.edu.cn的ip地址./">www.tsinghua.edu.cn的IP地址。</a></li>
<li>3）域名系统DNS解析出清华大学服务器的<strong>IP地址</strong>。</li>
<li>4）浏览器与该服务器<strong>建立TCP连接</strong>（默认端口号为80）。</li>
<li>5）浏览器发出HTTP请求<strong>取出文件命令</strong>：GET&#x2F;chn&#x2F;index.htm。</li>
<li>6）服务器通过<strong>HTTP响应</strong>把文件index.htm发送给<strong>浏览器</strong>。</li>
<li>7）释放TCP连接。</li>
<li>8）浏览器解释文件index.htm，并将Web页显示给用户。</li>
</ul>
</li>
<li><p>HTTP的特点</p>
<ul>
<li><p>HTTP是<strong>无连接</strong>的</p>
<p>HTTP基于TCP连接，用来保证可靠传输，但本身是<strong>无连接</strong>的。也就是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。</p>
</li>
<li><p>HTTP是<strong>无状态</strong>的</p>
<p>同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。因为服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。</p>
<blockquote>
<p>但是在实际工作中，一些万维网站点常常希望能够识别用户</p>
<p><strong>Cookie</strong>：是存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码识别，如“123456”）的访问记录。 提供个性化服务。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>连接方式</p>
<ul>
<li><p>非持久连接</p>
<p>对于非持久连接，每个网页元素对象（如JPEG图形、Flash等）的传输都需要单独建立一个TCP连接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C6d531251538720cc8b4601339670e14dpngpic_center.jpg" alt="image-20230822111929479"><br>请求 w e b 文档所需时间 &#x3D; 传输时间 + 2 R T T 请求web文档所需时间&#x3D;传输时间+2RTT 请求web文档所需时间=传输时间+2RTT<br>​ <strong>请求一个万维网文档所需的时间</strong>是该文档的<strong>传输时间</strong>（与文档大小成正比）<strong>加上两倍往返时间RTT</strong>（一个RTT用于TCP连接，另一个RTT用于请求和接收文档）。</p>
<p>​ 每个对象引用都导致2×RTT的开销，此外每次建立新的TCP连接都要分配缓存和变量，使万<strong>维网服务器的负担很重</strong>。</p>
</li>
<li><p>持久连接</p>
<p>持久连接是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求和响应报文。</p>
<p>持久连接又分为非流水线和流水线两种方式。</p>
<ul>
<li><p><strong>非流水线方式</strong>：客户在收到前一个响应后才能发出下一个请求，服务器发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C9fc7a0a55c5b48b9c7dbbe37d1ff3d72pngpic_center.jpg" alt="image-20230822112353926"></p>
</li>
<li><p><strong>流水线方式</strong>：客户每遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对各个引用对象的请求。<strong>HTTP&#x2F;1.1的默认方式</strong>。</p>
<p>如果所有的请求和响应都是连续发送的，那么所有引用的对象共计经历1个RTT延迟，而不是像非流水线方式那样，每个引用都必须有1个RTT延迟。这种方式减少了TCP连接中的空闲时间，提高了效率。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP的报文结构</p>
<p>​ HTTP是<strong>面向文本</strong>的（Text-Oriented），因此报文中的每个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。有<strong>两类HTTP报文</strong>：</p>
<ul>
<li>请求报文：从客户向服务器发送的请求报文。</li>
<li>响应报文：从服务器到客户的回答。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C7ad4ee38d847d9754733507c8a290f01pngpic_center.jpg" alt="image-20230822112857308"></p>
<ul>
<li><p><strong>开始行</strong>：用于区分是<strong>请求报文</strong>还是<strong>响应报文</strong>。在请求报文中的开始行称为<strong>请求行</strong>，而在响应报文中的开始行称为<strong>状态行</strong>。开始行的三个字段之间都以空格分隔，最后的“CR”和“LF”分别代表**“回车”和“换行”**。</p>
<p>请求报文的“请求行”有三个内容：<strong>方法、请求资源的URL及HTTP的版本</strong>。其中，“方法”是对所请求对象进行的操作，这些方法实际上也就是一些命令。</p>
<table>
<thead>
<tr>
<th align="center">方法（操作）</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">请求读取由URL标识的信息</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">请求读取由URL标识的信息的首部</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">给服务器添加信息（如注释）</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">在指明的URL下存储一个文档</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">删除指明的URL所标志的资源</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="center">用于代理服务器</td>
</tr>
</tbody></table>
</li>
<li><p><strong>首部行</strong>：用来说明<strong>浏览器、服务器或报文主体的一些信息</strong>。首部可以有几行，但也可以不使用。</p>
<p>在每个首部行中都有<strong>首部字段名</strong>和它的<strong>值</strong>，每一行在结束的地方都要有**“回车”和“换行”<strong>。整个首部行结束时，还有一</strong>空行<strong>将首部行和后面的</strong>实体主体**分开。</p>
</li>
<li><p><strong>实体主体</strong>：在请求报文中一般不用这个字段，而在响应报文中也可能没有这个字段。</p>
</li>
<li><p><strong>状态码</strong>：状态行包括三项内容，即HTTP的版本，状态码，以及解释状态码的简单短语。</p>
<ul>
<li><strong>1xx</strong>：表示通知信息的，如请求收到了或正在处理。</li>
<li><strong>2xx</strong>：表示成功，如接受或知道了。</li>
<li><strong>3xx</strong>：表示重定向，如要完成请求还必须采取进一步的行动。</li>
<li><strong>4xx</strong>：表示客户的差错，如请求中有错误的语法或不能完成。</li>
<li><strong>5xx</strong>：表示服务器的差错，如服务器失效无法完成请求。</li>
</ul>
<p>下面三种状态行在响应报文中是经常见到的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C553b092d1c961bec82684e8a5f5b826epngpic_center.jpg" alt="image-20230822113915410"></p>
</li>
</ul>
<p>下面是一个完整的HTTP<strong>请求报文</strong>的例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C09459c87decadbae3dfd05ee2001f7a6pngpic_center.jpg" alt="image-20230822113638142"></p>
<p>​ 在<strong>请求行</strong>使用了相对URL（即省略了主机的域名）是因为下面的首部行（第2行）给出了<strong>主机的域名</strong>。第3行是告诉服务器<strong>不使用持续连接</strong>，表示浏览器希望服务器在传送完所请求的对象后即<strong>关闭TCP连接</strong>。这个请求报文<strong>没有实体主体</strong>。</p>
<p>若请求的网页转移到了一个新的地址，则响应报文的状态行和一个首部行就是下面的形式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images%5C64991388015605a8b43fc50eaeba4cfbpngpic_center.jpg" alt="image-20230822114133715"></p>
</li>
</ol>
<p><strong>常见应用层协议小结</strong>：</p>
<table>
<thead>
<tr>
<th align="center">应用程序</th>
<th align="center">FTP数据</th>
<th align="center">FTP控制</th>
<th align="center">TELNET</th>
<th align="center">SMTP</th>
<th align="center">DNS</th>
<th align="center">TFTP</th>
<th align="center">HTTP</th>
<th align="center">POP3</th>
<th align="center">SNMP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用协议</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">UDP</td>
<td align="center">UDP</td>
<td align="center">TCP</td>
<td align="center">TCP</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">熟知端口号</td>
<td align="center">20</td>
<td align="center">21</td>
<td align="center">23</td>
<td align="center">25</td>
<td align="center">53</td>
<td align="center">69</td>
<td align="center">80</td>
<td align="center">110</td>
<td align="center">161</td>
</tr>
</tbody></table>
<h1 id="第3章-MongoDB数据库操作"><a href="#第3章-MongoDB数据库操作" class="headerlink" title="第3章  MongoDB数据库操作"></a>第3章  MongoDB数据库操作</h1><h2 id="3-1-MongoDB部署"><a href="#3-1-MongoDB部署" class="headerlink" title="3.1  MongoDB部署"></a>3.1  MongoDB部署</h2><p>通过访问<a target="_blank" rel="noopener" href="https://www.mongodb.com/try/download/community">MongoDB官网</a>进入MongoDB下载页面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092222780-16858748815572.png" alt="image-20220409222224501"></p>
<p>Version：指定MongoDB版本，MongoDB的版本分为稳定版和开发板，本次安装使用稳定版4.2。<br>提示：版本的选择：<br>MongoDB的版本命名规范如：x.y.z；<br>y为奇数时表示当前版本为开发版，如：1.5.2、4.1.13；<br>y为偶数时表示当前版本为稳定版，如：1.6.3、4.0.10；<br>z是修正版本号，数字越大越好。</p>
<h3 id="GUI工具-NoSQLBooster-for-MongoDB"><a href="#GUI工具-NoSQLBooster-for-MongoDB" class="headerlink" title="GUI工具-NoSQLBooster for MongoDB"></a>GUI工具-NoSQLBooster for MongoDB</h3><p>当然你可以用可视化界面进行连接数据库。比如Studio 3T、NoSQL Manager for MongoDB、NoSQLBooster for MongoDB等GUI工具。</p>
<p>这里推荐使用NoSQLBooster for MongoDB（破解方法在群文件可下载）</p>
<ol>
<li>首先再次启动mongod服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mongod -f /usr/local/mongodb/standalone/mongod.conf</span><br><span class="line">about to fork child process, waiting <span class="keyword">until</span> server is ready <span class="keyword">for</span> connections.</span><br><span class="line">forked process: 8800</span><br><span class="line">child process started successfully, parent exiting</span><br><span class="line">[root@localhost ~]# ps -ef|grep mongod</span><br><span class="line">root       8800      1 46 22:59 ?        00:00:04 mongod -f /usr/local/mongodb/standalone/mongod.conf</span><br><span class="line">root       8845   7536  0 23:00 pts/0    00:00:00 grep --color=auto mongod</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开NoSQLBooster，新建单节点服务器配置并测试连接是否可通。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092223932.png" alt="image-20220409222327595"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092223497.png" alt="image-20220409222336307"></p>
<h2 id="3-2-数据库操作"><a href="#3-2-数据库操作" class="headerlink" title="3.2  数据库操作"></a>3.2  数据库操作</h2><h3 id="新建数据库、查看数据库、删除数据库"><a href="#新建数据库、查看数据库、删除数据库" class="headerlink" title="新建数据库、查看数据库、删除数据库"></a>新建数据库、查看数据库、删除数据库</h3><p>选择和创建数据库的语法格式：<br>​	<code>use 数据库名称</code></p>
<p>如果数据库不存在则自动创建，例如，以下语句创建 spitdb 数据库：<br>    <code>use articledb</code></p>
<p>查看有权限查看的所有的数据库命令:<br>​	<code>show dbs 或show databases</code></p>
<p>注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092223321.png" alt="image-20220409222352198"></p>
<p>查看当前正在使用的数据库命令:<br>    <code>db</code></p>
<p>MongoDB 中默认的数据库为 test，如果你没有选择数据库，集合将存放在 test 数据库中。</p>
<p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<ul>
<li><strong>admin</strong>：从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li><strong>local</strong>：（集群和分片时用）这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li><strong>config</strong>：当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<p>MongoDB 删除数据库的语法格式如下：<br>    <code>db.dropDatabase()</code><br>    提示：主要用来删除已经持久化的数据库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092224090.png" alt="image-20220409222409948"></p>
<h2 id="3-3-集合操作"><a href="#3-3-集合操作" class="headerlink" title="3.3  集合操作"></a>3.3  集合操作</h2><h3 id="创建集合、删除集合"><a href="#创建集合、删除集合" class="headerlink" title="创建集合、删除集合"></a>创建集合、删除集合</h3><p>集合，类似关系型数据库中的表。<br>可以显示的创建，也可以隐式的创建。</p>
<p><strong>集合的显式创建</strong>：<br>    <code>db.createCollection(name)</code><br>    参数说明：<br>        name: 要创建的集合名称<br>    例如：创建一个名为 mycollection 的普通集合。<br>        <code>db.createCollection(&quot;mycollection&quot;)</code><br>    查看当前库中的表：show tables命令<br>        <code>show collections 或show tables</code><br> <strong>集合的隐式创建</strong>：<br>    当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合	详见 文档的插入 章节。<br>    提示：通常我们使用隐式创建文档即可。</p>
<p><strong>集合的删除</strong>：<br>    <code>db.collection.drop() 或db.集合.drop()</code><br>    返回值<br>        如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。<br>    例如：要删除mycollection集合<br>        <code>db.mycollection.drop()</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092224957.png" alt="image-20220409222423826"></p>
<h2 id="3-4-文档的插入、更新与删除操作"><a href="#3-4-文档的插入、更新与删除操作" class="headerlink" title="3.4  文档的插入、更新与删除操作"></a>3.4  文档的插入、更新与删除操作</h2><h3 id="文档插入"><a href="#文档插入" class="headerlink" title="文档插入"></a>文档插入</h3><p>文档（document）的数据结构和 JSON 基本一样。所有存储在集合中的数据都是 BSON 格式。</p>
<p>insert()和save()方法的区别在于：</p>
<blockquote>
<p>​	若使用insert()方法插入文档时，集合中已存在该文档，则会报错。</p>
<p>​	若使用save()方法插入文档时，集合中已存在该文档，则会覆盖。</p>
</blockquote>
<h4 id="（1）单个文档插入"><a href="#（1）单个文档插入" class="headerlink" title="（1）单个文档插入"></a>（1）单个文档插入</h4><p>使用insert() 或 save() 方法向集合中插入文档，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert( </span><br><span class="line">　　<span class="operator">&lt;</span>document <span class="keyword">or</span> <span class="keyword">array</span> <span class="keyword">of</span> documents<span class="operator">&gt;</span>, </span><br><span class="line">　　　&#123; </span><br><span class="line">　　　　writeConcern: <span class="operator">&lt;</span>document<span class="operator">&gt;</span>, </span><br><span class="line">　　　　ordered: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span> </span><br><span class="line">　　　&#125; </span><br><span class="line">　)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092224031.png" alt="image-20220409222438847"><br>要向comment的集合(表)中插入一条测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insert(&#123;&quot;articleid&quot;:&quot;100000&quot;,&quot;content&quot;:&quot;今天天气真好，阳光明媚&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;nickname&quot;:&quot;Rose&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(),&quot;likenum&quot;:NumberInt(<span class="number">10</span>),&quot;state&quot;:<span class="keyword">null</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092224798.png" alt="image-20220409222452586"></p>
<p>提示：<br>　　1）comment集合如果不存在，则会隐式创建<br>　　2）mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。<br>　　3）插入当前日期使用 new Date()<br>　　4）插入的数据没有指定 _id ，会自动生成主键值<br>　　5）如果某字段没值，可以赋值为null，或不写该字段。</p>
<p>执行后，如下，说明插入一个数据成功了。WriteResult({ “nInserted” : 1 })</p>
<p>注意：</p>
<ol>
<li><p>文档中的键&#x2F;值对是有序的。</p>
</li>
<li><p>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 </p>
</li>
<li><p>MongoDB区分类型和大小写。</p>
</li>
<li><p>MongoDB的文档不能有重复的键。</p>
</li>
<li><p>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</p>
</li>
</ol>
<blockquote>
<p>文档键命名规范：<br> 键不能含有\0 (空字符)。这个字符用来表示键的结尾。<br> .和$有特别的意义，只有在特定环境下才能使用。<br> 以下划线”_”开头的键是保留的(不是严格要求的)。</p>
</blockquote>
<h4 id="（2）批量插入"><a href="#（2）批量插入" class="headerlink" title="（2）批量插入"></a>（2）批量插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insertMany( </span><br><span class="line">　　　[ <span class="operator">&lt;</span>document <span class="number">1</span><span class="operator">&gt;</span> , <span class="operator">&lt;</span>document <span class="number">2</span><span class="operator">&gt;</span>, ... ], </span><br><span class="line">　　　&#123; </span><br><span class="line">　　　　writeConcern: <span class="operator">&lt;</span>document<span class="operator">&gt;</span>, </span><br><span class="line">　　　　ordered: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span> </span><br><span class="line">　　　&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092225400.png" alt="image-20220409222516183"></p>
<p>【示例】<br>批量插入多条文章评论：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insertMany([ </span><br><span class="line">    &#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">1000</span>),&quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">888</span>),&quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船长&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-06T01:05:06.321Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">666</span>),&quot;state&quot;:&quot;1&quot;&#125;,</span><br><span class="line">    &#123;&quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-06T08:18:35.288Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">2000</span>),&quot;state&quot;:&quot;1&quot;&#125;,</span><br><span class="line">    &#123;&quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08- 06T11:01:02.521Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">3000</span>),&quot;state&quot;:&quot;1&quot;&#125; </span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br>插入时指定了 _id ，则主键就是该值。</p>
<p>如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。</p>
<p>因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。如（掌握）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123; </span><br><span class="line">db.comment.insertMany([ </span><br><span class="line">    &#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">1000</span>),&quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">888</span>),&quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">    &#123;&quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船长&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-06T01:05:06.321Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">666</span>),&quot;state&quot;:&quot;1&quot;&#125;,</span><br><span class="line">    &#123;&quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08-06T08:18:35.288Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">2000</span>),&quot;state&quot;:&quot;1&quot;&#125;,</span><br><span class="line">    &#123;&quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:<span class="keyword">new</span> <span class="type">Date</span>(&quot;2019-08- 06T11:01:02.521Z&quot;),&quot;likenum&quot;:NumberInt(<span class="number">3000</span>),&quot;state&quot;:&quot;1&quot;&#125; </span><br><span class="line">]);</span><br><span class="line">&#125; catch (e) &#123; </span><br><span class="line">    print (e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092225512.png" alt="image-20220409222532220"></p>
<h3 id="文档更新"><a href="#文档更新" class="headerlink" title="文档更新"></a>文档更新</h3><h4 id="（1）覆盖的修改"><a href="#（1）覆盖的修改" class="headerlink" title="（1）覆盖的修改"></a>（1）覆盖的修改</h4><p>如果我们想修改_id为1的记录，点赞量为1001，输入以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 先查询当前数据库中的数据</span><br><span class="line">db.comment.find();</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 执行命令测试文档的更新是否成功</span><br><span class="line">db.comment.update(&#123;_id:&quot;1&quot;&#125;,&#123;likenum:NumberInt(<span class="number">1001</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>这是原本的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092225416.png" alt="image-20220409222544179"></p>
<p>执行后，我们会发现，这条文档除了likenum字段其它字段都不见了，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092225535.png" alt="image-20220409222554318"></p>
<h4 id="（2）局部修改"><a href="#（2）局部修改" class="headerlink" title="（2）局部修改"></a>（2）局部修改</h4><p>为了解决这个问题，我们需要使用修改器$set来实现，命令如下：</p>
<p>我们想修改_id为2的记录，点赞数为889，输入以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;likenum:NumberInt(<span class="number">889</span>)&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092226938.png" alt="image-20220409222614721"></p>
<h4 id="（3）批量的修改"><a href="#（3）批量的修改" class="headerlink" title="（3）批量的修改"></a>（3）批量的修改</h4><p>更新所有用户为 1003 的用户的昵称为 张三 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>默认只修改第一条数据 </span><br><span class="line">db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;nickname:&quot;张三&quot;&#125;&#125;) </span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092226316.png" alt="image-20220409222629145"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>修改所有符合条件的数据 </span><br><span class="line">db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;nickname:&quot;法外狂徒张三&quot;&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>提示：如果不加后面的参数，则只更新符合条件的第一条记录</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092226292.png" alt="image-20220409222648026"></p>
<h4 id="（４）列值增长的修改"><a href="#（４）列值增长的修改" class="headerlink" title="（４）列值增长的修改"></a>（４）列值增长的修改</h4><p>如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用 $inc 运算符来实现。</p>
<p>需求：对3号数据的点赞数，每次递增1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.update(&#123;_id:&quot;3&quot;&#125;,&#123;$inc:&#123;likenum:NumberInt(<span class="number">1</span>)&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092227238.png" alt="image-20220409222706976"></p>
<h4 id="动手操作"><a href="#动手操作" class="headerlink" title="动手操作"></a>动手操作</h4><p>将键contect的值由</p>
<p>“研究表明，刚烧开的水千万不能喝，因为烫嘴。”</p>
<p>更新为</p>
<p>“喝水增加了尿量，能使有害物质及时排出体内”，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.update(&#123;&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫嘴。&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;&quot;content&quot;:&quot;喝水增加了尿量，能使有害物质及时排出体内&quot;&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092227178.png" alt="image-20220409222716947"></p>
<h3 id="文档删除"><a href="#文档删除" class="headerlink" title="文档删除"></a>文档删除</h3><p>删除文档的语法结构：</p>
<p>​			db.集合名称.remove(条件)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.remove(&#123;userid:&quot;1003&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092227639.png" alt="image-20220409222728373"></p>
<p>删除集合comment中键nickname为“爱德华”的文档，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.remove(&#123;&quot;nickname&quot;:&quot;爱德华&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>查看集合中所有文档，验证文档是否删除成功，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find()</span><br></pre></td></tr></table></figure>

<p>删除集合comment中全部文档，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>再次查看集合中所有文档，验证文档是否全部删除，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find()</span><br></pre></td></tr></table></figure>

<h2 id="3-5-文档查询"><a href="#3-5-文档查询" class="headerlink" title="3.5  文档查询"></a>3.5  文档查询</h2><h3 id="3-5-1-文档的简单查询"><a href="#3-5-1-文档的简单查询" class="headerlink" title="3.5.1 文档的简单查询"></a>3.5.1 文档的简单查询</h3><h4 id="（1）查询所有"><a href="#（1）查询所有" class="headerlink" title="（1）查询所有"></a>（1）查询所有</h4><p>如果我们要查询spit集合的所有文档，我们输入以下命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find()</span><br></pre></td></tr></table></figure>


<p>或</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。</p>
<p>如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。</p>
<p>如果我想按一定条件来查询，比如我想查询userid为1003的记录，怎么办？很简单！只 要在find()中添加参数即可，参数也是json格式，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:<span class="string">&#x27;1003&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>如果你只需要返回符合条件的第一条数据，我们可以使用findOne命令来实现，语法和find一样。<br>如：查询用户编号是1003的记录，但只最多返回符合条件的第一条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.findOne(&#123;userid:<span class="string">&#x27;1003&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="（2）投影查询（Projection-Query）："><a href="#（2）投影查询（Projection-Query）：" class="headerlink" title="（2）投影查询（Projection Query）："></a>（2）投影查询（Projection Query）：</h4><p>如果要查询结果返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）。<br>如：查询结果只显示 _id、userid、nickname :</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:<span class="number">1</span>,nickname:<span class="number">1</span>&#125;) </span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092228985.png" alt="image-20220409222803729"></p>
<p>默认 _id 会显示。<br>如：查询结果只显示 、userid、nickname ，不显示 _id ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:<span class="number">1</span>,nickname:<span class="number">1</span>,_id:<span class="number">0</span>&#125;) </span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092228609.png" alt="image-20220409222815370"></p>
<p>再例如：查询所有数据，但只显示 _id、userid、nickname :</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;&#125;,&#123;userid:<span class="number">1</span>,nickname:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092228386.png" alt="image-20220409222833135"></p>
<h3 id="3-5-2-文档更多查询"><a href="#3-5-2-文档更多查询" class="headerlink" title="3.5.2  文档更多查询"></a>3.5.2  文档更多查询</h3><h4 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h4><p>使用count()方法</p>
<p>【示例】<br>（1）统计所有记录数：<br>统计comment集合的所有的记录数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.<span class="built_in">count</span>()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092228990.png" alt="image-20220409222856806"></p>
<p>（2）按条件统计记录数：<br>例如：统计userid为1003的记录条数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.<span class="built_in">count</span>(&#123;userid:&quot;1003&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>提示：<br>默认情况下 count() 方法返回符合条件的全部记录条数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092229724.png" alt="image-20220409222908516"></p>
<h4 id="文档的分页列表查询"><a href="#文档的分页列表查询" class="headerlink" title="文档的分页列表查询"></a>文档的分页列表查询</h4><p>可以使用limit()方法来读取指定数量的数据，使用skip()方法来跳过指定数量的数据。</p>
<p>如果你想返回指定条数的记录，可以在find方法后调用limit来返回结果(TopN)，默认值20，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find().limit(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092229179.png" alt="image-20220409222925952"></p>
<p>skip方法同样接受一个数字参数作为跳过的记录条数。（前N个不要）,默认值是0</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find().<span class="keyword">skip</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092229752.png" alt="image-20220409222937538"></p>
<p>分页查询：需求：每页2个，第二页开始：跳过前两条数据，接着值显示3和4条数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>第一页 </span><br><span class="line">db.comment.find().<span class="keyword">skip</span>(<span class="number">0</span>).limit(<span class="number">2</span>) </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第二页 </span><br><span class="line">db.comment.find().<span class="keyword">skip</span>(<span class="number">2</span>).limit(<span class="number">2</span>) </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第三页 </span><br><span class="line">db.comment.find().<span class="keyword">skip</span>(<span class="number">4</span>).limit(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092230521.png" alt="image-20220409223002353"></p>
<h4 id="文档的排序查询"><a href="#文档的排序查询" class="headerlink" title="文档的排序查询"></a>文档的排序查询</h4><p>sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>
<p>例如：<br>对userid降序排列，并对访问量进行升序排列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find().sort(&#123;userid:<span class="number">-1</span>,likenum:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092230120.png" alt="image-20220409223017956"></p>
<p>对userid降序，对点赞数升序，查询结果按userid和likenum的条件限制	</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;&#125;,&#123;userid:<span class="number">1</span>,likenum:<span class="number">1</span>&#125;).sort(&#123;userid:<span class="number">-1</span>,likenum:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092230656.png" alt="image-20220409223033441"></p>
<p>提示：<br>skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()，和命令编写顺序无关。</p>
<h4 id="文档的正则复杂条件查询"><a href="#文档的正则复杂条件查询" class="headerlink" title="文档的正则复杂条件查询"></a>文档的正则复杂条件查询</h4><p>MongoDB的模糊查询是通过正则表达式的方式实现的。格式为：</p>
<p> <code>db.collection.find(&#123;field:/正则表达式/&#125;)</code> </p>
<p>或</p>
<p><code>db.集合.find(&#123;字段:/正则表达式/&#125;)</code>	</p>
<p>提示：正则表达式是js的语法，直接量的写法。</p>
<p>例如，我要查询评论内容包含“开水”的所有文档，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;content:<span class="operator">/</span>开水<span class="operator">/</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092230495.png" alt="image-20220409223053300"></p>
<p>如果要查询评论的内容中以“专家”开头的，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;content:<span class="operator">/</span><span class="operator">^</span>专家<span class="operator">/</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092231855.png" alt="image-20220409223108702"></p>
<h4 id="文档的比较查询"><a href="#文档的比较查询" class="headerlink" title="文档的比较查询"></a>文档的比较查询</h4><p>&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D; 这个操作符也是很常用的，格式如下:<br>db.集合名称.find({ “field” : { $gt: value }}) &#x2F;&#x2F; 大于: field &gt; value<br>db.集合名称.find({ “field” : { $lt: value }}) &#x2F;&#x2F; 小于: field &lt; value<br>db.集合名称.find({ “field” : { $gte: value }}) &#x2F;&#x2F; 大于等于: field &gt;&#x3D; value<br>db.集合名称.find({ “field” : { $lte: value }}) &#x2F;&#x2F; 小于等于: field &lt;&#x3D; value<br>db.集合名称.find({ “field” : { $ne: value }}) &#x2F;&#x2F; 不等于: field !&#x3D; value<br>示例：查询评论点赞数量大于700的记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;likenum:&#123;$gt:NumberInt(<span class="number">700</span>)&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092231798.png" alt="image-20220409223121625"></p>
<h4 id="文档的包含查询"><a href="#文档的包含查询" class="headerlink" title="文档的包含查询"></a>文档的包含查询</h4><p>包含使用$in操作符。 示例：查询评论的集合中userid字段包含1003或1004的文档</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&#123;$<span class="keyword">in</span>:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092231352.png" alt="image-20220409223135149"></p>
<p>不包含使用$nin操作符。 示例：查询评论集合中userid字段不包含1003和1004的文档</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&#123;$nin:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092231912.png" alt="image-20220409223146699"></p>
<h4 id="文档的条件连接查询"><a href="#文档的条件连接查询" class="headerlink" title="文档的条件连接查询"></a>文档的条件连接查询</h4><p>我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）格式为：<br>$and:[ { },{ },{ } ]<br>示例：查询评论集合中likenum大于等于700 并且小于2000的文档：　</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;$<span class="keyword">and</span>:[&#123;likenum:&#123;$gte:NumberInt(<span class="number">700</span>)&#125;&#125;,&#123;likenum:&#123;$lt:NumberInt(<span class="number">2000</span>)&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092231702.png" alt="image-20220409223159485"></p>
<p>如果两个以上条件之间是或者的关系，我们使用操作符进行关联，与前面and的使用方式相同格式为：<br>$or:[ { },{ },{ } ]<br>示例：查询评论集合中userid为1003，或者点赞数小于1000的文档记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;$<span class="keyword">or</span>:[ &#123;userid:&quot;1003&quot;&#125; ,&#123;likenum:&#123;$lt:<span class="number">1000</span>&#125; &#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092232620.png" alt="image-20220409223210452"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">选择切换数据库：use articledb </span><br><span class="line"></span><br><span class="line">插入数据：db.comment.insert(&#123;bson数据&#125;) </span><br><span class="line"></span><br><span class="line">查询所有数据：db.comment.find(); </span><br><span class="line"></span><br><span class="line">条件查询数据：db.comment.find(&#123;条件&#125;) </span><br><span class="line"></span><br><span class="line">查询符合条件的第一条记录：db.comment.findOne(&#123;条件&#125;) </span><br><span class="line"></span><br><span class="line">查询符合条件的前几条记录：db.comment.find(&#123;条件&#125;).limit(条数) </span><br><span class="line"></span><br><span class="line">查询符合条件的跳过的记录：db.comment.find(&#123;条件&#125;).<span class="keyword">skip</span>(条数) </span><br><span class="line"></span><br><span class="line">修改数据：db.comment.update(&#123;条件&#125;,&#123;修改后的数据&#125;) 或db.comment.update(&#123;条件&#125;,&#123;$<span class="keyword">set</span>:&#123;要修改部分的字段:数据&#125;) </span><br><span class="line"></span><br><span class="line">修改数据并自增某字段值：db.comment.update(&#123;条件&#125;,&#123;$inc:&#123;自增的字段:步进值&#125;&#125;) </span><br><span class="line"></span><br><span class="line">删除数据：db.comment.remove(&#123;条件&#125;) </span><br><span class="line"></span><br><span class="line">统计查询：db.comment.<span class="built_in">count</span>(&#123;条件&#125;) </span><br><span class="line"></span><br><span class="line">模糊查询：db.comment.find(&#123;字段名:<span class="operator">/</span>正则表达式<span class="operator">/</span>&#125;) </span><br><span class="line"></span><br><span class="line">条件比较运算：db.comment.find(&#123;字段名:&#123;$gt:值&#125;&#125;) </span><br><span class="line"></span><br><span class="line">包含查询：db.comment.find(&#123;字段名:&#123;$<span class="keyword">in</span>:[值<span class="number">1</span>，值<span class="number">2</span>]&#125;&#125;)或db.comment.find(&#123;字段名:&#123;$nin:[值<span class="number">1</span>，值<span class="number">2</span>]&#125;&#125;) 条件连接查询：db.comment.find(&#123;$<span class="keyword">and</span>:[&#123;条件<span class="number">1</span>&#125;,&#123;条件<span class="number">2</span>&#125;]&#125;)或db.comment.find(&#123;$<span class="keyword">or</span>:[&#123;条件<span class="number">1</span>&#125;,&#123;条件<span class="number">2</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-6-聚合操作"><a href="#3-6-聚合操作" class="headerlink" title="3.6  聚合操作"></a>3.6  聚合操作</h2><h3 id="3-6-1-常见管道操作符"><a href="#3-6-1-常见管道操作符" class="headerlink" title="3.6.1 常见管道操作符"></a>3.6.1 常见管道操作符</h3><p>聚合管道操作是将文档在一个管道处理完毕后，把处理的结果传递给下一个管道进行再次处理。聚合管道是使用不同的管道阶段操作器进行不同聚合操作，管道阶段操作器也可称为管道操作符，常见管道操作符如下表。</p>
<table>
<thead>
<tr>
<th><strong>常见管道操作符</strong></th>
<th><strong>相关说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>$group</td>
<td>将集合中的文档进行分组，便于后续统计结果</td>
</tr>
<tr>
<td>$limit</td>
<td>用于限制MongoDB聚合管道返回的文档数</td>
</tr>
<tr>
<td>$match</td>
<td>用于过滤数据，只输出符合条件的文档</td>
</tr>
<tr>
<td>$sort</td>
<td>将输入的文档先进行排序，再输出</td>
</tr>
<tr>
<td>$project</td>
<td>用于修改输入文档的结构（增加、删除字段等）和名称</td>
</tr>
<tr>
<td>$skip</td>
<td>在聚合管道中跳过指定数量的文档，并返回剩余的文档</td>
</tr>
</tbody></table>
<p>使用$group操作符，将集合comment中的文档按userid进行分组，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$userid&quot;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092304590.png" alt="image-20220409230428397"></p>
<p>使用$limit操作符，展示集合comment中前三个文档，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.aggregate(&#123;$limit:<span class="number">3</span>&#125;).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092304868.png" alt="image-20220409230440724"></p>
<p>使用$match操作符，将集合comment中键nickname的值为凯撒的文档查询出来，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.aggregate([&#123;$<span class="keyword">match</span>: &#123;nickname:&quot;凯撒&quot;&#125;&#125;])</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202209252238281.png" alt="image-20220925223846057"></p>
<p>使用$sort操作符，将集合comment中的文档按照键likenum的值进行降序排序，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.aggregate([&#123;$sort: &#123;likenum:<span class="number">-1</span>&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092335227.png" alt="image-20220409233558076"></p>
<p>使用$project操作符，展示集合comment中的文档，并且文档均不包含字段_id，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.aggregate([&#123;$project:&#123;&quot;_id&quot;:<span class="number">0</span>&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092336911.png" alt="image-20220409233610761"></p>
<p>使用$project操作符，展示集合comment中的_id为5、6的文档，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.aggregate(&#123;$<span class="keyword">skip</span>:<span class="number">4</span>&#125;).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092336817.png" alt="image-20220409233620651"></p>
<h3 id="3-6-2-常见管道表达式"><a href="#3-6-2-常见管道表达式" class="headerlink" title="3.6.2 常见管道表达式"></a>3.6.2 常见管道表达式</h3><p>管道阶段操作器的值被称为管道表达式，并且每个管道表达式都是一个文档结构，由字段名称、字段值和管道表达式组成。常见的管道表达式如下表。</p>
<table>
<thead>
<tr>
<th><strong>常见管道表达式</strong></th>
<th><strong>相关说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>$sum</td>
<td>用于计算总和</td>
</tr>
<tr>
<td>$avg</td>
<td>计算平均值</td>
</tr>
<tr>
<td>$min</td>
<td>获取集合中所有文档对应值的最小值</td>
</tr>
<tr>
<td>$max</td>
<td>获取集合中所有文档对应值的最大值</td>
</tr>
<tr>
<td>$push</td>
<td>用于在结果文档中插入值到一个数组中</td>
</tr>
<tr>
<td>$first</td>
<td>获取分组文档中的第一个文档</td>
</tr>
<tr>
<td>$last</td>
<td>获取分组文档中的最后一个文档</td>
</tr>
</tbody></table>
<p>切换的articledb数据库，向集合product中插入五个文档，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.product.insertMany([</span><br><span class="line">&#123;&quot;_id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;iPhone 8&quot;,&quot;price&quot;:<span class="number">3000</span>,&quot;type&quot;:&quot;电子通讯&quot;&#125;,</span><br><span class="line">&#123;&quot;_id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;adidas neo&quot;,&quot;price&quot;:<span class="number">700</span>,&quot;type&quot;:&quot;服装&quot;&#125;,</span><br><span class="line">&#123;&quot;_id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;nike air max 90&quot;,&quot;price&quot;:<span class="number">760</span>,&quot;type&quot;:&quot;服装&quot;&#125;,</span><br><span class="line">&#123;&quot;_id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;HuaWei mate30&quot;,&quot;price&quot;:<span class="number">5000</span>,&quot;type&quot;:&quot;电子通讯&quot;&#125;,</span><br><span class="line">&#123;&quot;_id&quot;:&quot;5&quot;,&quot;name&quot;:&quot;vivo x27&quot;,&quot;price&quot;:<span class="number">2000</span>,&quot;type&quot;:&quot;电子通讯&quot;&#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>使用$avg表达式，将集合product中的文档按类型type进行分组并计算各个分组的价格price总和，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.product.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$type&quot;,&quot;price&quot;:&#123;$sum:&quot;$price&quot;&#125;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092336095.png" alt="image-20220409233632925"></p>
<p>使用$avg表达式，将集合product中的文档按类型type进行分组，并计算各个分组的价格price平均值，具体命令如下。    </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.product.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$type&quot;,&quot;price&quot;:&#123;$avg:&quot;$price&quot;&#125;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092336247.png" alt="image-20220409233657061"></p>
<p>使用$min表达式，将集合product中的文档按类型type进行分组，并计算各个分组中价格price最小值，具体命令如下。    </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.product.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$type&quot;,&quot;price&quot;:&#123;$min:&quot;$price&quot;&#125;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092337973.png" alt="image-20220409233720824"></p>
<p>使用$max表达式，将集合product中的文档按类型type进行分组，并计算各个分组中价格price最大值，具体命令如下。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.product.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$type&quot;,&quot;price&quot;:&#123;$max:&quot;$price&quot;&#125;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092337624.png" alt="image-20220409233733408"></p>
<p>使用$push表达式，将集合product中的文档按类型type进行分组，并将各个分组的产品插入到一个数组tags中，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.product.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$type&quot;,&quot;tags&quot;:&#123;$push:&quot;$name&quot;&#125;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>



<p>使用$first表达式，将集合product中的文档按类型type进行分组，并获取各个分组中第一个产品，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.product.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$type&quot;,&quot;product&quot;:&#123;$<span class="keyword">first</span>:&quot;$name&quot;&#125;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092337247.png" alt="image-20220409233747075"></p>
<p>使用$last表达式，将集合product中的文档按类型type进行分组，并获取各个分组中最后一个产品，具体命令如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.product.aggregate([&#123;$<span class="keyword">group</span>:&#123;&quot;_id&quot;:&quot;$type&quot;,&quot;product&quot;:&#123;$<span class="keyword">last</span>:&quot;$name&quot;&#125;&#125;&#125;]).pretty()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092338346.png" alt="image-20220409233803181"></p>
<h3 id="3-6-3-Map-Reduce操作"><a href="#3-6-3-Map-Reduce操作" class="headerlink" title="3.6.3 Map-Reduce操作"></a>3.6.3 Map-Reduce操作</h3><p>MongoDB提供Map-Reduce操作来进行聚合操作。通常，Map-Reduce操作有两个阶段，即Map和Reduce阶段，其中Map阶段是对集合中的每个输入文档进行处理，处理结束后输出一个或多个结果，Reduce阶段是将Map阶段输出的一个或多个结果进行合并输出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092338434.png" alt="image-20220409233815254"></p>
<p>①query阶段，查询集合orders中字段status为A的文档</p>
<p>②map阶段，按照字段cust_id进行分组，将字段cust_id相同的amount值放到一个数组中</p>
<p>③reduce阶段，通过函数sum对每组的amount值进行求和</p>
<p>④output阶段，将结果输出到集合order_totals中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.mapReduce(</span><br><span class="line">    <span class="keyword">function</span>()&#123;emit(key,<span class="keyword">value</span>);&#125;,   <span class="operator">/</span><span class="operator">/</span>map函数</span><br><span class="line">    <span class="keyword">function</span>(key,<span class="keyword">values</span>)&#123;<span class="keyword">return</span> reduceFunction&#125;,	<span class="operator">/</span><span class="operator">/</span>reduce函数</span><br><span class="line">    &#123;</span><br><span class="line">        query:条件,</span><br><span class="line">        <span class="keyword">out</span>:New_COLLECTION_NAME,</span><br><span class="line">        sort:条件,</span><br><span class="line">        limit:number</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<p>查询集合comment中字段state为1的文档，按照字段nickname对文档进行分组，计算出每个评论者的评论条数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.comment.mapReduce(</span><br><span class="line">    <span class="keyword">function</span>()&#123;emit(this.nickname,<span class="number">1</span>);&#125;,</span><br><span class="line">    <span class="keyword">function</span>(key,<span class="keyword">values</span>)&#123;<span class="keyword">return</span> Array.<span class="built_in">sum</span>(<span class="keyword">values</span>)&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        query:&#123;state:&quot;1&quot;&#125;,</span><br><span class="line">        <span class="keyword">out</span>:&quot;comment_total&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>!<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092338387-168587504309254.png" alt="image-20220409233827209"></p>
<p>查询结果集合comment_total中的结果数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment_total.find()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092338921.png" alt="image-20220409233839762"></p>
<h2 id="3-7-使用索引优化查询"><a href="#3-7-使用索引优化查询" class="headerlink" title="3.7  使用索引优化查询"></a>3.7  使用索引优化查询</h2><h3 id="3-7-1-索引概述"><a href="#3-7-1-索引概述" class="headerlink" title="3.7.1 索引概述"></a>3.7.1 索引概述</h3><p>索引支持在MongoDB中高效地执行查询。如果没有索引，MongoDB必须执行<strong>全集合扫描</strong>，即扫描集合中的每个文档，以选择与查询语句匹配的文档。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。如果查询存在适当的索引，MongoDB可以使用该索引限制必须检查的文档数。</p>
<p>索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。索引存储特定字段或一组字段的值，按字段值排序。索引项的排序支持有效的相等匹配和基于范围的查询操作。此外，MongoDB还可以使用索引中的排序返回排序结果。官网文档：<a target="_blank" rel="noopener" href="https://docs.mongodb.com/manual/indexes/">https://docs.mongodb.com/manual/indexes/</a><br>了解：</p>
<p>MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree）。多路动态平衡树，简称B-Tree，效率高，尤其是可以最大提高磁盘io效率，所以大部分数据库的存储引擎都用b-tree作为索引的数据存储结构</p>
<h4 id="1-单字段索引"><a href="#1-单字段索引" class="headerlink" title="1.单字段索引"></a>1.单字段索引</h4><p>MongoDB支持在文档的单个字段上创建用户定义的升序&#x2F;降序索引，因此被称为单字段索引（Single Field Index）。默认情况下，MongoDB中所有集合在“_id”字段上都有一个索引，用户也可以根据自己的需求添加额外索引来支持重要的查询和操作。由于MongoDB可以从任何方向遍历索引，因此对于单个字段索引和排序操作来说，索引项的排序顺序（即升序或降序）并不重要。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092338127.png" alt="image-20220409233851983"></p>
<p>在集合collection中的字段score上创建了一个索引，并指定其为有序。</p>
<h4 id="2-复合索引"><a href="#2-复合索引" class="headerlink" title="2.复合索引"></a>2.复合索引</h4><p>MongoDB除了支持单字段索引外，还支持复合索引。所谓复合索引，就是包含多个字段的索引，一个复合索引最多可以包含31个字段。需要注意的是，若某字段属于哈希索引，则这时复合索引就不能包括该字段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092339430.png" alt="image-20220409233902263"></p>
<p>复合索引是由{userid:1，score:-1}组成的，因此复合索引首先按字段userid通过ascii码的形式进行升序排序，然后在每个字段userid的值内，按照score降序排序。</p>
<h3 id="3-7-2-索引操作"><a href="#3-7-2-索引操作" class="headerlink" title="3.7.2 索引操作"></a>3.7.2 索引操作</h3><h4 id="1-单字段索引-1"><a href="#1-单字段索引-1" class="headerlink" title="(1)单字段索引"></a>(1)单字段索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对 userid 字段建立索引,参数<span class="number">1</span>：按升序创建索引</span><br><span class="line">db.comment.createIndex(&#123;userid:<span class="number">1</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>可以查看一下</span><br><span class="line">db.comment.getIndexes()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092339642-168587519975060.png" alt="image-20220409233920405"></p>
<h4 id="2-复合索引-1"><a href="#2-复合索引-1" class="headerlink" title="(2)复合索引"></a>(2)复合索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对 userid 和 nickname 同时建立复合（Compound）索引</span><br><span class="line">db.comment.createIndex(&#123;userid:<span class="number">1</span>,nickname:<span class="number">-1</span>&#125;)</span><br><span class="line"></span><br><span class="line">db.comment.getIndexes()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092339099.png" alt="image-20220409233941859"></p>
<h4 id="3-索引的移除"><a href="#3-索引的移除" class="headerlink" title="(3) 索引的移除"></a>(3) 索引的移除</h4><p>说明：可以移除指定的索引，或移除所有索引</p>
<ol>
<li>指定索引的移除<br>【示例】<br>删除 comment 集合中 userid 字段上的升序索引：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.dropIndex(&#123;userid:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092339369.png" alt="image-20220409233954173"><br>查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.getIndexes()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>所有索引的移除<br>【示例】</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>删除集合中所有索引。</span><br><span class="line">db.comment.dropIndexes()</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询</span><br><span class="line">db.comment.getIndexes()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204092340964.png" alt="image-20220409234013821"></p>
<h2 id="3-8-使用Java操作MongoDB"><a href="#3-8-使用Java操作MongoDB" class="headerlink" title="3.8  使用Java操作MongoDB"></a>3.8  使用Java操作MongoDB</h2><h3 id="3-8-1-搭建Java环境"><a href="#3-8-1-搭建Java环境" class="headerlink" title="3.8.1 搭建Java环境"></a>3.8.1 搭建Java环境</h3><h4 id="JDK的卸载"><a href="#JDK的卸载" class="headerlink" title="JDK的卸载"></a>JDK的卸载</h4><p><strong>删除JDK的文件夹</strong></p>
<p>1、在控制面板–程序中，卸载java8的旧版本</p>
<p>2、然后找到安装路径后，直接删除</p>
<p><strong>删除环境变量的配置</strong></p>
<p>此电脑–高级系统设置–环境变量–删除JAVA_HOME</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202209282005013.png" alt="image-20220928200458817"></p>
<p>删除Path中关于java的目录</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202209282006855.png" alt="image-20220928200608756"></p>
<p><strong>测试是否卸载成功</strong></p>
<p>WIN + R 打开CMD，输入java -version 测试是否卸载成功。</p>
<h4 id="安装新版的JDK"><a href="#安装新版的JDK" class="headerlink" title="安装新版的JDK"></a>安装新版的JDK</h4><p>1<strong>、百度搜索JDK 8</strong></p>
<p>2<strong>、同意协议3、下载电脑对应的版本</strong></p>
<p>4<strong>、双击安装JDK</strong></p>
<p>5<strong>、记住安装路径（避免使用中文路径）</strong></p>
<p>6<strong>、配置环境变量</strong></p>
<p>1.此电脑–右键–属性–高级系统设置–环境变量</p>
<p>2.环境变量–&gt;JAVA_HOME</p>
<p>3.配置Path变量</p>
<p>新建 %JAVA_HOME%\bin</p>
<p>新建 %JAVA_HOME%\jre\bin</p>
<p>4.测试是否成功</p>
<p>CMD中，输入java -version</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202209282007557.png" alt="image-20220928200736501" style="zoom: 67%;" />

<h4 id="maven的安装"><a href="#maven的安装" class="headerlink" title="maven的安装"></a>maven的安装</h4><p>访问maven官网下载Windows系统下的Maven安装包，本书下载的是maven 3.8.3版本，即apache-maven-3.8.3-bin.zip安装包。</p>
<p>将Maven安装路径下的bin目录添加到系统环境变量的Path变量中，这里添加的C:\Environment\Maven\apache-maven-3.8.3\bin。</p>
<p>Maven环境变量配置完成后，在Windows的DOS窗口执行“mvn -version”命令，查看Maven是否安装配置成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204111616087.png" alt="image-20220411161618916"></p>
<p>修改Maven配置文件settings.xml，该文件位于Maven安装路径下的conf文件夹内，向配置文件中添加本地仓库路径和远程仓库路径，需要注意的是本地仓库路径需要提前创建。</p>
<p>本地仓库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204111617447.png" alt="image-20220411161724356"></p>
<p>远程仓库（可配阿里云-自行百度）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202204111617614.png" alt="image-20220411161755525"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置阿里云--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>      </span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    </span><br><span class="line">         <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven-central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven-spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven-spring<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Switchboard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss-public-repository-group<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Public Repository Group<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.org/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default-http-blocker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:http:*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://0.0.0.0/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-8-2-基于Java-API操作MongoDB"><a href="#3-8-2-基于Java-API操作MongoDB" class="headerlink" title="3.8.2 基于Java API操作MongoDB"></a>3.8.2 基于Java API操作MongoDB</h3><h4 id="idea项目建立"><a href="#idea项目建立" class="headerlink" title="idea项目建立"></a>idea项目建立</h4><p>配置IDEA工具，在IDEA安装完成后的界面，单击“Configure”→“Settings”→“Build，Execution，Deployment”→“Build Tools”→“Maven”，将Maven添加至IDEA工具中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202210090918163.png" alt="image-20221009091830802"></p>
<p>配置IDEA工具，在IDEA安装完成后的界面，“Configure”→“Structure for New Projects”→“Project”，将jdk添加至IDEA工具中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202210090921328.png" alt="image-20221009092138195"></p>
<p>打开IDEA工具，单击“Create New Project”→“Maven”，选择创建一个Maven项目。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202210090923343.png" alt="image-20221009092316062"></p>
<p>添加Maven项目的名称和指定项目的存储路径。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202210090926313.png" alt="image-20221009092651032"></p>
<p>完成Maven项目的创建。</p>
<p>在项目article中配置pom.xml文件，引入MongoDB相关的依赖和单元测试的<a target="_blank" rel="noopener" href="https://mvnrepository.com/">依赖</a>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202210090930524.png" alt="image-20221009093040265"></p>
<h2 id="3-9-项目实训-文章评论"><a href="#3-9-项目实训-文章评论" class="headerlink" title="3.9 项目实训  文章评论"></a>3.9 项目实训  文章评论</h2><h3 id="3-9-1-需要实现"><a href="#3-9-1-需要实现" class="headerlink" title="3.9.1 需要实现"></a>3.9.1 需要实现</h3><p>以下功能：</p>
<p>1）基本增删改查API</p>
<p>2）根据文章id查询评论</p>
<p>3）评论点赞</p>
<p>数据库：articledb</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://yicopap-images.oss-cn-beijing.aliyuncs.com/imgs/202204092346660.png" alt="image-20220409234637444"></p>
<h3 id="3-9-2-文章微服务模块搭建"><a href="#3-9-2-文章微服务模块搭建" class="headerlink" title="3.9.2 文章微服务模块搭建"></a>3.9.2 文章微服务模块搭建</h3><h4 id="（1）搭建项目工程article，并设置pom-xml引入依赖："><a href="#（1）搭建项目工程article，并设置pom-xml引入依赖：" class="headerlink" title="（1）搭建项目工程article，并设置pom.xml引入依赖："></a>（1）搭建项目工程article，并设置pom.xml引入依赖：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>article<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="（2）在article-src-main-resources下创建文件application-yml"><a href="#（2）在article-src-main-resources下创建文件application-yml" class="headerlink" title="（2）在article\src\main\resources下创建文件application.yml"></a>（2）在article\src\main\resources下创建文件application.yml</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  #数据源配置</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      uri: mongodb:<span class="comment">//192.168.28.101:27017/articledb</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）创建启动类"><a href="#（3）创建启动类" class="headerlink" title="（3）创建启动类"></a>（3）创建启动类</h4><p>在article\src\main\java下创建类cn.itcast.article.ArticleApplication（此处命名方法使用到包机制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ArticleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）启动项目，看是否能正常启动，控制台没有错误。"><a href="#（4）启动项目，看是否能正常启动，控制台没有错误。" class="headerlink" title="（4）启动项目，看是否能正常启动，控制台没有错误。"></a>（4）启动项目，看是否能正常启动，控制台没有错误。</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/202209282042307.png" alt="image-20220928204230064"></p>
<h3 id="3-9-3-文章评论实体类的编写"><a href="#3-9-3-文章评论实体类的编写" class="headerlink" title="3.9.3 文章评论实体类的编写"></a>3.9.3 文章评论实体类的编写</h3><p>在article\src\main\java下创建实体类，创建包cn.itcast.article，包下建包po用于存放实体类，创建实体类</p>
<p>cn.itcast.article.po.Comment</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.index.CompoundIndex;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.index.Indexed;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章评论实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//把一个java类声明为mongodb的文档，可以通过collection参数指定这个类对应的文档。</span></span><br><span class="line"><span class="comment">//@Document(collection=&quot;mongodb 对应 collection 名&quot;)</span></span><br><span class="line"><span class="comment">// 若未加 @Document ，该 bean save 到 mongo 的 comment collection</span></span><br><span class="line"><span class="comment">// 若添加 @Document ，则 save 到 comment collection</span></span><br><span class="line"><span class="meta">@Document(collection=&quot;comment&quot;)</span><span class="comment">//可以省略，如果省略，则默认使用类名小写映射集合</span></span><br><span class="line"><span class="comment">//复合索引</span></span><br><span class="line"><span class="meta">@CompoundIndex( def = &quot;&#123;&#x27;userid&#x27;: 1, &#x27;nickname&#x27;: -1&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comment</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//主键标识，该属性的值会自动对应mongodb的主键字段&quot;_id&quot;，如果该属性名就叫“id”,则该注解可以省略，否则必须写</span></span><br><span class="line"><span class="comment">//    @Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;<span class="comment">//主键</span></span><br><span class="line">    <span class="comment">//该属性对应mongodb的字段的名字，如果一致，则无需该注解</span></span><br><span class="line">    <span class="meta">@Field(&quot;content&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//吐槽内容</span></span><br><span class="line">    <span class="keyword">private</span> Date publishtime;<span class="comment">//发布日期</span></span><br><span class="line">    <span class="comment">//添加了一个单字段的索引</span></span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line">    <span class="keyword">private</span> String userid;<span class="comment">//发布人ID</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdatetime;<span class="comment">//评论的日期时间</span></span><br><span class="line">    <span class="keyword">private</span> Integer likenum;<span class="comment">//点赞数</span></span><br><span class="line">    <span class="keyword">private</span> Integer replynum;<span class="comment">//回复数</span></span><br><span class="line">    <span class="keyword">private</span> String state;<span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">private</span> String parentid;<span class="comment">//上级ID</span></span><br><span class="line">    <span class="keyword">private</span> String articleid;</span><br><span class="line">    <span class="comment">//getter and setter.....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getPublishtime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> publishtime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPublishtime</span><span class="params">(Date publishtime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.publishtime = publishtime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserid</span><span class="params">(String userid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userid = userid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNickname</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickname</span><span class="params">(String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LocalDateTime <span class="title function_">getCreatedatetime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createdatetime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreatedatetime</span><span class="params">(LocalDateTime createdatetime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createdatetime = createdatetime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getLikenum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> likenum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLikenum</span><span class="params">(Integer likenum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.likenum = likenum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getReplynum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> replynum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReplynum</span><span class="params">(Integer replynum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.replynum = replynum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParentid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParentid</span><span class="params">(String parentid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parentid = parentid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getArticleid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> articleid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArticleid</span><span class="params">(String articleid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.articleid = articleid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Comment&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, publishtime=&quot;</span> + publishtime +</span><br><span class="line">                <span class="string">&quot;, userid=&#x27;&quot;</span> + userid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, createdatetime=&quot;</span> + createdatetime +</span><br><span class="line">                <span class="string">&quot;, likenum=&quot;</span> + likenum +</span><br><span class="line">                <span class="string">&quot;, replynum=&quot;</span> + replynum +</span><br><span class="line">                <span class="string">&quot;, state=&#x27;&quot;</span> + state + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, parentid=&#x27;&quot;</span> + parentid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, articleid=&#x27;&quot;</span> + articleid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-9-4-文章评论的基本增删改查"><a href="#3-9-4-文章评论的基本增删改查" class="headerlink" title="3.9.4 文章评论的基本增删改查"></a>3.9.4 文章评论的基本增删改查</h3><h4 id="（1）创建数据访问接口-cn-itcast-article包下创建dao包，包下创建接口"><a href="#（1）创建数据访问接口-cn-itcast-article包下创建dao包，包下创建接口" class="headerlink" title="（1）创建数据访问接口 cn.itcast.article包下创建dao包，包下创建接口"></a>（1）创建数据访问接口 cn.itcast.article包下创建dao包，包下创建接口</h4><p>cn.itcast.article.dao.CommentRepository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.po.Comment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">//评论的dao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommentRepository</span> <span class="keyword">extends</span> <span class="title class_">MongoRepository</span>&lt;Comment,String &gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据父id，查询子评论的分页列表</span></span><br><span class="line">    Page&lt;Comment&gt; <span class="title function_">findByParentid</span><span class="params">(String parentid,Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）创建业务逻辑类-cn-itcast-article包下创建service包，包下创建类"><a href="#（2）创建业务逻辑类-cn-itcast-article包下创建service包，包下创建类" class="headerlink" title="（2）创建业务逻辑类 cn.itcast.article包下创建service包，包下创建类"></a>（2）创建业务逻辑类 cn.itcast.article包下创建service包，包下创建类</h4><p>cn.itcast.article.service.CommentService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.dao.CommentRepository;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.po.Comment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.query.Criteria;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.query.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.query.Update;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//评论的业务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentService</span> &#123;</span><br><span class="line">    <span class="comment">//注入dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentRepository commentRepository;</span><br><span class="line">    <span class="comment">//注入MongoTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存一个评论</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line">        <span class="comment">//如果需要自定义主键，可以在这里指定主键；如果不指定主键，MongoDB会自动生成主键</span></span><br><span class="line">        <span class="comment">//设置一些默认初始值。。。</span></span><br><span class="line">        <span class="comment">//调用dao</span></span><br><span class="line">        commentRepository.save(comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新评论</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line">        <span class="comment">//调用dao</span></span><br><span class="line">        commentRepository.save(comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除评论</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteCommentById</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="comment">//调用dao</span></span><br><span class="line">        commentRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有评论</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Comment&gt; <span class="title function_">findCommentList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用dao</span></span><br><span class="line">        <span class="keyword">return</span> commentRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询评论</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Comment <span class="title function_">findCommentById</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="comment">//调用dao</span></span><br><span class="line">        <span class="keyword">return</span> commentRepository.findById(id).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Page&lt;Comment&gt; <span class="title function_">findCommentListByParentid</span><span class="params">(String parentid,<span class="type">int</span> page,<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">//为什么要page-1？因为参数穿进去的是zero-based page index.，基于0开始的索引的页码</span></span><br><span class="line">        <span class="keyword">return</span> commentRepository.findByParentid(parentid,PageRequest.of(page-<span class="number">1</span>,size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点赞数+1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCommentLikenum</span><span class="params">(String id)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  查询条件</span></span><br><span class="line">        <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;_id&quot;</span>).is(id));</span><br><span class="line">        <span class="comment">//  更新条件</span></span><br><span class="line">        <span class="type">Update</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Update</span>();</span><br><span class="line">        <span class="comment">//对赞数列递增1</span></span><br><span class="line">        update.inc(<span class="string">&quot;likenum&quot;</span>);</span><br><span class="line">        <span class="comment">//更新点赞数</span></span><br><span class="line">        <span class="comment">//参数1：查询对象</span></span><br><span class="line">        <span class="comment">//参数2：更新对象</span></span><br><span class="line">        <span class="comment">//参数3：集合的名字或实体类的类型Comment.class</span></span><br><span class="line">        mongoTemplate.updateFirst(query,update,Comment.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）新建Junit测试类，测试保存和查询所有："><a href="#（3）新建Junit测试类，测试保存和查询所有：" class="headerlink" title="（3）新建Junit测试类，测试保存和查询所有："></a>（3）新建Junit测试类，测试保存和查询所有：</h4><p>在article\src\test\java下新建测试类cn.itcast.article.service.CommentServiceTest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.ArticleApplication;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.po.Comment;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试评论的业务层</span></span><br><span class="line"><span class="comment">//SpringBoot的Junit集成测试</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">//SpringBoot的测试环境初始化，参数：启动类</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = ArticleApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentServiceTest</span> &#123;</span><br><span class="line">    <span class="comment">//注入Service</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommentService commentService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindCommentList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Comment&gt; commentList = commentService.findCommentList();</span><br><span class="line">        System.out.println(commentList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Comment&gt; list = commentService.findCommentList();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试根据id查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindCommentById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Comment</span> <span class="variable">commentById</span> <span class="operator">=</span> commentService.findCommentById(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(commentById);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存一个评论</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveComment</span><span class="params">()</span>&#123;</span><br><span class="line">        Comment comment=<span class="keyword">new</span> <span class="title class_">Comment</span>();</span><br><span class="line">        comment.setArticleid(<span class="string">&quot;100000&quot;</span>);</span><br><span class="line">        comment.setContent(<span class="string">&quot;测试添加的数据&quot;</span>);</span><br><span class="line">        comment.setCreatedatetime(LocalDateTime.now());</span><br><span class="line">        comment.setUserid(<span class="string">&quot;1003&quot;</span>);</span><br><span class="line">        comment.setNickname(<span class="string">&quot;凯撒大帝&quot;</span>);</span><br><span class="line">        comment.setState(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        comment.setLikenum(<span class="number">0</span>);</span><br><span class="line">        comment.setReplynum(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        commentService.saveComment(comment);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试根据父id查询子评论的分页列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindCommentListByParentid</span><span class="params">()</span> &#123;</span><br><span class="line">        Page&lt;Comment&gt; page = commentService.findCommentListByParentid(<span class="string">&quot;3&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----总记录数：&quot;</span> + page.getTotalElements());</span><br><span class="line">        System.out.println(<span class="string">&quot;----当前页数据：&quot;</span> + page.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点赞数+1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateCommentLikenum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//对1号文档的点赞数+1</span></span><br><span class="line">        commentService.updateCommentLikenum(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加一条测试数据</p>
<p>根据上级ID查询文章评论的分页列表</p>
<p>插入一条测试数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insert([&#123;&quot;parentid&quot;:&quot;3&quot;,&quot;nickname&quot;:&quot;张三&quot;&#125;])</span><br></pre></td></tr></table></figure>



<p> MongoTemplate实现评论点赞</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Smith</div><div class="post-copyright__author_desc">人生太短，要干的事太多，我要争分夺秒</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://smithhs.cn/2024/09/23/2024-05-07-111/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://smithhs.cn/2024/09/23/2024-05-07-111/')">Smith</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/1.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/2.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://smithhs.cn/2024/09/23/2024-05-07-111/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Smith&amp;url=https://smithhs.cn/2024/09/23/2024-05-07-111/&amp;pic=data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://smithhs.cn" target="_blank">Smith</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/jupyter.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/08/2024-09-08-Redis%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/redis1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis使用手册</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/09/2024-10-09-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/DesignPatterns.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E7%9A%84%E9%A6%96%E5%B0%BE%E5%AE%9A%E7%95%8C%E7%AC%A6%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">3.2.2 字符填充的首尾定界符法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">3.2.4 违规编码法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">3.3 差错控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">3.3.1 检错编码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">3.4 流量控制与可靠传输机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">3.4.1 滑动窗口机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-%E5%8D%95%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.</span> <span class="toc-text">3.4.2 单帧滑动窗口与停止-等待协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-%E5%A4%9A%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%90%8E%E9%80%80N%E5%B8%A7%E5%8D%8F%E8%AE%AE%EF%BC%88GBN%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3.4.3 多帧滑动窗口与后退N帧协议（GBN）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-4-%E5%A4%9A%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE%EF%BC%88SR%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">3.4.4 多帧滑动窗口与选择重传协议（SR）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">3.5 介质访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-1-%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">3.5.1 信道划分介质访问控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-2-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">3.5.2 随机访问介质访问控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-3-%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%EF%BC%9A%E4%BB%A4%E7%89%8C%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">3.5.3 轮询访问：令牌传递协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number"></span> <span class="toc-text">3.6 局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-1-%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">3.6.1 局域网的基本概念和体系结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-2-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%8E-IEEE-802-3"><span class="toc-number">2.</span> <span class="toc-text">3.6.2 以太网与 IEEE 802.3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-3-IEEE-802-11%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">3.</span> <span class="toc-text">3.6.3 IEEE 802.11无线局域网</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-4-VLAN%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">3.6.4 VLAN基本概念与基本原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%B9%BF%E5%9F%9F%E7%BD%91"><span class="toc-number"></span> <span class="toc-text">3.7 广域网</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-1-%E5%B9%BF%E5%9F%9F%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">3.7.1 广域网基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-2-PPP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.</span> <span class="toc-text">3.7.2 PPP协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-3-HDLC%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">3.7.3 HDLC协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number"></span> <span class="toc-text">3.8 数据链路层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-1-%E7%BD%91%E6%A1%A5"><span class="toc-number">1.</span> <span class="toc-text">3.8.1 网桥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-2-%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">3.8.2 局域网交换机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number"></span> <span class="toc-text">4 网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8A%9F%E8%83%BD"><span class="toc-number"></span> <span class="toc-text">4.1 网络层功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94"><span class="toc-number">1.</span> <span class="toc-text">4.1.1 异构网络互联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91"><span class="toc-number">2.</span> <span class="toc-text">4.1.2 路由转发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3-SDN%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">4.1.3 SDN基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-4-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">4.1.4 拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E5%92%8C%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="toc-number"></span> <span class="toc-text">4.2 路由算法和路由协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">1.</span> <span class="toc-text">4.2.1 静态路由与动态路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-%E8%B7%9D%E7%A6%BB-%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">4.2.2 距离-向量路由算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">4.2.3 链路状态路由算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1"><span class="toc-number">4.</span> <span class="toc-text">4.2.4 层次路由</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-IPv4"><span class="toc-number"></span> <span class="toc-text">4.3 IPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-IPv4%E5%88%86%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">4.3.1 IPv4分组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-IPv4%E5%9C%B0%E5%9D%80%E4%B8%8ENAT"><span class="toc-number">2.</span> <span class="toc-text">4.3.2 IPv4地址与NAT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81CIDR"><span class="toc-number">3.</span> <span class="toc-text">4.3.3 子网划分与子网掩码、CIDR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-ARP%E3%80%81DHCP%E4%B8%8EICMP"><span class="toc-number">4.</span> <span class="toc-text">4.3.4 ARP、DHCP与ICMP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-IPv6"><span class="toc-number"></span> <span class="toc-text">4.4 IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-1-IPv6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">4.4.1 IPv6的主要特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-IPv6%E5%9C%B0%E5%9D%80"><span class="toc-number">2.</span> <span class="toc-text">4.4.2 IPv6地址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-IP%E7%BB%84%E6%92%AD"><span class="toc-number"></span> <span class="toc-text">4.5 IP组播</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-1-%E7%BB%84%E6%92%AD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">4.5.1 组播的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2-IP%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">2.</span> <span class="toc-text">4.5.2 IP组播地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-3-IGMP%E4%B8%8E%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">4.5.3 IGMP与组播路由算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E7%A7%BB%E5%8A%A8IP"><span class="toc-number"></span> <span class="toc-text">4.6 移动IP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-1-%E7%A7%BB%E5%8A%A8IP%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">4.6.1 移动IP的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-2-%E7%A7%BB%E5%8A%A8IP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">4.6.2 移动IP通信过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number"></span> <span class="toc-text">4.7 网络层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-1-%E5%86%B2%E7%AA%81%E5%9F%9F%E5%92%8C%E5%B9%BF%E6%92%AD%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">4.7.1 冲突域和广播域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">4.7.2 路由器的组成和功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-3-%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">4.7.3 路由表与路由转发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number"></span> <span class="toc-text">5 传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number"></span> <span class="toc-text">5.1 传输层提供的服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.</span> <span class="toc-text">5.1.1 传输层的功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E5%AF%BB%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">5.1.2 传输层的寻址与端口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-UDP%E5%8D%8F%E8%AE%AE"><span class="toc-number"></span> <span class="toc-text">5.2 UDP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-UDP%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">1.</span> <span class="toc-text">5.2.1 UDP数据报</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-UDP%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">5.2.2 UDP校验</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number"></span> <span class="toc-text">5.3 TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">5.3.1 TCP协议的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-TCP%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">5.3.2 TCP报文段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-3-TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">5.3.3 TCP连接管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-4-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">4.</span> <span class="toc-text">5.3.4 TCP可靠传输</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-5-TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">5.3.5 TCP流量控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-6-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">5.3.6 TCP拥塞控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number"></span> <span class="toc-text">6 应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">6.1 网络应用模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">6.1.1 客户&#x2F;服务器模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-P2P%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">6.1.2 P2P模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%EF%BC%88DNS%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">6.2 域名系统（DNS）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-1-%E5%B1%82%E6%AC%A1%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.</span> <span class="toc-text">6.2.1 层次域名空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">6.2.2 域名服务器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-3-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">6.2.3 域名解析过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88FTP%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">6.3 文件传输协议（FTP）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1-FTP%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">6.3.1 FTP的工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-2-%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.</span> <span class="toc-text">6.3.2 控制连接与数据连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">6.4 电子邮件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-1-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">6.4.1 电子邮件系统的组成结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-2-SMTP%E5%92%8CPOP3"><span class="toc-number">2.</span> <span class="toc-text">6.4.2 SMTP和POP3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-3-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8EMIME"><span class="toc-number">3.</span> <span class="toc-text">6.4.3 电子邮件格式与MIME</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E4%B8%87%E7%BB%B4%E7%BD%91%EF%BC%88WWW%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">6.5 万维网（WWW）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-1-WWW%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">6.5.1 WWW的概念与组成结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-2-%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88HTTP%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">6.5.2 超文本传输协议（HTTP）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">第3章  MongoDB数据库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-MongoDB%E9%83%A8%E7%BD%B2"><span class="toc-number"></span> <span class="toc-text">3.1  MongoDB部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GUI%E5%B7%A5%E5%85%B7-NoSQLBooster-for-MongoDB"><span class="toc-number"></span> <span class="toc-text">GUI工具-NoSQLBooster for MongoDB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">3.2  数据库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">新建数据库、查看数据库、删除数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">3.3  集合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E3%80%81%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88"><span class="toc-number"></span> <span class="toc-text">创建集合、删除集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%96%87%E6%A1%A3%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">3.4  文档的插入、更新与删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%8F%92%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">文档插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3%E6%8F%92%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">（1）单个文档插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">（2）批量插入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0"><span class="toc-number"></span> <span class="toc-text">文档更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%A6%86%E7%9B%96%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number"></span> <span class="toc-text">（1）覆盖的修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E4%BF%AE%E6%94%B9"><span class="toc-number"></span> <span class="toc-text">（2）局部修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%89%B9%E9%87%8F%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number"></span> <span class="toc-text">（3）批量的修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%EF%BC%94%EF%BC%89%E5%88%97%E5%80%BC%E5%A2%9E%E9%95%BF%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number"></span> <span class="toc-text">（４）列值增长的修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%89%8B%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">动手操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%88%A0%E9%99%A4"><span class="toc-number"></span> <span class="toc-text">文档删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">3.5  文档查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E6%96%87%E6%A1%A3%E7%9A%84%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">3.5.1 文档的简单查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89"><span class="toc-number"></span> <span class="toc-text">（1）查询所有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8A%95%E5%BD%B1%E6%9F%A5%E8%AF%A2%EF%BC%88Projection-Query%EF%BC%89%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">（2）投影查询（Projection Query）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E6%96%87%E6%A1%A3%E6%9B%B4%E5%A4%9A%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">3.5.2  文档更多查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">统计查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E5%88%86%E9%A1%B5%E5%88%97%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">文档的分页列表查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">文档的排序查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E6%AD%A3%E5%88%99%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">文档的正则复杂条件查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E6%AF%94%E8%BE%83%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">文档的比较查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E5%8C%85%E5%90%AB%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">文档的包含查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">文档的条件连接查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">3.6  聚合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%B8%B8%E8%A7%81%E7%AE%A1%E9%81%93%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number"></span> <span class="toc-text">3.6.1 常见管道操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%B8%B8%E8%A7%81%E7%AE%A1%E9%81%93%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">3.6.2 常见管道表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-Map-Reduce%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">3.6.3 Map-Reduce操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="toc-number"></span> <span class="toc-text">3.7  使用索引优化查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number"></span> <span class="toc-text">3.7.1 索引概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E5%AD%97%E6%AE%B5%E7%B4%A2%E5%BC%95"><span class="toc-number"></span> <span class="toc-text">1.单字段索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number"></span> <span class="toc-text">2.复合索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">3.7.2 索引操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E5%AD%97%E6%AE%B5%E7%B4%A2%E5%BC%95-1"><span class="toc-number"></span> <span class="toc-text">(1)单字段索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95-1"><span class="toc-number"></span> <span class="toc-text">(2)复合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%A7%BB%E9%99%A4"><span class="toc-number"></span> <span class="toc-text">(3) 索引的移除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9CMongoDB"><span class="toc-number"></span> <span class="toc-text">3.8  使用Java操作MongoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-%E6%90%AD%E5%BB%BAJava%E7%8E%AF%E5%A2%83"><span class="toc-number"></span> <span class="toc-text">3.8.1 搭建Java环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number"></span> <span class="toc-text">JDK的卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88%E7%9A%84JDK"><span class="toc-number"></span> <span class="toc-text">安装新版的JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#maven%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number"></span> <span class="toc-text">maven的安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-2-%E5%9F%BA%E4%BA%8EJava-API%E6%93%8D%E4%BD%9CMongoDB"><span class="toc-number"></span> <span class="toc-text">3.8.2 基于Java API操作MongoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#idea%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B"><span class="toc-number"></span> <span class="toc-text">idea项目建立</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD-%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA"><span class="toc-number"></span> <span class="toc-text">3.9 项目实训  文章评论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">3.9.1 需要实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-%E6%96%87%E7%AB%A0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97%E6%90%AD%E5%BB%BA"><span class="toc-number"></span> <span class="toc-text">3.9.2 文章微服务模块搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8Barticle%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AEpom-xml%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">（1）搭建项目工程article，并设置pom.xml引入依赖：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9C%A8article-src-main-resources%E4%B8%8B%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6application-yml"><span class="toc-number"></span> <span class="toc-text">（2）在article\src\main\resources下创建文件application.yml</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">（3）创建启动类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%9C%8B%E6%98%AF%E5%90%A6%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%B2%A1%E6%9C%89%E9%94%99%E8%AF%AF%E3%80%82"><span class="toc-number"></span> <span class="toc-text">（4）启动项目，看是否能正常启动，控制台没有错误。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-3-%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99"><span class="toc-number"></span> <span class="toc-text">3.9.3 文章评论实体类的编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-4-%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number"></span> <span class="toc-text">3.9.4 文章评论的基本增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3-cn-itcast-article%E5%8C%85%E4%B8%8B%E5%88%9B%E5%BB%BAdao%E5%8C%85%EF%BC%8C%E5%8C%85%E4%B8%8B%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number"></span> <span class="toc-text">（1）创建数据访问接口 cn.itcast.article包下创建dao包，包下创建接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%B1%BB-cn-itcast-article%E5%8C%85%E4%B8%8B%E5%88%9B%E5%BB%BAservice%E5%8C%85%EF%BC%8C%E5%8C%85%E4%B8%8B%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">（2）创建业务逻辑类 cn.itcast.article包下创建service包，包下创建类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%96%B0%E5%BB%BAJunit%E6%B5%8B%E8%AF%95%E7%B1%BB%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%BF%9D%E5%AD%98%E5%92%8C%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">（3）新建Junit测试类，测试保存和查询所有：</span></a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2024 By <a class="footer-bar-link" href="/" title="Smith" target="_blank">Smith</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/Smithhss/smithhs.github.io.git" title="Hexo">Hexo</a></div></div></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://smith-1315833455.cos.ap-beijing.myqcloud.com/blog/d20f536c64d06e5fcf4bfe2ec5dc25d.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">55</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于我</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8805965276" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=464586318&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.6/translate/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.14/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script>var meting_api = "https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r";
</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("07/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.5.3",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Smith 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";</script><script>//动态标题
let leaveTitle = '再看看嘛🌈！';
let backTitle = '欢迎回来✌️！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/waterfall.js/1.1.0/waterfall.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | Smith")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {if (typeof addFriendLinksInFooter === "function") {addFriendLinksInFooter();}}, 200)</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div></body></html>